"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.toRegExp = exports.expandAll = exports.expandN = exports.expand = exports.count = void 0;
var regexp_tree_1 = require("regexp-tree");
var Expander_1 = __importDefault(require("./Expander"));
var Expansion_1 = __importDefault(require("./Expansion"));
// Circular reference for spying/mocking in tests
var _1 = require(".");
var transforms_1 = __importDefault(require("./transforms"));
// From https://triin.net/2011/10/19/Meta_Regular_Expression
var regexAsStringPattern = /^\/([^/\[\\]|\\.|\[([^\]\\]|\\.)*\])*\/[a-z]*$/i;
/**
 * Calculate how many strings satisfy the regular expression pattern.
 * @param pattern The regular expression to expand
 * @return The total number of strings that satisfy the regular expression
 * @throws When pattern is invalid or unsupported syntax
 */
function count(pattern) {
    return _1.expand(pattern).count;
}
exports.count = count;
/**
 * Calculate strings that satisfy the regular expression pattern.
 * @param pattern The regular expression to expand
 * @return The Expansion of pattern
 * @throws When pattern is invalid or unsupported syntax
 */
function expand(pattern) {
    if (pattern === null) {
        return Expansion_1["default"].Empty;
    }
    else if (!pattern) {
        return Expansion_1["default"].Blank;
    }
    var patternFormatted = _1.toRegExp(pattern);
    // Run custom RegEx mutations in /transforms
    var transformed = regexp_tree_1.transform(patternFormatted, transforms_1["default"]);
    // Process the RegEx logic into a regexp-tree
    var parsed = regexp_tree_1.parse(transformed.toString());
    // Create an expansion generator with regex-to-strings
    var expander = new Expander_1["default"](parsed.flags);
    return expander.expandExpression(parsed.body);
}
exports.expand = expand;
/**
 * Calculate up to N strings that satisfy the regular expression pattern.
 * Return all strings or N strings, whichever is fewer.
 * @param pattern The regular expression to expand
 * @param maxExpansions The maximum number of expansions to return
 * @return A list of up to maxExpansions strings matched by pattern
 * @throws When pattern is invalid or unsupported syntax
 */
function expandN(pattern, maxExpansions) {
    var results = [];
    var generator = _1.expand(pattern).getIterator();
    var expansion = generator.next();
    while (!expansion.done && results.length < maxExpansions) {
        results.push(expansion.value);
        expansion = generator.next();
    }
    return results;
}
exports.expandN = expandN;
/**
 * Calculate all strings that satisfy the regular expression pattern.
 * @param pattern The regular expression to expand
 * @return A list of strings matched by pattern
 * @throws When pattern is invalid or unsupported syntax
 */
function expandAll(pattern) {
    return __spreadArray([], __read(_1.expand(pattern).getIterator()));
}
exports.expandAll = expandAll;
/**
 * Normalize a regular expression pattern to a format that regexp-tree can parse.
 * Distinguish RegEx-like strings (e.g. "/abc/i") from plain strings (e.g. "abc").
 * @param pattern The unnormalized regular expression pattern
 * @returns pattern as a RegExp or RegEx-like string
 */
function toRegExp(pattern) {
    if (pattern instanceof RegExp) {
        return pattern;
    }
    else if (regexAsStringPattern.test(pattern.trim())) {
        // The string looks like RegEx, e.g. "/abc/i"
        return regexp_tree_1.compatTranspile(pattern).toRegExp();
    }
    else {
        return "/" + pattern + "/";
    }
}
exports.toRegExp = toRegExp;
//# sourceMappingURL=pattern.js.map