import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports2, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism5 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return clone;
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return clone;
              default:
                return o;
            }
          },
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          insertBefore: function(inside, before, insert, root) {
            root = root || _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        hooks: {
          all: {},
          add: function(name, callback) {
            var hooks = _.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism5;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism5;
    }
    Prism5.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism5.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism5.languages.markup["entity"];
    Prism5.languages.markup["doctype"].inside["internal-subset"].inside = Prism5.languages.markup;
    Prism5.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism5.languages.markup.tag, "addInlined", {
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism5.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism5.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism5.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism5.languages.markup.tag, "addAttribute", {
      value: function(attrName, lang) {
        Prism5.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism5.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism5.languages.html = Prism5.languages.markup;
    Prism5.languages.mathml = Prism5.languages.markup;
    Prism5.languages.svg = Prism5.languages.markup;
    Prism5.languages.xml = Prism5.languages.extend("markup", {});
    Prism5.languages.ssml = Prism5.languages.xml;
    Prism5.languages.atom = Prism5.languages.xml;
    Prism5.languages.rss = Prism5.languages.xml;
    (function(Prism6) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism6.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
          }
        },
        "url": {
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism6.languages.css["atrule"].inside.rest = Prism6.languages.css;
      var markup = Prism6.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism5);
    Prism5.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism5.languages.javascript = Prism5.languages.extend("clike", {
      "class-name": [
        Prism5.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism5.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism5.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism5.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism5.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism5.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism5.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism5.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism5.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism5.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism5.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism5.languages.markup) {
      Prism5.languages.markup.tag.addInlined("script", "javascript");
      Prism5.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism5.languages.js = Prism5.languages.javascript;
    (function() {
      if (typeof Prism5 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism5.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism5.hooks.add("before-sanity-check", function(env) {
        var pre = env.element;
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension2 = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension2] || extension2;
          }
          Prism5.util.setLanguage(code, language);
          Prism5.util.setLanguage(pre, language);
          var autoloader = Prism5.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism5.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism5.plugins.fileHighlight = {
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism5.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism5.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism5.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/openapi-resolver/dist/openapi-resolver.browser.js
var require_openapi_resolver_browser = __commonJS({
  "node_modules/openapi-resolver/dist/openapi-resolver.browser.js"(exports2, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["OpenApiResolver"] = factory();
      else
        root["OpenApiResolver"] = factory();
    })(exports2, () => {
      return (() => {
        var __webpack_modules__ = {
          2258: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const $Ref = __webpack_require__2(6654);
            const Pointer = __webpack_require__2(5860);
            const url = __webpack_require__2(6930);
            module2.exports = bundle;
            function bundle(parser2, options2) {
              let inventory = [];
              crawl(parser2, "schema", parser2.$refs._root$Ref.path + "#", "#", 0, inventory, parser2.$refs, options2);
              remap(inventory);
            }
            function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options2) {
              let obj = key === null ? parent : parent[key];
              if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
                if ($Ref.isAllowed$Ref(obj)) {
                  inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options2);
                } else {
                  let keys = Object.keys(obj).sort((a, b) => {
                    if (a === "definitions") {
                      return -1;
                    } else if (b === "definitions") {
                      return 1;
                    } else {
                      return a.length - b.length;
                    }
                  });
                  for (let key2 of keys) {
                    let keyPath = Pointer.join(path, key2);
                    let keyPathFromRoot = Pointer.join(pathFromRoot, key2);
                    let value = obj[key2];
                    if ($Ref.isAllowed$Ref(value)) {
                      inventory$Ref(obj, key2, path, keyPathFromRoot, indirections, inventory, $refs, options2);
                    } else {
                      crawl(obj, key2, keyPath, keyPathFromRoot, indirections, inventory, $refs, options2);
                    }
                  }
                }
              }
            }
            function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options2) {
              let $ref = $refKey === null ? $refParent : $refParent[$refKey];
              let $refPath = url.resolve(path, $ref.$ref);
              let pointer = $refs._resolve($refPath, pathFromRoot, options2);
              if (pointer === null) {
                return;
              }
              let depth = Pointer.parse(pathFromRoot).length;
              let file = url.stripHash(pointer.path);
              let hash = url.getHash(pointer.path);
              let external = file !== $refs._root$Ref.path;
              let extended = $Ref.isExtended$Ref($ref);
              indirections += pointer.indirections;
              let existingEntry = findInInventory(inventory, $refParent, $refKey);
              if (existingEntry) {
                if (depth < existingEntry.depth || indirections < existingEntry.indirections) {
                  removeFromInventory(inventory, existingEntry);
                } else {
                  return;
                }
              }
              inventory.push({
                $ref,
                parent: $refParent,
                key: $refKey,
                pathFromRoot,
                depth,
                file,
                hash,
                value: pointer.value,
                circular: pointer.circular,
                extended,
                external,
                indirections
              });
              if (!existingEntry) {
                crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options2);
              }
            }
            function remap(inventory) {
              inventory.sort((a, b) => {
                if (a.file !== b.file) {
                  return a.file < b.file ? -1 : 1;
                } else if (a.hash !== b.hash) {
                  return a.hash < b.hash ? -1 : 1;
                } else if (a.circular !== b.circular) {
                  return a.circular ? -1 : 1;
                } else if (a.extended !== b.extended) {
                  return a.extended ? 1 : -1;
                } else if (a.indirections !== b.indirections) {
                  return a.indirections - b.indirections;
                } else if (a.depth !== b.depth) {
                  return a.depth - b.depth;
                } else {
                  let aDefinitionsIndex = a.pathFromRoot.lastIndexOf("/definitions");
                  let bDefinitionsIndex = b.pathFromRoot.lastIndexOf("/definitions");
                  if (aDefinitionsIndex !== bDefinitionsIndex) {
                    return bDefinitionsIndex - aDefinitionsIndex;
                  } else {
                    return a.pathFromRoot.length - b.pathFromRoot.length;
                  }
                }
              });
              let file, hash, pathFromRoot;
              for (let entry of inventory) {
                if (!entry.external) {
                  entry.$ref.$ref = entry.hash;
                } else if (entry.file === file && entry.hash === hash) {
                  entry.$ref.$ref = pathFromRoot;
                } else if (entry.file === file && entry.hash.indexOf(hash + "/") === 0) {
                  entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, "#")));
                } else {
                  file = entry.file;
                  hash = entry.hash;
                  pathFromRoot = entry.pathFromRoot;
                  entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);
                  if (entry.circular) {
                    entry.$ref.$ref = entry.pathFromRoot;
                  }
                }
              }
            }
            function findInInventory(inventory, $refParent, $refKey) {
              for (let i = 0; i < inventory.length; i++) {
                let existingEntry = inventory[i];
                if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {
                  return existingEntry;
                }
              }
            }
            function removeFromInventory(inventory, entry) {
              let index = inventory.indexOf(entry);
              inventory.splice(index, 1);
            }
          },
          6496: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const $Ref = __webpack_require__2(6654);
            const Pointer = __webpack_require__2(5860);
            const {
              ono
            } = __webpack_require__2(9978);
            const url = __webpack_require__2(6930);
            module2.exports = dereference;
            function dereference(parser2, options2) {
              let dereferenced = crawl(parser2.schema, parser2.$refs._root$Ref.path, "#", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Map(), parser2.$refs, options2);
              parser2.$refs.circular = dereferenced.circular;
              parser2.schema = dereferenced.value;
            }
            function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options2) {
              let dereferenced;
              let result = {
                value: obj,
                circular: false
              };
              if (options2.dereference.circular === "ignore" || !processedObjects.has(obj)) {
                if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
                  parents.add(obj);
                  processedObjects.add(obj);
                  if ($Ref.isAllowed$Ref(obj, options2)) {
                    dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options2);
                    result.circular = dereferenced.circular;
                    result.value = dereferenced.value;
                  } else {
                    for (const key of Object.keys(obj)) {
                      let keyPath = Pointer.join(path, key);
                      let keyPathFromRoot = Pointer.join(pathFromRoot, key);
                      let value = obj[key];
                      let circular = false;
                      if ($Ref.isAllowed$Ref(value, options2)) {
                        dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options2);
                        circular = dereferenced.circular;
                        if (obj[key] !== dereferenced.value) {
                          obj[key] = dereferenced.value;
                        }
                      } else {
                        if (!parents.has(value)) {
                          dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options2);
                          circular = dereferenced.circular;
                          if (obj[key] !== dereferenced.value) {
                            obj[key] = dereferenced.value;
                          }
                        } else {
                          circular = foundCircularReference(keyPath, $refs, options2);
                        }
                      }
                      result.circular = result.circular || circular;
                    }
                  }
                  parents.delete(obj);
                }
              }
              return result;
            }
            function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options2) {
              let $refPath = url.resolve(path, $ref.$ref);
              const cache = dereferencedCache.get($refPath);
              if (cache) {
                const refKeys = Object.keys($ref);
                if (refKeys.length > 1) {
                  const extraKeys = {};
                  for (let key of refKeys) {
                    if (key !== "$ref" && !(key in cache.value)) {
                      extraKeys[key] = $ref[key];
                    }
                  }
                  return {
                    circular: cache.circular,
                    value: Object.assign({}, cache.value, extraKeys)
                  };
                }
                return cache;
              }
              let pointer = $refs._resolve($refPath, path, options2);
              if (pointer === null) {
                return {
                  circular: false,
                  value: null
                };
              }
              let directCircular = pointer.circular;
              let circular = directCircular || parents.has(pointer.value);
              circular && foundCircularReference(path, $refs, options2);
              let dereferencedValue = $Ref.dereference($ref, pointer.value);
              if (!circular) {
                let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options2);
                circular = dereferenced.circular;
                dereferencedValue = dereferenced.value;
              }
              if (circular && !directCircular && options2.dereference.circular === "ignore") {
                dereferencedValue = $ref;
              }
              if (directCircular) {
                dereferencedValue.$ref = pathFromRoot;
              }
              const dereferencedObject = {
                circular,
                value: dereferencedValue
              };
              if (Object.keys($ref).length === 1) {
                dereferencedCache.set($refPath, dereferencedObject);
              }
              return dereferencedObject;
            }
            function foundCircularReference(keyPath, $refs, options2) {
              $refs.circular = true;
              if (!options2.dereference.circular) {
                throw ono.reference(`Circular $ref pointer found at ${keyPath}`);
              }
              return true;
            }
          },
          7455: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            const $Refs = __webpack_require__2(8031);
            const _parse = __webpack_require__2(3265);
            const normalizeArgs = __webpack_require__2(8575);
            const resolveExternal = __webpack_require__2(3747);
            const _bundle = __webpack_require__2(2258);
            const _dereference = __webpack_require__2(6496);
            const url = __webpack_require__2(6930);
            const {
              JSONParserError,
              InvalidPointerError,
              MissingPointerError,
              ResolverError,
              ParserError,
              UnmatchedParserError,
              UnmatchedResolverError,
              isHandledError,
              JSONParserErrorGroup
            } = __webpack_require__2(5554);
            const maybe = __webpack_require__2(4606);
            const {
              ono
            } = __webpack_require__2(9978);
            module2.exports = $RefParser;
            module2.exports["default"] = $RefParser;
            module2.exports.JSONParserError = JSONParserError;
            module2.exports.InvalidPointerError = InvalidPointerError;
            module2.exports.MissingPointerError = MissingPointerError;
            module2.exports.ResolverError = ResolverError;
            module2.exports.ParserError = ParserError;
            module2.exports.UnmatchedParserError = UnmatchedParserError;
            module2.exports.UnmatchedResolverError = UnmatchedResolverError;
            function $RefParser() {
              this.schema = null;
              this.$refs = new $Refs();
            }
            $RefParser.parse = function parse(path, schema, options2, callback) {
              let Class = this;
              let instance = new Class();
              return instance.parse.apply(instance, arguments);
            };
            $RefParser.prototype.parse = async function parse(path, schema, options2, callback) {
              let args = normalizeArgs(arguments);
              let promise;
              if (!args.path && !args.schema) {
                let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);
                return maybe(args.callback, Promise.reject(err));
              }
              this.schema = null;
              this.$refs = new $Refs();
              let pathType = "http";
              if (url.isFileSystemPath(args.path)) {
                args.path = url.fromFileSystemPath(args.path);
                pathType = "file";
              }
              args.path = url.resolve(url.cwd(), args.path);
              if (args.schema && typeof args.schema === "object") {
                let $ref = this.$refs._add(args.path);
                $ref.value = args.schema;
                $ref.pathType = pathType;
                promise = Promise.resolve(args.schema);
              } else {
                promise = _parse(args.path, this.$refs, args.options);
              }
              let me = this;
              try {
                let result = await promise;
                if (result !== null && typeof result === "object" && !Buffer2.isBuffer(result)) {
                  me.schema = result;
                  return maybe(args.callback, Promise.resolve(me.schema));
                } else if (args.options.continueOnError) {
                  me.schema = null;
                  return maybe(args.callback, Promise.resolve(me.schema));
                } else {
                  throw ono.syntax(`"${me.$refs._root$Ref.path || result}" is not a valid JSON Schema`);
                }
              } catch (err) {
                if (!args.options.continueOnError || !isHandledError(err)) {
                  return maybe(args.callback, Promise.reject(err));
                }
                if (this.$refs._$refs[url.stripHash(args.path)]) {
                  this.$refs._$refs[url.stripHash(args.path)].addError(err);
                }
                return maybe(args.callback, Promise.resolve(null));
              }
            };
            $RefParser.resolve = function resolve2(path, schema, options2, callback) {
              let Class = this;
              let instance = new Class();
              return instance.resolve.apply(instance, arguments);
            };
            $RefParser.prototype.resolve = async function resolve2(path, schema, options2, callback) {
              let me = this;
              let args = normalizeArgs(arguments);
              try {
                await this.parse(args.path, args.schema, args.options);
                await resolveExternal(me, args.options);
                finalize(me);
                return maybe(args.callback, Promise.resolve(me.$refs));
              } catch (err) {
                return maybe(args.callback, Promise.reject(err));
              }
            };
            $RefParser.bundle = function bundle(path, schema, options2, callback) {
              let Class = this;
              let instance = new Class();
              return instance.bundle.apply(instance, arguments);
            };
            $RefParser.prototype.bundle = async function bundle(path, schema, options2, callback) {
              let me = this;
              let args = normalizeArgs(arguments);
              try {
                await this.resolve(args.path, args.schema, args.options);
                _bundle(me, args.options);
                finalize(me);
                return maybe(args.callback, Promise.resolve(me.schema));
              } catch (err) {
                return maybe(args.callback, Promise.reject(err));
              }
            };
            $RefParser.dereference = function dereference(path, schema, options2, callback) {
              let Class = this;
              let instance = new Class();
              return instance.dereference.apply(instance, arguments);
            };
            $RefParser.prototype.dereference = async function dereference(path, schema, options2, callback) {
              let me = this;
              let args = normalizeArgs(arguments);
              try {
                await this.resolve(args.path, args.schema, args.options);
                _dereference(me, args.options);
                finalize(me);
                return maybe(args.callback, Promise.resolve(me.schema));
              } catch (err) {
                return maybe(args.callback, Promise.reject(err));
              }
            };
            function finalize(parser2) {
              const errors = JSONParserErrorGroup.getParserErrors(parser2);
              if (errors.length > 0) {
                throw new JSONParserErrorGroup(parser2);
              }
            }
          },
          8575: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const Options = __webpack_require__2(8316);
            module2.exports = normalizeArgs;
            function normalizeArgs(args) {
              let path, schema, options2, callback;
              args = Array.prototype.slice.call(args);
              if (typeof args[args.length - 1] === "function") {
                callback = args.pop();
              }
              if (typeof args[0] === "string") {
                path = args[0];
                if (typeof args[2] === "object") {
                  schema = args[1];
                  options2 = args[2];
                } else {
                  schema = void 0;
                  options2 = args[1];
                }
              } else {
                path = "";
                schema = args[0];
                options2 = args[1];
              }
              if (!(options2 instanceof Options)) {
                options2 = new Options(options2);
              }
              return {
                path,
                schema,
                options: options2,
                callback
              };
            }
          },
          8316: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const jsonParser = __webpack_require__2(9324);
            const yamlParser = __webpack_require__2(8015);
            const textParser = __webpack_require__2(4844);
            const binaryParser = __webpack_require__2(4486);
            const fileResolver = __webpack_require__2(9571);
            const httpResolver = __webpack_require__2(6796);
            module2.exports = $RefParserOptions;
            function $RefParserOptions(options2) {
              merge2(this, $RefParserOptions.defaults);
              merge2(this, options2);
            }
            $RefParserOptions.defaults = {
              parse: {
                json: jsonParser,
                yaml: yamlParser,
                text: textParser,
                binary: binaryParser
              },
              resolve: {
                file: fileResolver,
                http: httpResolver,
                external: true
              },
              continueOnError: false,
              dereference: {
                circular: true
              }
            };
            function merge2(target, source) {
              if (isMergeable(source)) {
                let keys = Object.keys(source);
                for (let i = 0; i < keys.length; i++) {
                  let key = keys[i];
                  let sourceSetting = source[key];
                  let targetSetting = target[key];
                  if (isMergeable(sourceSetting)) {
                    target[key] = merge2(targetSetting || {}, sourceSetting);
                  } else if (sourceSetting !== void 0) {
                    target[key] = sourceSetting;
                  }
                }
              }
              return target;
            }
            function isMergeable(val) {
              return val && typeof val === "object" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);
            }
          },
          3265: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            const {
              ono
            } = __webpack_require__2(9978);
            const url = __webpack_require__2(6930);
            const plugins = __webpack_require__2(6250);
            const {
              ResolverError,
              ParserError,
              UnmatchedParserError,
              UnmatchedResolverError,
              isHandledError
            } = __webpack_require__2(5554);
            module2.exports = parse;
            async function parse(path, $refs, options2) {
              path = url.stripHash(path);
              let $ref = $refs._add(path);
              let file = {
                url: path,
                extension: url.getExtension(path)
              };
              try {
                const resolver = await readFile(file, options2, $refs);
                $ref.pathType = resolver.plugin.name;
                file.data = resolver.result;
                const parser2 = await parseFile(file, options2, $refs);
                $ref.value = parser2.result;
                return parser2.result;
              } catch (err) {
                if (isHandledError(err)) {
                  $ref.value = err;
                }
                throw err;
              }
            }
            function readFile(file, options2, $refs) {
              return new Promise((resolve2, reject) => {
                let resolvers = plugins.all(options2.resolve);
                resolvers = plugins.filter(resolvers, "canRead", file);
                plugins.sort(resolvers);
                plugins.run(resolvers, "read", file, $refs).then(resolve2, onError);
                function onError(err) {
                  if (!err && options2.continueOnError) {
                    reject(new UnmatchedResolverError(file.url));
                  } else if (!err || !("error" in err)) {
                    reject(ono.syntax(`Unable to resolve $ref pointer "${file.url}"`));
                  } else if (err.error instanceof ResolverError) {
                    reject(err.error);
                  } else {
                    reject(new ResolverError(err, file.url));
                  }
                }
              });
            }
            function parseFile(file, options2, $refs) {
              return new Promise((resolve2, reject) => {
                let allParsers = plugins.all(options2.parse);
                let filteredParsers = plugins.filter(allParsers, "canParse", file);
                let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
                plugins.sort(parsers);
                plugins.run(parsers, "parse", file, $refs).then(onParsed, onError);
                function onParsed(parser2) {
                  if (!parser2.plugin.allowEmpty && isEmpty(parser2.result)) {
                    reject(ono.syntax(`Error parsing "${file.url}" as ${parser2.plugin.name}. 
Parsed value is empty`));
                  } else {
                    resolve2(parser2);
                  }
                }
                function onError(err) {
                  if (!err && options2.continueOnError) {
                    reject(new UnmatchedParserError(file.url));
                  } else if (!err || !("error" in err)) {
                    reject(ono.syntax(`Unable to parse ${file.url}`));
                  } else if (err.error instanceof ParserError) {
                    reject(err.error);
                  } else {
                    reject(new ParserError(err.error.message, file.url));
                  }
                }
              });
            }
            function isEmpty(value) {
              return value === void 0 || typeof value === "object" && Object.keys(value).length === 0 || typeof value === "string" && value.trim().length === 0 || Buffer2.isBuffer(value) && value.length === 0;
            }
          },
          4486: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            let BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
            module2.exports = {
              order: 400,
              allowEmpty: true,
              canParse(file) {
                return Buffer2.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
              },
              parse(file) {
                if (Buffer2.isBuffer(file.data)) {
                  return file.data;
                } else {
                  return Buffer2.from(file.data);
                }
              }
            };
          },
          9324: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            const {
              ParserError
            } = __webpack_require__2(5554);
            module2.exports = {
              order: 100,
              allowEmpty: true,
              canParse: ".json",
              async parse(file) {
                let data = file.data;
                if (Buffer2.isBuffer(data)) {
                  data = data.toString();
                }
                if (typeof data === "string") {
                  if (data.trim().length === 0) {
                    return;
                  } else {
                    try {
                      return JSON.parse(data);
                    } catch (e) {
                      throw new ParserError(e.message, file.url);
                    }
                  }
                } else {
                  return data;
                }
              }
            };
          },
          4844: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            const {
              ParserError
            } = __webpack_require__2(5554);
            let TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
            module2.exports = {
              order: 300,
              allowEmpty: true,
              encoding: "utf8",
              canParse(file) {
                return (typeof file.data === "string" || Buffer2.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
              },
              parse(file) {
                if (typeof file.data === "string") {
                  return file.data;
                } else if (Buffer2.isBuffer(file.data)) {
                  return file.data.toString(this.encoding);
                } else {
                  throw new ParserError("data is not text", file.url);
                }
              }
            };
          },
          8015: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            const {
              ParserError
            } = __webpack_require__2(5554);
            const yaml = __webpack_require__2(7949);
            module2.exports = {
              order: 200,
              allowEmpty: true,
              canParse: [".yaml", ".yml", ".json"],
              async parse(file) {
                let data = file.data;
                if (Buffer2.isBuffer(data)) {
                  data = data.toString();
                }
                if (typeof data === "string") {
                  try {
                    return yaml.load(data);
                  } catch (e) {
                    throw new ParserError(e.message, file.url);
                  }
                } else {
                  return data;
                }
              }
            };
          },
          5860: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            module2.exports = Pointer;
            const $Ref = __webpack_require__2(6654);
            const url = __webpack_require__2(6930);
            const {
              JSONParserError,
              InvalidPointerError,
              MissingPointerError,
              isHandledError
            } = __webpack_require__2(5554);
            const slashes = /\//g;
            const tildes = /~/g;
            const escapedSlash = /~1/g;
            const escapedTilde = /~0/g;
            function Pointer($ref, path, friendlyPath) {
              this.$ref = $ref;
              this.path = path;
              this.originalPath = friendlyPath || path;
              this.value = void 0;
              this.circular = false;
              this.indirections = 0;
            }
            Pointer.prototype.resolve = function(obj, options2, pathFromRoot) {
              let tokens = Pointer.parse(this.path, this.originalPath);
              this.value = unwrapOrThrow(obj);
              for (let i = 0; i < tokens.length; i++) {
                if (resolveIf$Ref(this, options2)) {
                  this.path = Pointer.join(this.path, tokens.slice(i));
                }
                if (typeof this.value === "object" && this.value !== null && "$ref" in this.value) {
                  return this;
                }
                let token = tokens[i];
                if (this.value[token] === void 0 || this.value[token] === null) {
                  this.value = null;
                  throw new MissingPointerError(token, this.originalPath);
                } else {
                  this.value = this.value[token];
                }
              }
              if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {
                resolveIf$Ref(this, options2);
              }
              return this;
            };
            Pointer.prototype.set = function(obj, value, options2) {
              let tokens = Pointer.parse(this.path);
              let token;
              if (tokens.length === 0) {
                this.value = value;
                return value;
              }
              this.value = unwrapOrThrow(obj);
              for (let i = 0; i < tokens.length - 1; i++) {
                resolveIf$Ref(this, options2);
                token = tokens[i];
                if (this.value && this.value[token] !== void 0) {
                  this.value = this.value[token];
                } else {
                  this.value = setValue(this, token, {});
                }
              }
              resolveIf$Ref(this, options2);
              token = tokens[tokens.length - 1];
              setValue(this, token, value);
              return obj;
            };
            Pointer.parse = function(path, originalPath) {
              let pointer = url.getHash(path).substr(1);
              if (!pointer) {
                return [];
              }
              pointer = pointer.split("/");
              for (let i = 0; i < pointer.length; i++) {
                pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, "/").replace(escapedTilde, "~"));
              }
              if (pointer[0] !== "") {
                throw new InvalidPointerError(pointer, originalPath === void 0 ? path : originalPath);
              }
              return pointer.slice(1);
            };
            Pointer.join = function(base, tokens) {
              if (base.indexOf("#") === -1) {
                base += "#";
              }
              tokens = Array.isArray(tokens) ? tokens : [tokens];
              for (let i = 0; i < tokens.length; i++) {
                let token = tokens[i];
                base += "/" + encodeURIComponent(token.replace(tildes, "~0").replace(slashes, "~1"));
              }
              return base;
            };
            function resolveIf$Ref(pointer, options2) {
              if ($Ref.isAllowed$Ref(pointer.value, options2)) {
                let $refPath = url.resolve(pointer.path, pointer.value.$ref);
                if ($refPath === pointer.path) {
                  pointer.circular = true;
                } else {
                  let resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options2);
                  if (resolved === null) {
                    return false;
                  }
                  pointer.indirections += resolved.indirections + 1;
                  if ($Ref.isExtended$Ref(pointer.value)) {
                    pointer.value = $Ref.dereference(pointer.value, resolved.value);
                    return false;
                  } else {
                    pointer.$ref = resolved.$ref;
                    pointer.path = resolved.path;
                    pointer.value = resolved.value;
                  }
                  return true;
                }
              }
            }
            function setValue(pointer, token, value) {
              if (pointer.value && typeof pointer.value === "object") {
                if (token === "-" && Array.isArray(pointer.value)) {
                  pointer.value.push(value);
                } else {
                  pointer.value[token] = value;
                }
              } else {
                throw new JSONParserError(`Error assigning $ref pointer "${pointer.path}". 
Cannot set "${token}" of a non-object.`);
              }
              return value;
            }
            function unwrapOrThrow(value) {
              if (isHandledError(value)) {
                throw value;
              }
              return value;
            }
          },
          6654: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(2076);
            module2.exports = $Ref;
            const Pointer = __webpack_require__2(5860);
            const {
              InvalidPointerError,
              isHandledError,
              normalizeError
            } = __webpack_require__2(5554);
            const {
              safePointerToPath,
              stripHash,
              getHash
            } = __webpack_require__2(6930);
            function $Ref() {
              this.path = void 0;
              this.value = void 0;
              this.$refs = void 0;
              this.pathType = void 0;
              this.errors = void 0;
            }
            $Ref.prototype.addError = function(err) {
              if (this.errors === void 0) {
                this.errors = [];
              }
              const existingErrors = this.errors.map((_ref) => {
                let {
                  footprint
                } = _ref;
                return footprint;
              });
              if (Array.isArray(err.errors)) {
                this.errors.push(...err.errors.map(normalizeError).filter((_ref2) => {
                  let {
                    footprint
                  } = _ref2;
                  return !existingErrors.includes(footprint);
                }));
              } else if (!existingErrors.includes(err.footprint)) {
                this.errors.push(normalizeError(err));
              }
            };
            $Ref.prototype.exists = function(path, options2) {
              try {
                this.resolve(path, options2);
                return true;
              } catch (e) {
                return false;
              }
            };
            $Ref.prototype.get = function(path, options2) {
              return this.resolve(path, options2).value;
            };
            $Ref.prototype.resolve = function(path, options2, friendlyPath, pathFromRoot) {
              let pointer = new Pointer(this, path, friendlyPath);
              try {
                return pointer.resolve(this.value, options2, pathFromRoot);
              } catch (err) {
                if (!options2 || !options2.continueOnError || !isHandledError(err)) {
                  throw err;
                }
                if (err.path === null) {
                  err.path = safePointerToPath(getHash(pathFromRoot));
                }
                if (err instanceof InvalidPointerError) {
                  err.source = stripHash(pathFromRoot);
                }
                this.addError(err);
                return null;
              }
            };
            $Ref.prototype.set = function(path, value) {
              let pointer = new Pointer(this, path);
              this.value = pointer.set(this.value, value);
            };
            $Ref.is$Ref = function(value) {
              return value && typeof value === "object" && typeof value.$ref === "string" && value.$ref.length > 0;
            };
            $Ref.isExternal$Ref = function(value) {
              return $Ref.is$Ref(value) && value.$ref[0] !== "#";
            };
            $Ref.isAllowed$Ref = function(value, options2) {
              if ($Ref.is$Ref(value)) {
                if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
                  return true;
                } else if (value.$ref[0] !== "#" && (!options2 || options2.resolve.external)) {
                  return true;
                }
              }
            };
            $Ref.isExtended$Ref = function(value) {
              return $Ref.is$Ref(value) && Object.keys(value).length > 1;
            };
            $Ref.dereference = function($ref, resolvedValue) {
              if (resolvedValue && typeof resolvedValue === "object" && $Ref.isExtended$Ref($ref)) {
                let merged = {};
                for (let key of Object.keys($ref)) {
                  if (key !== "$ref") {
                    merged[key] = $ref[key];
                  }
                }
                for (let key of Object.keys(resolvedValue)) {
                  if (!(key in merged)) {
                    merged[key] = resolvedValue[key];
                  }
                }
                return merged;
              } else {
                return resolvedValue;
              }
            };
          },
          8031: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const {
              ono
            } = __webpack_require__2(9978);
            const $Ref = __webpack_require__2(6654);
            const url = __webpack_require__2(6930);
            module2.exports = $Refs;
            function $Refs() {
              this.circular = false;
              this._$refs = {};
              this._root$Ref = null;
            }
            $Refs.prototype.paths = function(types2) {
              let paths = getPaths(this._$refs, arguments);
              return paths.map((path) => {
                return path.decoded;
              });
            };
            $Refs.prototype.values = function(types2) {
              let $refs = this._$refs;
              let paths = getPaths($refs, arguments);
              return paths.reduce((obj, path) => {
                obj[path.decoded] = $refs[path.encoded].value;
                return obj;
              }, {});
            };
            $Refs.prototype.toJSON = $Refs.prototype.values;
            $Refs.prototype.exists = function(path, options2) {
              try {
                this._resolve(path, "", options2);
                return true;
              } catch (e) {
                return false;
              }
            };
            $Refs.prototype.get = function(path, options2) {
              return this._resolve(path, "", options2).value;
            };
            $Refs.prototype.set = function(path, value) {
              let absPath = url.resolve(this._root$Ref.path, path);
              let withoutHash = url.stripHash(absPath);
              let $ref = this._$refs[withoutHash];
              if (!$ref) {
                throw ono(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
              }
              $ref.set(absPath, value);
            };
            $Refs.prototype._add = function(path) {
              let withoutHash = url.stripHash(path);
              let $ref = new $Ref();
              $ref.path = withoutHash;
              $ref.$refs = this;
              this._$refs[withoutHash] = $ref;
              this._root$Ref = this._root$Ref || $ref;
              return $ref;
            };
            $Refs.prototype._resolve = function(path, pathFromRoot, options2) {
              let absPath = url.resolve(this._root$Ref.path, path);
              let withoutHash = url.stripHash(absPath);
              let $ref = this._$refs[withoutHash];
              if (!$ref) {
                throw ono(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
              }
              return $ref.resolve(absPath, options2, path, pathFromRoot);
            };
            $Refs.prototype._get$Ref = function(path) {
              path = url.resolve(this._root$Ref.path, path);
              let withoutHash = url.stripHash(path);
              return this._$refs[withoutHash];
            };
            function getPaths($refs, types2) {
              let paths = Object.keys($refs);
              types2 = Array.isArray(types2[0]) ? types2[0] : Array.prototype.slice.call(types2);
              if (types2.length > 0 && types2[0]) {
                paths = paths.filter((key) => {
                  return types2.indexOf($refs[key].pathType) !== -1;
                });
              }
              return paths.map((path) => {
                return {
                  encoded: path,
                  decoded: $refs[path].pathType === "file" ? url.toFileSystemPath(path, true) : path
                };
              });
            }
          },
          3747: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const $Ref = __webpack_require__2(6654);
            const Pointer = __webpack_require__2(5860);
            const parse = __webpack_require__2(3265);
            const url = __webpack_require__2(6930);
            const {
              isHandledError
            } = __webpack_require__2(5554);
            module2.exports = resolveExternal;
            function resolveExternal(parser2, options2) {
              if (!options2.resolve.external) {
                return Promise.resolve();
              }
              try {
                let promises = crawl(parser2.schema, parser2.$refs._root$Ref.path + "#", parser2.$refs, options2);
                return Promise.all(promises);
              } catch (e) {
                return Promise.reject(e);
              }
            }
            function crawl(obj, path, $refs, options2, seen) {
              seen = seen || /* @__PURE__ */ new Set();
              let promises = [];
              if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {
                seen.add(obj);
                if ($Ref.isExternal$Ref(obj)) {
                  promises.push(resolve$Ref(obj, path, $refs, options2));
                } else {
                  for (let key of Object.keys(obj)) {
                    let keyPath = Pointer.join(path, key);
                    let value = obj[key];
                    if ($Ref.isExternal$Ref(value)) {
                      promises.push(resolve$Ref(value, keyPath, $refs, options2));
                    } else {
                      promises = promises.concat(crawl(value, keyPath, $refs, options2, seen));
                    }
                  }
                }
              }
              return promises;
            }
            async function resolve$Ref($ref, path, $refs, options2) {
              let resolvedPath = url.resolve(path, $ref.$ref);
              let withoutHash = url.stripHash(resolvedPath);
              $ref = $refs._$refs[withoutHash];
              if ($ref) {
                return Promise.resolve($ref.value);
              }
              try {
                const result = await parse(resolvedPath, $refs, options2);
                let promises = crawl(result, withoutHash + "#", $refs, options2);
                return Promise.all(promises);
              } catch (err) {
                if (!options2.continueOnError || !isHandledError(err)) {
                  throw err;
                }
                if ($refs._$refs[withoutHash]) {
                  err.source = url.stripHash(path);
                  err.path = url.safePointerToPath(url.getHash(path));
                }
                return [];
              }
            }
          },
          9571: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            const fs = __webpack_require__2(3471);
            const {
              ono
            } = __webpack_require__2(9978);
            const url = __webpack_require__2(6930);
            const {
              ResolverError
            } = __webpack_require__2(5554);
            module2.exports = {
              order: 100,
              canRead(file) {
                return url.isFileSystemPath(file.url);
              },
              read(file) {
                return new Promise((resolve2, reject) => {
                  let path;
                  try {
                    path = url.toFileSystemPath(file.url);
                  } catch (err) {
                    reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));
                  }
                  try {
                    fs.readFile(path, (err, data) => {
                      if (err) {
                        reject(new ResolverError(ono(err, `Error opening file "${path}"`), path));
                      } else {
                        resolve2(data);
                      }
                    });
                  } catch (err) {
                    reject(new ResolverError(ono(err, `Error opening file "${path}"`), path));
                  }
                });
              }
            };
          },
          6796: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            const http = __webpack_require__2(5262);
            const https = __webpack_require__2(9804);
            const {
              ono
            } = __webpack_require__2(9978);
            const url = __webpack_require__2(6930);
            const {
              ResolverError
            } = __webpack_require__2(5554);
            module2.exports = {
              order: 200,
              headers: null,
              timeout: 5e3,
              redirects: 5,
              withCredentials: false,
              canRead(file) {
                return url.isHttp(file.url);
              },
              read(file) {
                let u = url.parse(file.url);
                if (process2.browser && !u.protocol) {
                  u.protocol = url.parse(location.href).protocol;
                }
                return download(u, this);
              }
            };
            function download(u, httpOptions, redirects) {
              return new Promise((resolve2, reject) => {
                u = url.parse(u);
                redirects = redirects || [];
                redirects.push(u.href);
                get(u, httpOptions).then((res) => {
                  if (res.statusCode >= 400) {
                    throw ono({
                      status: res.statusCode
                    }, `HTTP ERROR ${res.statusCode}`);
                  } else if (res.statusCode >= 300) {
                    if (redirects.length > httpOptions.redirects) {
                      reject(new ResolverError(ono({
                        status: res.statusCode
                      }, `Error downloading ${redirects[0]}. 
Too many redirects: 
  ${redirects.join(" \n  ")}`)));
                    } else if (!res.headers.location) {
                      throw ono({
                        status: res.statusCode
                      }, `HTTP ${res.statusCode} redirect with no location header`);
                    } else {
                      let redirectTo = url.resolve(u, res.headers.location);
                      download(redirectTo, httpOptions, redirects).then(resolve2, reject);
                    }
                  } else {
                    resolve2(res.body || Buffer2.alloc(0));
                  }
                }).catch((err) => {
                  reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));
                });
              });
            }
            function get(u, httpOptions) {
              return new Promise((resolve2, reject) => {
                let protocol2 = u.protocol === "https:" ? https : http;
                let req = protocol2.get({
                  hostname: u.hostname,
                  port: u.port,
                  path: u.path,
                  auth: u.auth,
                  protocol: u.protocol,
                  headers: httpOptions.headers || {},
                  withCredentials: httpOptions.withCredentials
                });
                if (typeof req.setTimeout === "function") {
                  req.setTimeout(httpOptions.timeout);
                }
                req.on("timeout", () => {
                  req.abort();
                });
                req.on("error", reject);
                req.once("response", (res) => {
                  res.body = Buffer2.alloc(0);
                  res.on("data", (data) => {
                    res.body = Buffer2.concat([res.body, Buffer2.from(data)]);
                  });
                  res.on("error", reject);
                  res.on("end", () => {
                    resolve2(res);
                  });
                });
              });
            }
          },
          5554: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            const {
              Ono
            } = __webpack_require__2(9978);
            const {
              stripHash,
              toFileSystemPath
            } = __webpack_require__2(6930);
            const JSONParserError = exports3.JSONParserError = class JSONParserError extends Error {
              constructor(message, source) {
                super();
                this.code = "EUNKNOWN";
                this.message = message;
                this.source = source;
                this.path = null;
                Ono.extend(this);
              }
              get footprint() {
                return `${this.path}+${this.source}+${this.code}+${this.message}`;
              }
            };
            setErrorName(JSONParserError);
            const JSONParserErrorGroup = exports3.JSONParserErrorGroup = class JSONParserErrorGroup2 extends Error {
              constructor(parser2) {
                super();
                this.files = parser2;
                this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${toFileSystemPath(parser2.$refs._root$Ref.path)}'`;
                Ono.extend(this);
              }
              static getParserErrors(parser2) {
                const errors = [];
                for (const $ref of Object.values(parser2.$refs._$refs)) {
                  if ($ref.errors) {
                    errors.push(...$ref.errors);
                  }
                }
                return errors;
              }
              get errors() {
                return JSONParserErrorGroup2.getParserErrors(this.files);
              }
            };
            setErrorName(JSONParserErrorGroup);
            const ParserError = exports3.ParserError = class ParserError extends JSONParserError {
              constructor(message, source) {
                super(`Error parsing ${source}: ${message}`, source);
                this.code = "EPARSER";
              }
            };
            setErrorName(ParserError);
            const UnmatchedParserError = exports3.UnmatchedParserError = class UnmatchedParserError extends JSONParserError {
              constructor(source) {
                super(`Could not find parser for "${source}"`, source);
                this.code = "EUNMATCHEDPARSER";
              }
            };
            setErrorName(UnmatchedParserError);
            const ResolverError = exports3.ResolverError = class ResolverError extends JSONParserError {
              constructor(ex, source) {
                super(ex.message || `Error reading file "${source}"`, source);
                this.code = "ERESOLVER";
                if ("code" in ex) {
                  this.ioErrorCode = String(ex.code);
                }
              }
            };
            setErrorName(ResolverError);
            const UnmatchedResolverError = exports3.UnmatchedResolverError = class UnmatchedResolverError extends JSONParserError {
              constructor(source) {
                super(`Could not find resolver for "${source}"`, source);
                this.code = "EUNMATCHEDRESOLVER";
              }
            };
            setErrorName(UnmatchedResolverError);
            const MissingPointerError = exports3.MissingPointerError = class MissingPointerError extends JSONParserError {
              constructor(token, path) {
                super(`Token "${token}" does not exist.`, stripHash(path));
                this.code = "EMISSINGPOINTER";
              }
            };
            setErrorName(MissingPointerError);
            const InvalidPointerError = exports3.InvalidPointerError = class InvalidPointerError extends JSONParserError {
              constructor(pointer, path) {
                super(`Invalid $ref pointer "${pointer}". Pointers must begin with "#/"`, stripHash(path));
                this.code = "EINVALIDPOINTER";
              }
            };
            setErrorName(InvalidPointerError);
            function setErrorName(err) {
              Object.defineProperty(err.prototype, "name", {
                value: err.name,
                enumerable: true
              });
            }
            exports3.isHandledError = function(err) {
              return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;
            };
            exports3.normalizeError = function(err) {
              if (err.path === null) {
                err.path = [];
              }
              return err;
            };
          },
          6250: (__unused_webpack_module, exports3) => {
            "use strict";
            exports3.all = function(plugins) {
              return Object.keys(plugins).filter((key) => {
                return typeof plugins[key] === "object";
              }).map((key) => {
                plugins[key].name = key;
                return plugins[key];
              });
            };
            exports3.filter = function(plugins, method, file) {
              return plugins.filter((plugin) => {
                return !!getResult(plugin, method, file);
              });
            };
            exports3.sort = function(plugins) {
              for (let plugin of plugins) {
                plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
              }
              return plugins.sort((a, b) => {
                return a.order - b.order;
              });
            };
            exports3.run = function(plugins, method, file, $refs) {
              let plugin, lastError, index = 0;
              return new Promise((resolve2, reject) => {
                runNextPlugin();
                function runNextPlugin() {
                  plugin = plugins[index++];
                  if (!plugin) {
                    return reject(lastError);
                  }
                  try {
                    let result = getResult(plugin, method, file, callback, $refs);
                    if (result && typeof result.then === "function") {
                      result.then(onSuccess, onError);
                    } else if (result !== void 0) {
                      onSuccess(result);
                    } else if (index === plugins.length) {
                      throw new Error("No promise has been returned or callback has been called.");
                    }
                  } catch (e) {
                    onError(e);
                  }
                }
                function callback(err, result) {
                  if (err) {
                    onError(err);
                  } else {
                    onSuccess(result);
                  }
                }
                function onSuccess(result) {
                  resolve2({
                    plugin,
                    result
                  });
                }
                function onError(error) {
                  lastError = {
                    plugin,
                    error
                  };
                  runNextPlugin();
                }
              });
            };
            function getResult(obj, prop, file, callback, $refs) {
              let value = obj[prop];
              if (typeof value === "function") {
                return value.apply(obj, [file, callback, $refs]);
              }
              if (!callback) {
                if (value instanceof RegExp) {
                  return value.test(file.url);
                } else if (typeof value === "string") {
                  return value === file.extension;
                } else if (Array.isArray(value)) {
                  return value.indexOf(file.extension) !== -1;
                }
              }
              return value;
            }
          },
          6930: (module2, exports3, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            let isWindows = /^win/.test(process2.platform), forwardSlashPattern = /\//g, protocolPattern = /^(\w{2,}):\/\//i, url = module2.exports, jsonPointerSlash = /~1/g, jsonPointerTilde = /~0/g;
            let urlEncodePatterns = [/\?/g, "%3F", /\#/g, "%23"];
            let urlDecodePatterns = [/\%23/g, "#", /\%24/g, "$", /\%26/g, "&", /\%2C/g, ",", /\%40/g, "@"];
            exports3.parse = __webpack_require__2(3149).parse;
            exports3.resolve = __webpack_require__2(3149).resolve;
            exports3.cwd = function cwd() {
              if (process2.browser) {
                return location.href;
              }
              let path = process2.cwd();
              let lastChar = path.slice(-1);
              if (lastChar === "/" || lastChar === "\\") {
                return path;
              } else {
                return path + "/";
              }
            };
            exports3.getProtocol = function getProtocol(path) {
              let match = protocolPattern.exec(path);
              if (match) {
                return match[1].toLowerCase();
              }
            };
            exports3.getExtension = function getExtension(path) {
              let lastDot = path.lastIndexOf(".");
              if (lastDot >= 0) {
                return url.stripQuery(path.substr(lastDot).toLowerCase());
              }
              return "";
            };
            exports3.stripQuery = function stripQuery(path) {
              let queryIndex = path.indexOf("?");
              if (queryIndex >= 0) {
                path = path.substr(0, queryIndex);
              }
              return path;
            };
            exports3.getHash = function getHash(path) {
              let hashIndex = path.indexOf("#");
              if (hashIndex >= 0) {
                return path.substr(hashIndex);
              }
              return "#";
            };
            exports3.stripHash = function stripHash(path) {
              let hashIndex = path.indexOf("#");
              if (hashIndex >= 0) {
                path = path.substr(0, hashIndex);
              }
              return path;
            };
            exports3.isHttp = function isHttp(path) {
              let protocol2 = url.getProtocol(path);
              if (protocol2 === "http" || protocol2 === "https") {
                return true;
              } else if (protocol2 === void 0) {
                return process2.browser;
              } else {
                return false;
              }
            };
            exports3.isFileSystemPath = function isFileSystemPath(path) {
              if (process2.browser) {
                return false;
              }
              let protocol2 = url.getProtocol(path);
              return protocol2 === void 0 || protocol2 === "file";
            };
            exports3.fromFileSystemPath = function fromFileSystemPath(path) {
              if (isWindows) {
                path = path.replace(/\\/g, "/");
              }
              path = encodeURI(path);
              for (let i = 0; i < urlEncodePatterns.length; i += 2) {
                path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
              }
              return path;
            };
            exports3.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
              path = decodeURI(path);
              for (let i = 0; i < urlDecodePatterns.length; i += 2) {
                path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
              }
              let isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
              if (isFileUrl) {
                path = path[7] === "/" ? path.substr(8) : path.substr(7);
                if (isWindows && path[1] === "/") {
                  path = path[0] + ":" + path.substr(1);
                }
                if (keepFileProtocol) {
                  path = "file:///" + path;
                } else {
                  isFileUrl = false;
                  path = isWindows ? path : "/" + path;
                }
              }
              if (isWindows && !isFileUrl) {
                path = path.replace(forwardSlashPattern, "\\");
                if (path.substr(1, 2) === ":\\") {
                  path = path[0].toUpperCase() + path.substr(1);
                }
              }
              return path;
            };
            exports3.safePointerToPath = function safePointerToPath(pointer) {
              if (pointer.length <= 1 || pointer[0] !== "#" || pointer[1] !== "/") {
                return [];
              }
              return pointer.slice(2).split("/").map((value) => {
                return decodeURIComponent(value).replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~");
              });
            };
          },
          5742: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "Ono": () => constructor
            });
            var _extend_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(3842);
            var _normalize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(7104);
            var _to_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(6795);
            const constructor = Ono;
            function Ono(ErrorConstructor, options2) {
              options2 = (0, _normalize__WEBPACK_IMPORTED_MODULE_2__.normalizeOptions)(options2);
              function ono() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                let {
                  originalError,
                  props,
                  message
                } = (0, _normalize__WEBPACK_IMPORTED_MODULE_2__.normalizeArgs)(args, options2);
                let newError = new ErrorConstructor(message);
                return (0, _extend_error__WEBPACK_IMPORTED_MODULE_0__.extendError)(newError, originalError, props);
              }
              ono[Symbol.species] = ErrorConstructor;
              return ono;
            }
            Ono.toJSON = function toJSON(error) {
              return _to_json__WEBPACK_IMPORTED_MODULE_1__.toJSON.call(error);
            };
            Ono.extend = function extend(error, originalError, props) {
              if (props || originalError instanceof Error) {
                return (0, _extend_error__WEBPACK_IMPORTED_MODULE_0__.extendError)(error, originalError, props);
              } else if (originalError) {
                return (0, _extend_error__WEBPACK_IMPORTED_MODULE_0__.extendError)(error, void 0, originalError);
              } else {
                return (0, _extend_error__WEBPACK_IMPORTED_MODULE_0__.extendError)(error);
              }
            };
          },
          3842: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "extendError": () => extendError
            });
            var _isomorphic_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(7226);
            var _stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(6442);
            var _to_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(6795);
            const protectedProps = ["name", "message", "stack"];
            function extendError(error, originalError, props) {
              let onoError = error;
              extendStack(onoError, originalError);
              if (originalError && typeof originalError === "object") {
                mergeErrors(onoError, originalError);
              }
              onoError.toJSON = _to_json__WEBPACK_IMPORTED_MODULE_0__.toJSON;
              if (_isomorphic_node__WEBPACK_IMPORTED_MODULE_1__.addInspectMethod) {
                (0, _isomorphic_node__WEBPACK_IMPORTED_MODULE_1__.addInspectMethod)(onoError);
              }
              if (props && typeof props === "object") {
                Object.assign(onoError, props);
              }
              return onoError;
            }
            function extendStack(newError, originalError) {
              let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
              if ((0, _stack__WEBPACK_IMPORTED_MODULE_2__.isLazyStack)(stackProp)) {
                (0, _stack__WEBPACK_IMPORTED_MODULE_2__.lazyJoinStacks)(stackProp, newError, originalError);
              } else if ((0, _stack__WEBPACK_IMPORTED_MODULE_2__.isWritableStack)(stackProp)) {
                newError.stack = (0, _stack__WEBPACK_IMPORTED_MODULE_2__.joinStacks)(newError, originalError);
              }
            }
            function mergeErrors(newError, originalError) {
              let keys = (0, _to_json__WEBPACK_IMPORTED_MODULE_0__.getDeepKeys)(originalError, protectedProps);
              let _newError = newError;
              let _originalError = originalError;
              for (let key of keys) {
                if (_newError[key] === void 0) {
                  try {
                    _newError[key] = _originalError[key];
                  } catch (e) {
                  }
                }
              }
            }
          },
          9978: (module2, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "Ono": () => _constructor__WEBPACK_IMPORTED_MODULE_1__.Ono,
              "default": () => __WEBPACK_DEFAULT_EXPORT__,
              "ono": () => _singleton__WEBPACK_IMPORTED_MODULE_0__.ono
            });
            var _singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(5480);
            var _constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(5742);
            var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(3462);
            module2 = __webpack_require__2.hmd(module2);
            const __WEBPACK_DEFAULT_EXPORT__ = _singleton__WEBPACK_IMPORTED_MODULE_0__.ono;
            if (typeof module2.exports === "object") {
              module2.exports = Object.assign(module2.exports.default, module2.exports);
            }
          },
          7226: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "addInspectMethod": () => addInspectMethod,
              "format": () => format2
            });
            const format2 = false;
            const addInspectMethod = false;
          },
          7104: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "normalizeArgs": () => normalizeArgs,
              "normalizeOptions": () => normalizeOptions
            });
            var _isomorphic_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(7226);
            function normalizeOptions(options2) {
              options2 = options2 || {};
              return {
                concatMessages: options2.concatMessages === void 0 ? true : Boolean(options2.concatMessages),
                format: options2.format === void 0 ? _isomorphic_node__WEBPACK_IMPORTED_MODULE_0__.format : typeof options2.format === "function" ? options2.format : false
              };
            }
            function normalizeArgs(args, options2) {
              let originalError;
              let props;
              let formatArgs;
              let message = "";
              if (typeof args[0] === "string") {
                formatArgs = args;
              } else if (typeof args[1] === "string") {
                if (args[0] instanceof Error) {
                  originalError = args[0];
                } else {
                  props = args[0];
                }
                formatArgs = args.slice(1);
              } else {
                originalError = args[0];
                props = args[1];
                formatArgs = args.slice(2);
              }
              if (formatArgs.length > 0) {
                if (options2.format) {
                  message = options2.format.apply(void 0, formatArgs);
                } else {
                  message = formatArgs.join(" ");
                }
              }
              if (options2.concatMessages && originalError && originalError.message) {
                message += (message ? " \n" : "") + originalError.message;
              }
              return {
                originalError,
                props,
                message
              };
            }
          },
          5480: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "ono": () => singleton
            });
            var _constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(5742);
            const singleton = ono;
            ono.error = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(Error);
            ono.eval = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(EvalError);
            ono.range = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(RangeError);
            ono.reference = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(ReferenceError);
            ono.syntax = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(SyntaxError);
            ono.type = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(TypeError);
            ono.uri = new _constructor__WEBPACK_IMPORTED_MODULE_0__.Ono(URIError);
            const onoMap = ono;
            function ono() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              let originalError = args[0];
              if (typeof originalError === "object" && typeof originalError.name === "string") {
                for (let typedOno of Object.values(onoMap)) {
                  if (typeof typedOno === "function" && typedOno.name === "ono") {
                    let species = typedOno[Symbol.species];
                    if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {
                      return typedOno.apply(void 0, args);
                    }
                  }
                }
              }
              return ono.error.apply(void 0, args);
            }
          },
          6442: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "isLazyStack": () => isLazyStack,
              "isWritableStack": () => isWritableStack,
              "joinStacks": () => joinStacks,
              "lazyJoinStacks": () => lazyJoinStacks
            });
            const newline = /\r?\n/;
            const onoCall = /\bono[ @]/;
            function isLazyStack(stackProp) {
              return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === "function");
            }
            function isWritableStack(stackProp) {
              return Boolean(
                !stackProp || stackProp.writable || typeof stackProp.set === "function"
              );
            }
            function joinStacks(newError, originalError) {
              let newStack = popStack(newError.stack);
              let originalStack = originalError ? originalError.stack : void 0;
              if (newStack && originalStack) {
                return newStack + "\n\n" + originalStack;
              } else {
                return newStack || originalStack;
              }
            }
            function lazyJoinStacks(lazyStack, newError, originalError) {
              if (originalError) {
                Object.defineProperty(newError, "stack", {
                  get: () => {
                    let newStack = lazyStack.get.apply(newError);
                    return joinStacks({
                      stack: newStack
                    }, originalError);
                  },
                  enumerable: false,
                  configurable: true
                });
              } else {
                lazyPopStack(newError, lazyStack);
              }
            }
            function popStack(stack) {
              if (stack) {
                let lines = stack.split(newline);
                let onoStart;
                for (let i = 0; i < lines.length; i++) {
                  let line = lines[i];
                  if (onoCall.test(line)) {
                    if (onoStart === void 0) {
                      onoStart = i;
                    }
                  } else if (onoStart !== void 0) {
                    lines.splice(onoStart, i - onoStart);
                    break;
                  }
                }
                if (lines.length > 0) {
                  return lines.join("\n");
                }
              }
              return stack;
            }
            function lazyPopStack(error, lazyStack) {
              Object.defineProperty(error, "stack", {
                get: () => popStack(lazyStack.get.apply(error)),
                enumerable: false,
                configurable: true
              });
            }
          },
          6795: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "getDeepKeys": () => getDeepKeys,
              "toJSON": () => toJSON
            });
            var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(2076);
            var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__);
            const nonJsonTypes = ["function", "symbol", "undefined"];
            const protectedProps = ["constructor", "prototype", "__proto__"];
            const objectPrototype = Object.getPrototypeOf({});
            function toJSON() {
              let pojo = {};
              let error = this;
              for (let key of getDeepKeys(error)) {
                if (typeof key === "string") {
                  let value = error[key];
                  let type = typeof value;
                  if (!nonJsonTypes.includes(type)) {
                    pojo[key] = value;
                  }
                }
              }
              return pojo;
            }
            function getDeepKeys(obj) {
              let omit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              let keys = [];
              while (obj && obj !== objectPrototype) {
                keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
                obj = Object.getPrototypeOf(obj);
              }
              let uniqueKeys = new Set(keys);
              for (let key of omit.concat(protectedProps)) {
                uniqueKeys.delete(key);
              }
              return uniqueKeys;
            }
          },
          3462: (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(3254);
            var util__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(util__WEBPACK_IMPORTED_MODULE_0__);
          },
          6717: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(9494);
            exports3.byteLength = byteLength;
            exports3.toByteArray = toByteArray;
            exports3.fromByteArray = fromByteArray;
            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (var i = 0, len = code.length; i < len; ++i) {
              lookup[i] = code[i];
              revLookup[code.charCodeAt(i)] = i;
            }
            revLookup["-".charCodeAt(0)] = 62;
            revLookup["_".charCodeAt(0)] = 63;
            function getLens(b64) {
              var len2 = b64.length;
              if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
              }
              var validLen = b64.indexOf("=");
              if (validLen === -1)
                validLen = len2;
              var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
              return [validLen, placeHoldersLen];
            }
            function byteLength(b64) {
              var lens = getLens(b64);
              var validLen = lens[0];
              var placeHoldersLen = lens[1];
              return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
            }
            function _byteLength(b64, validLen, placeHoldersLen) {
              return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
            }
            function toByteArray(b64) {
              var tmp;
              var lens = getLens(b64);
              var validLen = lens[0];
              var placeHoldersLen = lens[1];
              var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
              var curByte = 0;
              var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
              var i2;
              for (i2 = 0; i2 < len2; i2 += 4) {
                tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
              }
              if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                arr[curByte++] = tmp & 255;
              }
              if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
              }
              return arr;
            }
            function tripletToBase64(num) {
              return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
            }
            function encodeChunk(uint8, start, end) {
              var tmp;
              var output = [];
              for (var i2 = start; i2 < end; i2 += 3) {
                tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
                output.push(tripletToBase64(tmp));
              }
              return output.join("");
            }
            function fromByteArray(uint8) {
              var tmp;
              var len2 = uint8.length;
              var extraBytes = len2 % 3;
              var parts2 = [];
              var maxChunkLength = 16383;
              for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                parts2.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
              }
              if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                parts2.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
              } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                parts2.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
              }
              return parts2.join("");
            }
          },
          5851: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(9494);
            __webpack_require__2(2076);
            const base64 = __webpack_require__2(6717);
            const ieee754 = __webpack_require__2(9350);
            const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
            exports3.Buffer = Buffer2;
            exports3.SlowBuffer = SlowBuffer;
            exports3.INSPECT_MAX_BYTES = 50;
            const K_MAX_LENGTH = 2147483647;
            exports3.kMaxLength = K_MAX_LENGTH;
            Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
              try {
                const arr = new Uint8Array(1);
                const proto = {
                  foo: function() {
                    return 42;
                  }
                };
                Object.setPrototypeOf(proto, Uint8Array.prototype);
                Object.setPrototypeOf(arr, proto);
                return arr.foo() === 42;
              } catch (e) {
                return false;
              }
            }
            Object.defineProperty(Buffer2.prototype, "parent", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.buffer;
              }
            });
            Object.defineProperty(Buffer2.prototype, "offset", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.byteOffset;
              }
            });
            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              const buf = new Uint8Array(length);
              Object.setPrototypeOf(buf, Buffer2.prototype);
              return buf;
            }
            function Buffer2(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }
            Buffer2.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }
              if (ArrayBuffer.isView(value)) {
                return fromArrayView(value);
              }
              if (value == null) {
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
              }
              if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              }
              const valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer2.from(valueOf, encodingOrOffset, length);
              }
              const b = fromObject(value);
              if (b)
                return b;
              if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
              }
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            }
            Buffer2.from = function(value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };
            Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer2, Uint8Array);
            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
            }
            function alloc(size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(size);
              }
              if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
              }
              return createBuffer(size);
            }
            Buffer2.alloc = function(size, fill, encoding) {
              return alloc(size, fill, encoding);
            };
            function allocUnsafe(size) {
              assertSize(size);
              return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }
            Buffer2.allocUnsafe = function(size) {
              return allocUnsafe(size);
            };
            Buffer2.allocUnsafeSlow = function(size) {
              return allocUnsafe(size);
            };
            function fromString(string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }
              if (!Buffer2.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              const length = byteLength(string, encoding) | 0;
              let buf = createBuffer(length);
              const actual = buf.write(string, encoding);
              if (actual !== length) {
                buf = buf.slice(0, actual);
              }
              return buf;
            }
            function fromArrayLike(array) {
              const length = array.length < 0 ? 0 : checked(array.length) | 0;
              const buf = createBuffer(length);
              for (let i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
              }
              return buf;
            }
            function fromArrayView(arrayView) {
              if (isInstance(arrayView, Uint8Array)) {
                const copy = new Uint8Array(arrayView);
                return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
              }
              return fromArrayLike(arrayView);
            }
            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }
              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }
              let buf;
              if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array);
              } else if (length === void 0) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }
              Object.setPrototypeOf(buf, Buffer2.prototype);
              return buf;
            }
            function fromObject(obj) {
              if (Buffer2.isBuffer(obj)) {
                const len = checked(obj.length) | 0;
                const buf = createBuffer(len);
                if (buf.length === 0) {
                  return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
              }
              if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }
              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }
            function checked(length) {
              if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer2.alloc(+length);
            }
            Buffer2.isBuffer = function isBuffer(b) {
              return b != null && b._isBuffer === true && b !== Buffer2.prototype;
            };
            Buffer2.compare = function compare(a, b) {
              if (isInstance(a, Uint8Array))
                a = Buffer2.from(a, a.offset, a.byteLength);
              if (isInstance(b, Uint8Array))
                b = Buffer2.from(b, b.offset, b.byteLength);
              if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              }
              if (a === b)
                return 0;
              let x = a.length;
              let y = b.length;
              for (let i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            Buffer2.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer2.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list.length === 0) {
                return Buffer2.alloc(0);
              }
              let i;
              if (length === void 0) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }
              const buffer = Buffer2.allocUnsafe(length);
              let pos = 0;
              for (i = 0; i < list.length; ++i) {
                let buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                  if (pos + buf.length > buffer.length) {
                    if (!Buffer2.isBuffer(buf))
                      buf = Buffer2.from(buf);
                    buf.copy(buffer, pos);
                  } else {
                    Uint8Array.prototype.set.call(buffer, buf, pos);
                  }
                } else if (!Buffer2.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                } else {
                  buf.copy(buffer, pos);
                }
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength(string, encoding) {
              if (Buffer2.isBuffer(string)) {
                return string.length;
              }
              if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
              }
              const len = string.length;
              const mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0)
                return 0;
              let loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length;
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.byteLength = byteLength;
            function slowToString(encoding, start, end) {
              let loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding)
                encoding = "utf8";
              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.prototype._isBuffer = true;
            function swap(b, n, m) {
              const i = b[n];
              b[n] = b[m];
              b[m] = i;
            }
            Buffer2.prototype.swap16 = function swap16() {
              const len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (let i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };
            Buffer2.prototype.swap32 = function swap32() {
              const len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (let i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };
            Buffer2.prototype.swap64 = function swap64() {
              const len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (let i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };
            Buffer2.prototype.toString = function toString() {
              const length = this.length;
              if (length === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
            Buffer2.prototype.equals = function equals(b) {
              if (!Buffer2.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b)
                return true;
              return Buffer2.compare(this, b) === 0;
            };
            Buffer2.prototype.inspect = function inspect() {
              let str = "";
              const max = exports3.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
              if (this.length > max)
                str += " ... ";
              return "<Buffer " + str + ">";
            };
            if (customInspectSymbol) {
              Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
            }
            Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer2.from(target, target.offset, target.byteLength);
              }
              if (!Buffer2.isBuffer(target)) {
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              let x = thisEnd - thisStart;
              let y = end - start;
              const len = Math.min(x, y);
              const thisCopy = this.slice(thisStart, thisEnd);
              const targetCopy = target.slice(start, end);
              for (let i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
              if (buffer.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer2.from(val, encoding);
              }
              if (Buffer2.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              let indexSize = 1;
              let arrLength = arr.length;
              let valLength = val.length;
              if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i2) {
                if (indexSize === 1) {
                  return buf[i2];
                } else {
                  return buf.readUInt16BE(i2 * indexSize);
                }
              }
              let i;
              if (dir) {
                let foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  let found = true;
                  for (let j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i;
                }
              }
              return -1;
            }
            Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              const remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              const strLen = string.length;
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              let i;
              for (i = 0; i < length; ++i) {
                const parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed))
                  return i;
                buf[offset + i] = parsed;
              }
              return i;
            }
            function utf8Write(buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer2.prototype.write = function write(string, offset, length, encoding) {
              if (offset === void 0) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
              } else if (length === void 0 && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === void 0)
                    encoding = "utf8";
                } else {
                  encoding = length;
                  length = void 0;
                }
              } else {
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              }
              const remaining = this.length - offset;
              if (length === void 0 || length > remaining)
                length = remaining;
              if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding)
                encoding = "utf8";
              let loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return asciiWrite(this, string, offset, length);
                  case "base64":
                    return base64Write(this, string, offset, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer2.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              const res = [];
              let i = start;
              while (i < end) {
                const firstByte = buf[i];
                let codePoint = null;
                let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                  let secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            const MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              const len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              let res = "";
              let i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              let ret = "";
              end = Math.min(buf.length, end);
              for (let i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              let ret = "";
              end = Math.min(buf.length, end);
              for (let i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              const len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              let out = "";
              for (let i = start; i < end; ++i) {
                out += hexSliceLookupTable[buf[i]];
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              const bytes = buf.slice(start, end);
              let res = "";
              for (let i = 0; i < bytes.length - 1; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }
            Buffer2.prototype.slice = function slice(start, end) {
              const len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              const newBuf = this.subarray(start, end);
              Object.setPrototypeOf(newBuf, Buffer2.prototype);
              return newBuf;
            };
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              let val = this[offset];
              let mul = 1;
              let i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength2, this.length);
              }
              let val = this[offset + --byteLength2];
              let mul = 1;
              while (byteLength2 > 0 && (mul *= 256)) {
                val += this[offset + --byteLength2] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              return this[offset];
            };
            Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] | this[offset + 1] << 8;
            };
            Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] << 8 | this[offset + 1];
            };
            Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
            };
            Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            };
            Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
              offset = offset >>> 0;
              validateNumber(offset, "offset");
              const first = this[offset];
              const last = this[offset + 7];
              if (first === void 0 || last === void 0) {
                boundsError(offset, this.length - 8);
              }
              const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
              const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
              return BigInt(lo) + (BigInt(hi) << BigInt(32));
            });
            Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
              offset = offset >>> 0;
              validateNumber(offset, "offset");
              const first = this[offset];
              const last = this[offset + 7];
              if (first === void 0 || last === void 0) {
                boundsError(offset, this.length - 8);
              }
              const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
              const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
              return (BigInt(hi) << BigInt(32)) + BigInt(lo);
            });
            Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              let val = this[offset];
              let mul = 1;
              let i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              let i = byteLength2;
              let mul = 1;
              let val = this[offset + --i];
              while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              if (!(this[offset] & 128))
                return this[offset];
              return (255 - this[offset] + 1) * -1;
            };
            Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              const val = this[offset] | this[offset + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              const val = this[offset + 1] | this[offset] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            };
            Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            };
            Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
              offset = offset >>> 0;
              validateNumber(offset, "offset");
              const first = this[offset];
              const last = this[offset + 7];
              if (first === void 0 || last === void 0) {
                boundsError(offset, this.length - 8);
              }
              const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
              return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
            });
            Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
              offset = offset >>> 0;
              validateNumber(offset, "offset");
              const first = this[offset];
              const last = this[offset + 7];
              if (first === void 0 || last === void 0) {
                boundsError(offset, this.length - 8);
              }
              const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
              return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
            });
            Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer2.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              let mul = 1;
              let i = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              let i = byteLength2 - 1;
              let mul = 1;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 255, 0);
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            function wrtBigUInt64LE(buf, value, offset, min, max) {
              checkIntBI(value, min, max, buf, offset, 7);
              let lo = Number(value & BigInt(4294967295));
              buf[offset++] = lo;
              lo = lo >> 8;
              buf[offset++] = lo;
              lo = lo >> 8;
              buf[offset++] = lo;
              lo = lo >> 8;
              buf[offset++] = lo;
              let hi = Number(value >> BigInt(32) & BigInt(4294967295));
              buf[offset++] = hi;
              hi = hi >> 8;
              buf[offset++] = hi;
              hi = hi >> 8;
              buf[offset++] = hi;
              hi = hi >> 8;
              buf[offset++] = hi;
              return offset;
            }
            function wrtBigUInt64BE(buf, value, offset, min, max) {
              checkIntBI(value, min, max, buf, offset, 7);
              let lo = Number(value & BigInt(4294967295));
              buf[offset + 7] = lo;
              lo = lo >> 8;
              buf[offset + 6] = lo;
              lo = lo >> 8;
              buf[offset + 5] = lo;
              lo = lo >> 8;
              buf[offset + 4] = lo;
              let hi = Number(value >> BigInt(32) & BigInt(4294967295));
              buf[offset + 3] = hi;
              hi = hi >> 8;
              buf[offset + 2] = hi;
              hi = hi >> 8;
              buf[offset + 1] = hi;
              hi = hi >> 8;
              buf[offset] = hi;
              return offset + 8;
            }
            Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
              let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
            });
            Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
              let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
            });
            Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                const limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              let i = 0;
              let mul = 1;
              let sub = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                const limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              let i = byteLength2 - 1;
              let mul = 1;
              let sub = 0;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 127, -128);
              if (value < 0)
                value = 255 + value + 1;
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };
            Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (value < 0)
                value = 4294967295 + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
              let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            });
            Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
              let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            });
            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }
            Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }
            Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer2.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              const len = end - start;
              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
              } else {
                Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
              }
              return len;
            };
            Buffer2.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  const code = val.charCodeAt(0);
                  if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              } else if (typeof val === "boolean") {
                val = Number(val);
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              let i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
                const len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }
              return this;
            };
            const errors = {};
            function E(sym, getMessage, Base) {
              errors[sym] = class NodeError extends Base {
                constructor() {
                  super();
                  Object.defineProperty(this, "message", {
                    value: getMessage.apply(this, arguments),
                    writable: true,
                    configurable: true
                  });
                  this.name = `${this.name} [${sym}]`;
                  this.stack;
                  delete this.name;
                }
                get code() {
                  return sym;
                }
                set code(value) {
                  Object.defineProperty(this, "code", {
                    configurable: true,
                    enumerable: true,
                    value,
                    writable: true
                  });
                }
                toString() {
                  return `${this.name} [${sym}]: ${this.message}`;
                }
              };
            }
            E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
              if (name) {
                return `${name} is outside of buffer bounds`;
              }
              return "Attempt to access memory outside buffer bounds";
            }, RangeError);
            E("ERR_INVALID_ARG_TYPE", function(name, actual) {
              return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
            }, TypeError);
            E("ERR_OUT_OF_RANGE", function(str, range, input) {
              let msg = `The value of "${str}" is out of range.`;
              let received = input;
              if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                received = addNumericalSeparator(String(input));
              } else if (typeof input === "bigint") {
                received = String(input);
                if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                  received = addNumericalSeparator(received);
                }
                received += "n";
              }
              msg += ` It must be ${range}. Received ${received}`;
              return msg;
            }, RangeError);
            function addNumericalSeparator(val) {
              let res = "";
              let i = val.length;
              const start = val[0] === "-" ? 1 : 0;
              for (; i >= start + 4; i -= 3) {
                res = `_${val.slice(i - 3, i)}${res}`;
              }
              return `${val.slice(0, i)}${res}`;
            }
            function checkBounds(buf, offset, byteLength2) {
              validateNumber(offset, "offset");
              if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
                boundsError(offset, buf.length - (byteLength2 + 1));
              }
            }
            function checkIntBI(value, min, max, buf, offset, byteLength2) {
              if (value > max || value < min) {
                const n = typeof min === "bigint" ? "n" : "";
                let range;
                if (byteLength2 > 3) {
                  if (min === 0 || min === BigInt(0)) {
                    range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
                  } else {
                    range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
                  }
                } else {
                  range = `>= ${min}${n} and <= ${max}${n}`;
                }
                throw new errors.ERR_OUT_OF_RANGE("value", range, value);
              }
              checkBounds(buf, offset, byteLength2);
            }
            function validateNumber(value, name) {
              if (typeof value !== "number") {
                throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
              }
            }
            function boundsError(value, length, type) {
              if (Math.floor(value) !== value) {
                validateNumber(value, type);
                throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
              }
              if (length < 0) {
                throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
              }
              throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
            }
            const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = str.split("=")[0];
              str = str.trim().replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              let codePoint;
              const length = string.length;
              let leadSurrogate = null;
              const bytes = [];
              for (let i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              const byteArray = [];
              for (let i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              let c, hi, lo;
              const byteArray = [];
              for (let i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0)
                  break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
              let i;
              for (i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length)
                  break;
                dst[i + offset] = src[i];
              }
              return i;
            }
            function isInstance(obj, type) {
              return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
              return obj !== obj;
            }
            const hexSliceLookupTable = function() {
              const alphabet = "0123456789abcdef";
              const table = new Array(256);
              for (let i = 0; i < 16; ++i) {
                const i16 = i * 16;
                for (let j = 0; j < 16; ++j) {
                  table[i16 + j] = alphabet[i] + alphabet[j];
                }
              }
              return table;
            }();
            function defineBigIntMethod(fn) {
              return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
            }
            function BufferBigIntNotDefined() {
              throw new Error("BigInt not supported");
            }
          },
          1403: (module2) => {
            module2.exports = {
              "100": "Continue",
              "101": "Switching Protocols",
              "102": "Processing",
              "200": "OK",
              "201": "Created",
              "202": "Accepted",
              "203": "Non-Authoritative Information",
              "204": "No Content",
              "205": "Reset Content",
              "206": "Partial Content",
              "207": "Multi-Status",
              "208": "Already Reported",
              "226": "IM Used",
              "300": "Multiple Choices",
              "301": "Moved Permanently",
              "302": "Found",
              "303": "See Other",
              "304": "Not Modified",
              "305": "Use Proxy",
              "307": "Temporary Redirect",
              "308": "Permanent Redirect",
              "400": "Bad Request",
              "401": "Unauthorized",
              "402": "Payment Required",
              "403": "Forbidden",
              "404": "Not Found",
              "405": "Method Not Allowed",
              "406": "Not Acceptable",
              "407": "Proxy Authentication Required",
              "408": "Request Timeout",
              "409": "Conflict",
              "410": "Gone",
              "411": "Length Required",
              "412": "Precondition Failed",
              "413": "Payload Too Large",
              "414": "URI Too Long",
              "415": "Unsupported Media Type",
              "416": "Range Not Satisfiable",
              "417": "Expectation Failed",
              "418": "I'm a teapot",
              "421": "Misdirected Request",
              "422": "Unprocessable Entity",
              "423": "Locked",
              "424": "Failed Dependency",
              "425": "Unordered Collection",
              "426": "Upgrade Required",
              "428": "Precondition Required",
              "429": "Too Many Requests",
              "431": "Request Header Fields Too Large",
              "451": "Unavailable For Legal Reasons",
              "500": "Internal Server Error",
              "501": "Not Implemented",
              "502": "Bad Gateway",
              "503": "Service Unavailable",
              "504": "Gateway Timeout",
              "505": "HTTP Version Not Supported",
              "506": "Variant Also Negotiates",
              "507": "Insufficient Storage",
              "508": "Loop Detected",
              "509": "Bandwidth Limit Exceeded",
              "510": "Not Extended",
              "511": "Network Authentication Required"
            };
          },
          2648: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var GetIntrinsic = __webpack_require__2(3584);
            var callBind = __webpack_require__2(7257);
            var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
            module2.exports = function callBoundIntrinsic(name, allowMissing) {
              var intrinsic = GetIntrinsic(name, !!allowMissing);
              if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                return callBind(intrinsic);
              }
              return intrinsic;
            };
          },
          7257: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var bind = __webpack_require__2(4597);
            var GetIntrinsic = __webpack_require__2(3584);
            var $apply = GetIntrinsic("%Function.prototype.apply%");
            var $call = GetIntrinsic("%Function.prototype.call%");
            var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
            var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
            var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
            var $max = GetIntrinsic("%Math.max%");
            if ($defineProperty) {
              try {
                $defineProperty({}, "a", {
                  value: 1
                });
              } catch (e) {
                $defineProperty = null;
              }
            }
            module2.exports = function callBind(originalFunction) {
              var func = $reflectApply(bind, $call, arguments);
              if ($gOPD && $defineProperty) {
                var desc = $gOPD(func, "length");
                if (desc.configurable) {
                  $defineProperty(func, "length", {
                    value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                  });
                }
              }
              return func;
            };
            var applyBind = function applyBind2() {
              return $reflectApply(bind, $apply, arguments);
            };
            if ($defineProperty) {
              $defineProperty(module2.exports, "apply", {
                value: applyBind
              });
            } else {
              module2.exports.apply = applyBind;
            }
          },
          4606: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            __webpack_require__2(8192);
            var next = __webpack_require__2.g.process && process2.nextTick || __webpack_require__2.g.setImmediate || function(f) {
              setTimeout(f, 0);
            };
            module2.exports = function maybe(cb, promise) {
              if (cb) {
                promise.then(function(result) {
                  next(function() {
                    cb(null, result);
                  });
                }, function(err) {
                  next(function() {
                    cb(err);
                  });
                });
                return void 0;
              } else {
                return promise;
              }
            };
          },
          8257: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var isCallable = __webpack_require__2(9212);
            var tryToString = __webpack_require__2(5637);
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (isCallable(argument))
                return argument;
              throw $TypeError(tryToString(argument) + " is not a function");
            };
          },
          9882: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var isCallable = __webpack_require__2(9212);
            var $String = String;
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (typeof argument == "object" || isCallable(argument))
                return argument;
              throw $TypeError("Can't set " + $String(argument) + " as a prototype");
            };
          },
          6288: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var wellKnownSymbol = __webpack_require__2(3649);
            var create = __webpack_require__2(3590);
            var defineProperty = __webpack_require__2(4615).f;
            var UNSCOPABLES = wellKnownSymbol("unscopables");
            var ArrayPrototype = Array.prototype;
            if (ArrayPrototype[UNSCOPABLES] == void 0) {
              defineProperty(ArrayPrototype, UNSCOPABLES, {
                configurable: true,
                value: create(null)
              });
            }
            module2.exports = function(key) {
              ArrayPrototype[UNSCOPABLES][key] = true;
            };
          },
          2569: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var isObject = __webpack_require__2(794);
            var $String = String;
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (isObject(argument))
                return argument;
              throw $TypeError($String(argument) + " is not an object");
            };
          },
          1601: (module2) => {
            module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
          },
          3977: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var NATIVE_ARRAY_BUFFER = __webpack_require__2(1601);
            var DESCRIPTORS = __webpack_require__2(8494);
            var global2 = __webpack_require__2(7583);
            var isCallable = __webpack_require__2(9212);
            var isObject = __webpack_require__2(794);
            var hasOwn = __webpack_require__2(2870);
            var classof = __webpack_require__2(3058);
            var tryToString = __webpack_require__2(5637);
            var createNonEnumerableProperty = __webpack_require__2(57);
            var defineBuiltIn = __webpack_require__2(3746);
            var defineProperty = __webpack_require__2(4615).f;
            var isPrototypeOf = __webpack_require__2(2447);
            var getPrototypeOf = __webpack_require__2(729);
            var setPrototypeOf = __webpack_require__2(7496);
            var wellKnownSymbol = __webpack_require__2(3649);
            var uid = __webpack_require__2(8284);
            var InternalStateModule = __webpack_require__2(2743);
            var enforceInternalState = InternalStateModule.enforce;
            var getInternalState = InternalStateModule.get;
            var Int8Array2 = global2.Int8Array;
            var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
            var Uint8ClampedArray2 = global2.Uint8ClampedArray;
            var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
            var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
            var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
            var ObjectPrototype = Object.prototype;
            var TypeError2 = global2.TypeError;
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
            var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
            var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global2.opera) !== "Opera";
            var TYPED_ARRAY_TAG_REQUIRED = false;
            var NAME, Constructor, Prototype;
            var TypedArrayConstructorsList = {
              Int8Array: 1,
              Uint8Array: 1,
              Uint8ClampedArray: 1,
              Int16Array: 2,
              Uint16Array: 2,
              Int32Array: 4,
              Uint32Array: 4,
              Float32Array: 4,
              Float64Array: 8
            };
            var BigIntArrayConstructorsList = {
              BigInt64Array: 8,
              BigUint64Array: 8
            };
            var isView = function isView2(it) {
              if (!isObject(it))
                return false;
              var klass = classof(it);
              return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
            };
            var getTypedArrayConstructor = function(it) {
              var proto = getPrototypeOf(it);
              if (!isObject(proto))
                return;
              var state = getInternalState(proto);
              return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
            };
            var isTypedArray = function(it) {
              if (!isObject(it))
                return false;
              var klass = classof(it);
              return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
            };
            var aTypedArray = function(it) {
              if (isTypedArray(it))
                return it;
              throw TypeError2("Target is not a typed array");
            };
            var aTypedArrayConstructor = function(C) {
              if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
                return C;
              throw TypeError2(tryToString(C) + " is not a typed array constructor");
            };
            var exportTypedArrayMethod = function(KEY, property, forced, options2) {
              if (!DESCRIPTORS)
                return;
              if (forced)
                for (var ARRAY in TypedArrayConstructorsList) {
                  var TypedArrayConstructor = global2[ARRAY];
                  if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
                    try {
                      delete TypedArrayConstructor.prototype[KEY];
                    } catch (error) {
                      try {
                        TypedArrayConstructor.prototype[KEY] = property;
                      } catch (error2) {
                      }
                    }
                }
              if (!TypedArrayPrototype[KEY] || forced) {
                defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options2);
              }
            };
            var exportTypedArrayStaticMethod = function(KEY, property, forced) {
              var ARRAY, TypedArrayConstructor;
              if (!DESCRIPTORS)
                return;
              if (setPrototypeOf) {
                if (forced)
                  for (ARRAY in TypedArrayConstructorsList) {
                    TypedArrayConstructor = global2[ARRAY];
                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                      try {
                        delete TypedArrayConstructor[KEY];
                      } catch (error) {
                      }
                  }
                if (!TypedArray[KEY] || forced) {
                  try {
                    return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                  } catch (error) {
                  }
                } else
                  return;
              }
              for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = global2[ARRAY];
                if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                  defineBuiltIn(TypedArrayConstructor, KEY, property);
                }
              }
            };
            for (NAME in TypedArrayConstructorsList) {
              Constructor = global2[NAME];
              Prototype = Constructor && Constructor.prototype;
              if (Prototype)
                enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
              else
                NATIVE_ARRAY_BUFFER_VIEWS = false;
            }
            for (NAME in BigIntArrayConstructorsList) {
              Constructor = global2[NAME];
              Prototype = Constructor && Constructor.prototype;
              if (Prototype)
                enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
            }
            if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
              TypedArray = function TypedArray2() {
                throw TypeError2("Incorrect invocation");
              };
              if (NATIVE_ARRAY_BUFFER_VIEWS)
                for (NAME in TypedArrayConstructorsList) {
                  if (global2[NAME])
                    setPrototypeOf(global2[NAME], TypedArray);
                }
            }
            if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
              TypedArrayPrototype = TypedArray.prototype;
              if (NATIVE_ARRAY_BUFFER_VIEWS)
                for (NAME in TypedArrayConstructorsList) {
                  if (global2[NAME])
                    setPrototypeOf(global2[NAME].prototype, TypedArrayPrototype);
                }
            }
            if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
              setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
            }
            if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
              TYPED_ARRAY_TAG_REQUIRED = true;
              defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                get: function() {
                  return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
                }
              });
              for (NAME in TypedArrayConstructorsList)
                if (global2[NAME]) {
                  createNonEnumerableProperty(global2[NAME], TYPED_ARRAY_TAG, NAME);
                }
            }
            module2.exports = {
              NATIVE_ARRAY_BUFFER_VIEWS,
              TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
              aTypedArray,
              aTypedArrayConstructor,
              exportTypedArrayMethod,
              exportTypedArrayStaticMethod,
              getTypedArrayConstructor,
              isView,
              isTypedArray,
              TypedArray,
              TypedArrayPrototype
            };
          },
          5766: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toIndexedObject = __webpack_require__2(2977);
            var toAbsoluteIndex = __webpack_require__2(6782);
            var lengthOfArrayLike = __webpack_require__2(1825);
            var createMethod = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIndexedObject($this);
                var length = lengthOfArrayLike(O);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index) {
                    value = O[index++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index; index++) {
                    if ((IS_INCLUDES || index in O) && O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
                return !IS_INCLUDES && -1;
              };
            };
            module2.exports = {
              includes: createMethod(true),
              indexOf: createMethod(false)
            };
          },
          6917: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            module2.exports = uncurryThis([].slice);
          },
          9624: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var toString = uncurryThis({}.toString);
            var stringSlice = uncurryThis("".slice);
            module2.exports = function(it) {
              return stringSlice(toString(it), 8, -1);
            };
          },
          3058: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var TO_STRING_TAG_SUPPORT = __webpack_require__2(8191);
            var isCallable = __webpack_require__2(9212);
            var classofRaw = __webpack_require__2(9624);
            var wellKnownSymbol = __webpack_require__2(3649);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var $Object = Object;
            var CORRECT_ARGUMENTS = classofRaw(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it, key) {
              try {
                return it[key];
              } catch (error) {
              }
            };
            module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
              var O, tag, result;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
            };
          },
          3478: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var hasOwn = __webpack_require__2(2870);
            var ownKeys = __webpack_require__2(929);
            var getOwnPropertyDescriptorModule = __webpack_require__2(6683);
            var definePropertyModule = __webpack_require__2(4615);
            module2.exports = function(target, source, exceptions) {
              var keys = ownKeys(source);
              var defineProperty = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                  defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                }
              }
            };
          },
          926: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var fails = __webpack_require__2(6544);
            module2.exports = !fails(function() {
              function F() {
              }
              F.prototype.constructor = null;
              return Object.getPrototypeOf(new F()) !== F.prototype;
            });
          },
          57: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var definePropertyModule = __webpack_require__2(4615);
            var createPropertyDescriptor = __webpack_require__2(4677);
            module2.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          4677: (module2) => {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          3746: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var isCallable = __webpack_require__2(9212);
            var definePropertyModule = __webpack_require__2(4615);
            var makeBuiltIn = __webpack_require__2(9594);
            var defineGlobalProperty = __webpack_require__2(2296);
            module2.exports = function(O, key, value, options2) {
              if (!options2)
                options2 = {};
              var simple = options2.enumerable;
              var name = options2.name !== void 0 ? options2.name : key;
              if (isCallable(value))
                makeBuiltIn(value, name, options2);
              if (options2.global) {
                if (simple)
                  O[key] = value;
                else
                  defineGlobalProperty(key, value);
              } else {
                try {
                  if (!options2.unsafe)
                    delete O[key];
                  else if (O[key])
                    simple = true;
                } catch (error) {
                }
                if (simple)
                  O[key] = value;
                else
                  definePropertyModule.f(O, key, {
                    value,
                    enumerable: false,
                    configurable: !options2.nonConfigurable,
                    writable: !options2.nonWritable
                  });
              }
              return O;
            };
          },
          2296: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var defineProperty = Object.defineProperty;
            module2.exports = function(key, value) {
              try {
                defineProperty(global2, key, {
                  value,
                  configurable: true,
                  writable: true
                });
              } catch (error) {
                global2[key] = value;
              }
              return value;
            };
          },
          8494: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var fails = __webpack_require__2(6544);
            module2.exports = !fails(function() {
              return Object.defineProperty({}, 1, {
                get: function() {
                  return 7;
                }
              })[1] != 7;
            });
          },
          6668: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var isObject = __webpack_require__2(794);
            var document2 = global2.document;
            var EXISTS = isObject(document2) && isObject(document2.createElement);
            module2.exports = function(it) {
              return EXISTS ? document2.createElement(it) : {};
            };
          },
          7020: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var userAgent = __webpack_require__2(6918);
            module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
          },
          5354: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var classof = __webpack_require__2(9624);
            var global2 = __webpack_require__2(7583);
            module2.exports = classof(global2.process) == "process";
          },
          6918: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var getBuiltIn = __webpack_require__2(5897);
            module2.exports = getBuiltIn("navigator", "userAgent") || "";
          },
          4061: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var userAgent = __webpack_require__2(6918);
            var process2 = global2.process;
            var Deno = global2.Deno;
            var versions = process2 && process2.versions || Deno && Deno.version;
            var v8 = versions && versions.v8;
            var match, version;
            if (v8) {
              match = v8.split(".");
              version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
            }
            if (!version && userAgent) {
              match = userAgent.match(/Edge\/(\d+)/);
              if (!match || match[1] >= 74) {
                match = userAgent.match(/Chrome\/(\d+)/);
                if (match)
                  version = +match[1];
              }
            }
            module2.exports = version;
          },
          5690: (module2) => {
            module2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
          },
          7263: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var getOwnPropertyDescriptor = __webpack_require__2(6683).f;
            var createNonEnumerableProperty = __webpack_require__2(57);
            var defineBuiltIn = __webpack_require__2(3746);
            var defineGlobalProperty = __webpack_require__2(2296);
            var copyConstructorProperties = __webpack_require__2(3478);
            var isForced = __webpack_require__2(4451);
            module2.exports = function(options2, source) {
              var TARGET = options2.target;
              var GLOBAL = options2.global;
              var STATIC = options2.stat;
              var FORCED, target, key, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global2;
              } else if (STATIC) {
                target = global2[TARGET] || defineGlobalProperty(TARGET, {});
              } else {
                target = (global2[TARGET] || {}).prototype;
              }
              if (target)
                for (key in source) {
                  sourceProperty = source[key];
                  if (options2.dontCallGetSet) {
                    descriptor = getOwnPropertyDescriptor(target, key);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key];
                  FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty == typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options2.sham || targetProperty && targetProperty.sham) {
                    createNonEnumerableProperty(sourceProperty, "sham", true);
                  }
                  defineBuiltIn(target, key, sourceProperty, options2);
                }
            };
          },
          6544: (module2) => {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (error) {
                return true;
              }
            };
          },
          1611: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var NATIVE_BIND = __webpack_require__2(8987);
            var FunctionPrototype = Function.prototype;
            var apply = FunctionPrototype.apply;
            var call = FunctionPrototype.call;
            module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
              return call.apply(apply, arguments);
            });
          },
          2938: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var aCallable = __webpack_require__2(8257);
            var NATIVE_BIND = __webpack_require__2(8987);
            var bind = uncurryThis(uncurryThis.bind);
            module2.exports = function(fn, that) {
              aCallable(fn);
              return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
                return fn.apply(that, arguments);
              };
            };
          },
          8987: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var fails = __webpack_require__2(6544);
            module2.exports = !fails(function() {
              var test = function() {
              }.bind();
              return typeof test != "function" || test.hasOwnProperty("prototype");
            });
          },
          8262: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var NATIVE_BIND = __webpack_require__2(8987);
            var call = Function.prototype.call;
            module2.exports = NATIVE_BIND ? call.bind(call) : function() {
              return call.apply(call, arguments);
            };
          },
          4340: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var hasOwn = __webpack_require__2(2870);
            var FunctionPrototype = Function.prototype;
            var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
            var EXISTS = hasOwn(FunctionPrototype, "name");
            var PROPER = EXISTS && function something() {
            }.name === "something";
            var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
            module2.exports = {
              EXISTS,
              PROPER,
              CONFIGURABLE
            };
          },
          7386: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var NATIVE_BIND = __webpack_require__2(8987);
            var FunctionPrototype = Function.prototype;
            var bind = FunctionPrototype.bind;
            var call = FunctionPrototype.call;
            var uncurryThis = NATIVE_BIND && bind.bind(call, call);
            module2.exports = NATIVE_BIND ? function(fn) {
              return fn && uncurryThis(fn);
            } : function(fn) {
              return fn && function() {
                return call.apply(fn, arguments);
              };
            };
          },
          5897: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var isCallable = __webpack_require__2(9212);
            var aFunction = function(argument) {
              return isCallable(argument) ? argument : void 0;
            };
            module2.exports = function(namespace, method) {
              return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
            };
          },
          911: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var aCallable = __webpack_require__2(8257);
            module2.exports = function(V, P) {
              var func = V[P];
              return func == null ? void 0 : aCallable(func);
            };
          },
          7583: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || function() {
              return this;
            }() || Function("return this")();
          },
          2870: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var toObject2 = __webpack_require__2(1324);
            var hasOwnProperty = uncurryThis({}.hasOwnProperty);
            module2.exports = Object.hasOwn || function hasOwn(it, key) {
              return hasOwnProperty(toObject2(it), key);
            };
          },
          4639: (module2) => {
            module2.exports = {};
          },
          482: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var getBuiltIn = __webpack_require__2(5897);
            module2.exports = getBuiltIn("document", "documentElement");
          },
          275: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var fails = __webpack_require__2(6544);
            var createElement = __webpack_require__2(6668);
            module2.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          },
          5044: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var fails = __webpack_require__2(6544);
            var classof = __webpack_require__2(9624);
            var $Object = Object;
            var split = uncurryThis("".split);
            module2.exports = fails(function() {
              return !$Object("z").propertyIsEnumerable(0);
            }) ? function(it) {
              return classof(it) == "String" ? split(it, "") : $Object(it);
            } : $Object;
          },
          9734: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var isCallable = __webpack_require__2(9212);
            var store = __webpack_require__2(1314);
            var functionToString = uncurryThis(Function.toString);
            if (!isCallable(store.inspectSource)) {
              store.inspectSource = function(it) {
                return functionToString(it);
              };
            }
            module2.exports = store.inspectSource;
          },
          2743: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var NATIVE_WEAK_MAP = __webpack_require__2(9491);
            var global2 = __webpack_require__2(7583);
            var uncurryThis = __webpack_require__2(7386);
            var isObject = __webpack_require__2(794);
            var createNonEnumerableProperty = __webpack_require__2(57);
            var hasOwn = __webpack_require__2(2870);
            var shared = __webpack_require__2(1314);
            var sharedKey = __webpack_require__2(9137);
            var hiddenKeys = __webpack_require__2(4639);
            var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
            var TypeError2 = global2.TypeError;
            var WeakMap2 = global2.WeakMap;
            var set, get, has;
            var enforce = function(it) {
              return has(it) ? get(it) : set(it, {});
            };
            var getterFor = function(TYPE) {
              return function(it) {
                var state;
                if (!isObject(it) || (state = get(it)).type !== TYPE) {
                  throw TypeError2("Incompatible receiver, " + TYPE + " required");
                }
                return state;
              };
            };
            if (NATIVE_WEAK_MAP || shared.state) {
              var store = shared.state || (shared.state = new WeakMap2());
              var wmget = uncurryThis(store.get);
              var wmhas = uncurryThis(store.has);
              var wmset = uncurryThis(store.set);
              set = function(it, metadata) {
                if (wmhas(store, it))
                  throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                metadata.facade = it;
                wmset(store, it, metadata);
                return metadata;
              };
              get = function(it) {
                return wmget(store, it) || {};
              };
              has = function(it) {
                return wmhas(store, it);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set = function(it, metadata) {
                if (hasOwn(it, STATE))
                  throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                metadata.facade = it;
                createNonEnumerableProperty(it, STATE, metadata);
                return metadata;
              };
              get = function(it) {
                return hasOwn(it, STATE) ? it[STATE] : {};
              };
              has = function(it) {
                return hasOwn(it, STATE);
              };
            }
            module2.exports = {
              set,
              get,
              has,
              enforce,
              getterFor
            };
          },
          9212: (module2) => {
            module2.exports = function(argument) {
              return typeof argument == "function";
            };
          },
          4451: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var fails = __webpack_require__2(6544);
            var isCallable = __webpack_require__2(9212);
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data[normalize(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string) {
              return String(string).replace(replacement, ".").toLowerCase();
            };
            var data = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module2.exports = isForced;
          },
          794: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var isCallable = __webpack_require__2(9212);
            module2.exports = function(it) {
              return typeof it == "object" ? it !== null : isCallable(it);
            };
          },
          6268: (module2) => {
            module2.exports = false;
          },
          5871: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var getBuiltIn = __webpack_require__2(5897);
            var isCallable = __webpack_require__2(9212);
            var isPrototypeOf = __webpack_require__2(2447);
            var USE_SYMBOL_AS_UID = __webpack_require__2(7786);
            var $Object = Object;
            module2.exports = USE_SYMBOL_AS_UID ? function(it) {
              return typeof it == "symbol";
            } : function(it) {
              var $Symbol = getBuiltIn("Symbol");
              return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
            };
          },
          1825: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toLength = __webpack_require__2(97);
            module2.exports = function(obj) {
              return toLength(obj.length);
            };
          },
          9594: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var fails = __webpack_require__2(6544);
            var isCallable = __webpack_require__2(9212);
            var hasOwn = __webpack_require__2(2870);
            var DESCRIPTORS = __webpack_require__2(8494);
            var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(4340).CONFIGURABLE;
            var inspectSource = __webpack_require__2(9734);
            var InternalStateModule = __webpack_require__2(2743);
            var enforceInternalState = InternalStateModule.enforce;
            var getInternalState = InternalStateModule.get;
            var defineProperty = Object.defineProperty;
            var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
              return defineProperty(function() {
              }, "length", {
                value: 8
              }).length !== 8;
            });
            var TEMPLATE = String(String).split("String");
            var makeBuiltIn = module2.exports = function(value, name, options2) {
              if (String(name).slice(0, 7) === "Symbol(") {
                name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
              }
              if (options2 && options2.getter)
                name = "get " + name;
              if (options2 && options2.setter)
                name = "set " + name;
              if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                if (DESCRIPTORS)
                  defineProperty(value, "name", {
                    value: name,
                    configurable: true
                  });
                else
                  value.name = name;
              }
              if (CONFIGURABLE_LENGTH && options2 && hasOwn(options2, "arity") && value.length !== options2.arity) {
                defineProperty(value, "length", {
                  value: options2.arity
                });
              }
              try {
                if (options2 && hasOwn(options2, "constructor") && options2.constructor) {
                  if (DESCRIPTORS)
                    defineProperty(value, "prototype", {
                      writable: false
                    });
                } else if (value.prototype)
                  value.prototype = void 0;
              } catch (error) {
              }
              var state = enforceInternalState(value);
              if (!hasOwn(state, "source")) {
                state.source = TEMPLATE.join(typeof name == "string" ? name : "");
              }
              return value;
            };
            Function.prototype.toString = makeBuiltIn(function toString() {
              return isCallable(this) && getInternalState(this).source || inspectSource(this);
            }, "toString");
          },
          9021: (module2) => {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = Math.trunc || function trunc(x) {
              var n = +x;
              return (n > 0 ? floor : ceil)(n);
            };
          },
          8640: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var V8_VERSION = __webpack_require__2(4061);
            var fails = __webpack_require__2(6544);
            module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              var symbol = Symbol();
              return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
            });
          },
          9491: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var isCallable = __webpack_require__2(9212);
            var inspectSource = __webpack_require__2(9734);
            var WeakMap2 = global2.WeakMap;
            module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
          },
          3590: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var anObject = __webpack_require__2(2569);
            var definePropertiesModule = __webpack_require__2(8728);
            var enumBugKeys = __webpack_require__2(5690);
            var hiddenKeys = __webpack_require__2(4639);
            var html2 = __webpack_require__2(482);
            var documentCreateElement = __webpack_require__2(6668);
            var sharedKey = __webpack_require__2(9137);
            var GT = ">";
            var LT = "<";
            var PROTOTYPE = "prototype";
            var SCRIPT = "script";
            var IE_PROTO = sharedKey("IE_PROTO");
            var EmptyConstructor = function() {
            };
            var scriptTag = function(content) {
              return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
            };
            var NullProtoObjectViaActiveX = function(activeXDocument2) {
              activeXDocument2.write(scriptTag(""));
              activeXDocument2.close();
              var temp = activeXDocument2.parentWindow.Object;
              activeXDocument2 = null;
              return temp;
            };
            var NullProtoObjectViaIFrame = function() {
              var iframe = documentCreateElement("iframe");
              var JS = "java" + SCRIPT + ":";
              var iframeDocument;
              iframe.style.display = "none";
              html2.appendChild(iframe);
              iframe.src = String(JS);
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(scriptTag("document.F=Object"));
              iframeDocument.close();
              return iframeDocument.F;
            };
            var activeXDocument;
            var NullProtoObject = function() {
              try {
                activeXDocument = new ActiveXObject("htmlfile");
              } catch (error) {
              }
              NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
              var length = enumBugKeys.length;
              while (length--)
                delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
              return NullProtoObject();
            };
            hiddenKeys[IE_PROTO] = true;
            module2.exports = Object.create || function create(O, Properties) {
              var result;
              if (O !== null) {
                EmptyConstructor[PROTOTYPE] = anObject(O);
                result = new EmptyConstructor();
                EmptyConstructor[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else
                result = NullProtoObject();
              return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
            };
          },
          8728: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(7670);
            var definePropertyModule = __webpack_require__2(4615);
            var anObject = __webpack_require__2(2569);
            var toIndexedObject = __webpack_require__2(2977);
            var objectKeys = __webpack_require__2(5432);
            exports3.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var props = toIndexedObject(Properties);
              var keys = objectKeys(Properties);
              var length = keys.length;
              var index = 0;
              var key;
              while (length > index)
                definePropertyModule.f(O, key = keys[index++], props[key]);
              return O;
            };
          },
          4615: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var IE8_DOM_DEFINE = __webpack_require__2(275);
            var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(7670);
            var anObject = __webpack_require__2(2569);
            var toPropertyKey = __webpack_require__2(8734);
            var $TypeError = TypeError;
            var $defineProperty = Object.defineProperty;
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var ENUMERABLE = "enumerable";
            var CONFIGURABLE = "configurable";
            var WRITABLE = "writable";
            exports3.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                var current = $getOwnPropertyDescriptor(O, P);
                if (current && current[WRITABLE]) {
                  O[P] = Attributes.value;
                  Attributes = {
                    configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                    enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                    writable: false
                  };
                }
              }
              return $defineProperty(O, P, Attributes);
            } : $defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return $defineProperty(O, P, Attributes);
                } catch (error) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw $TypeError("Accessors not supported");
              if ("value" in Attributes)
                O[P] = Attributes.value;
              return O;
            };
          },
          6683: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var call = __webpack_require__2(8262);
            var propertyIsEnumerableModule = __webpack_require__2(112);
            var createPropertyDescriptor = __webpack_require__2(4677);
            var toIndexedObject = __webpack_require__2(2977);
            var toPropertyKey = __webpack_require__2(8734);
            var hasOwn = __webpack_require__2(2870);
            var IE8_DOM_DEFINE = __webpack_require__2(275);
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports3.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
              O = toIndexedObject(O);
              P = toPropertyKey(P);
              if (IE8_DOM_DEFINE)
                try {
                  return $getOwnPropertyDescriptor(O, P);
                } catch (error) {
                }
              if (hasOwn(O, P))
                return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
            };
          },
          9275: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var internalObjectKeys = __webpack_require__2(8356);
            var enumBugKeys = __webpack_require__2(5690);
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports3.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return internalObjectKeys(O, hiddenKeys);
            };
          },
          4012: (__unused_webpack_module, exports3) => {
            exports3.f = Object.getOwnPropertySymbols;
          },
          729: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var hasOwn = __webpack_require__2(2870);
            var isCallable = __webpack_require__2(9212);
            var toObject2 = __webpack_require__2(1324);
            var sharedKey = __webpack_require__2(9137);
            var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(926);
            var IE_PROTO = sharedKey("IE_PROTO");
            var $Object = Object;
            var ObjectPrototype = $Object.prototype;
            module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
              var object = toObject2(O);
              if (hasOwn(object, IE_PROTO))
                return object[IE_PROTO];
              var constructor = object.constructor;
              if (isCallable(constructor) && object instanceof constructor) {
                return constructor.prototype;
              }
              return object instanceof $Object ? ObjectPrototype : null;
            };
          },
          2447: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            module2.exports = uncurryThis({}.isPrototypeOf);
          },
          8356: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var hasOwn = __webpack_require__2(2870);
            var toIndexedObject = __webpack_require__2(2977);
            var indexOf = __webpack_require__2(5766).indexOf;
            var hiddenKeys = __webpack_require__2(4639);
            var push = uncurryThis([].push);
            module2.exports = function(object, names) {
              var O = toIndexedObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O)
                !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
              while (names.length > i)
                if (hasOwn(O, key = names[i++])) {
                  ~indexOf(result, key) || push(result, key);
                }
              return result;
            };
          },
          5432: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var internalObjectKeys = __webpack_require__2(8356);
            var enumBugKeys = __webpack_require__2(5690);
            module2.exports = Object.keys || function keys(O) {
              return internalObjectKeys(O, enumBugKeys);
            };
          },
          112: (__unused_webpack_module, exports3) => {
            "use strict";
            var $propertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
              1: 2
            }, 1);
            exports3.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
              var descriptor = getOwnPropertyDescriptor(this, V);
              return !!descriptor && descriptor.enumerable;
            } : $propertyIsEnumerable;
          },
          7496: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var anObject = __webpack_require__2(2569);
            var aPossiblePrototype = __webpack_require__2(9882);
            module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var CORRECT_SETTER = false;
              var test = {};
              var setter;
              try {
                setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                setter(test, []);
                CORRECT_SETTER = test instanceof Array;
              } catch (error) {
              }
              return function setPrototypeOf(O, proto) {
                anObject(O);
                aPossiblePrototype(proto);
                if (CORRECT_SETTER)
                  setter(O, proto);
                else
                  O.__proto__ = proto;
                return O;
              };
            }() : void 0);
          },
          6252: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var call = __webpack_require__2(8262);
            var isCallable = __webpack_require__2(9212);
            var isObject = __webpack_require__2(794);
            var $TypeError = TypeError;
            module2.exports = function(input, pref) {
              var fn, val;
              if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                return val;
              if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                return val;
              if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                return val;
              throw $TypeError("Can't convert object to primitive value");
            };
          },
          929: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var getBuiltIn = __webpack_require__2(5897);
            var uncurryThis = __webpack_require__2(7386);
            var getOwnPropertyNamesModule = __webpack_require__2(9275);
            var getOwnPropertySymbolsModule = __webpack_require__2(4012);
            var anObject = __webpack_require__2(2569);
            var concat = uncurryThis([].concat);
            module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
              var keys = getOwnPropertyNamesModule.f(anObject(it));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
            };
          },
          3955: (module2) => {
            var $TypeError = TypeError;
            module2.exports = function(it) {
              if (it == void 0)
                throw $TypeError("Can't call method on " + it);
              return it;
            };
          },
          9137: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var shared = __webpack_require__2(7836);
            var uid = __webpack_require__2(8284);
            var keys = shared("keys");
            module2.exports = function(key) {
              return keys[key] || (keys[key] = uid(key));
            };
          },
          1314: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var defineGlobalProperty = __webpack_require__2(2296);
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
            module2.exports = store;
          },
          7836: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var IS_PURE = __webpack_require__2(6268);
            var store = __webpack_require__2(1314);
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.23.5",
              mode: IS_PURE ? "pure" : "global",
              copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
              license: "https://github.com/zloirock/core-js/blob/v3.23.5/LICENSE",
              source: "https://github.com/zloirock/core-js"
            });
          },
          8117: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var apply = __webpack_require__2(1611);
            var bind = __webpack_require__2(2938);
            var isCallable = __webpack_require__2(9212);
            var hasOwn = __webpack_require__2(2870);
            var fails = __webpack_require__2(6544);
            var html2 = __webpack_require__2(482);
            var arraySlice = __webpack_require__2(6917);
            var createElement = __webpack_require__2(6668);
            var validateArgumentsLength = __webpack_require__2(7520);
            var IS_IOS = __webpack_require__2(7020);
            var IS_NODE = __webpack_require__2(5354);
            var set = global2.setImmediate;
            var clear = global2.clearImmediate;
            var process2 = global2.process;
            var Dispatch = global2.Dispatch;
            var Function2 = global2.Function;
            var MessageChannel = global2.MessageChannel;
            var String2 = global2.String;
            var counter = 0;
            var queue = {};
            var ONREADYSTATECHANGE = "onreadystatechange";
            var location2, defer, channel, port;
            try {
              location2 = global2.location;
            } catch (error) {
            }
            var run = function(id) {
              if (hasOwn(queue, id)) {
                var fn = queue[id];
                delete queue[id];
                fn();
              }
            };
            var runner = function(id) {
              return function() {
                run(id);
              };
            };
            var listener = function(event) {
              run(event.data);
            };
            var post = function(id) {
              global2.postMessage(String2(id), location2.protocol + "//" + location2.host);
            };
            if (!set || !clear) {
              set = function setImmediate(handler) {
                validateArgumentsLength(arguments.length, 1);
                var fn = isCallable(handler) ? handler : Function2(handler);
                var args = arraySlice(arguments, 1);
                queue[++counter] = function() {
                  apply(fn, void 0, args);
                };
                defer(counter);
                return counter;
              };
              clear = function clearImmediate(id) {
                delete queue[id];
              };
              if (IS_NODE) {
                defer = function(id) {
                  process2.nextTick(runner(id));
                };
              } else if (Dispatch && Dispatch.now) {
                defer = function(id) {
                  Dispatch.now(runner(id));
                };
              } else if (MessageChannel && !IS_IOS) {
                channel = new MessageChannel();
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = bind(port.postMessage, port);
              } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && location2 && location2.protocol !== "file:" && !fails(post)) {
                defer = post;
                global2.addEventListener("message", listener, false);
              } else if (ONREADYSTATECHANGE in createElement("script")) {
                defer = function(id) {
                  html2.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                    html2.removeChild(this);
                    run(id);
                  };
                };
              } else {
                defer = function(id) {
                  setTimeout(runner(id), 0);
                };
              }
            }
            module2.exports = {
              set,
              clear
            };
          },
          6782: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toIntegerOrInfinity = __webpack_require__2(7486);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              var integer = toIntegerOrInfinity(index);
              return integer < 0 ? max(integer + length, 0) : min(integer, length);
            };
          },
          2977: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var IndexedObject = __webpack_require__2(5044);
            var requireObjectCoercible = __webpack_require__2(3955);
            module2.exports = function(it) {
              return IndexedObject(requireObjectCoercible(it));
            };
          },
          7486: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var trunc = __webpack_require__2(9021);
            module2.exports = function(argument) {
              var number = +argument;
              return number !== number || number === 0 ? 0 : trunc(number);
            };
          },
          97: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toIntegerOrInfinity = __webpack_require__2(7486);
            var min = Math.min;
            module2.exports = function(argument) {
              return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
            };
          },
          1324: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var requireObjectCoercible = __webpack_require__2(3955);
            var $Object = Object;
            module2.exports = function(argument) {
              return $Object(requireObjectCoercible(argument));
            };
          },
          3248: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toPositiveInteger = __webpack_require__2(2955);
            var $RangeError = RangeError;
            module2.exports = function(it, BYTES) {
              var offset = toPositiveInteger(it);
              if (offset % BYTES)
                throw $RangeError("Wrong offset");
              return offset;
            };
          },
          2955: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toIntegerOrInfinity = __webpack_require__2(7486);
            var $RangeError = RangeError;
            module2.exports = function(it) {
              var result = toIntegerOrInfinity(it);
              if (result < 0)
                throw $RangeError("The argument can't be less than 0");
              return result;
            };
          },
          2670: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var call = __webpack_require__2(8262);
            var isObject = __webpack_require__2(794);
            var isSymbol = __webpack_require__2(5871);
            var getMethod = __webpack_require__2(911);
            var ordinaryToPrimitive = __webpack_require__2(6252);
            var wellKnownSymbol = __webpack_require__2(3649);
            var $TypeError = TypeError;
            var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
            module2.exports = function(input, pref) {
              if (!isObject(input) || isSymbol(input))
                return input;
              var exoticToPrim = getMethod(input, TO_PRIMITIVE);
              var result;
              if (exoticToPrim) {
                if (pref === void 0)
                  pref = "default";
                result = call(exoticToPrim, input, pref);
                if (!isObject(result) || isSymbol(result))
                  return result;
                throw $TypeError("Can't convert object to primitive value");
              }
              if (pref === void 0)
                pref = "number";
              return ordinaryToPrimitive(input, pref);
            };
          },
          8734: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var toPrimitive = __webpack_require__2(2670);
            var isSymbol = __webpack_require__2(5871);
            module2.exports = function(argument) {
              var key = toPrimitive(argument, "string");
              return isSymbol(key) ? key : key + "";
            };
          },
          8191: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var wellKnownSymbol = __webpack_require__2(3649);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var test = {};
            test[TO_STRING_TAG] = "z";
            module2.exports = String(test) === "[object z]";
          },
          5637: (module2) => {
            var $String = String;
            module2.exports = function(argument) {
              try {
                return $String(argument);
              } catch (error) {
                return "Object";
              }
            };
          },
          8284: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var uncurryThis = __webpack_require__2(7386);
            var id = 0;
            var postfix = Math.random();
            var toString = uncurryThis(1 .toString);
            module2.exports = function(key) {
              return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
            };
          },
          7786: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var NATIVE_SYMBOL = __webpack_require__2(8640);
            module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
          },
          7670: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var DESCRIPTORS = __webpack_require__2(8494);
            var fails = __webpack_require__2(6544);
            module2.exports = DESCRIPTORS && fails(function() {
              return Object.defineProperty(function() {
              }, "prototype", {
                value: 42,
                writable: false
              }).prototype != 42;
            });
          },
          7520: (module2) => {
            var $TypeError = TypeError;
            module2.exports = function(passed, required) {
              if (passed < required)
                throw $TypeError("Not enough arguments");
              return passed;
            };
          },
          3649: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var global2 = __webpack_require__2(7583);
            var shared = __webpack_require__2(7836);
            var hasOwn = __webpack_require__2(2870);
            var uid = __webpack_require__2(8284);
            var NATIVE_SYMBOL = __webpack_require__2(8640);
            var USE_SYMBOL_AS_UID = __webpack_require__2(7786);
            var WellKnownSymbolsStore = shared("wks");
            var Symbol2 = global2.Symbol;
            var symbolFor = Symbol2 && Symbol2["for"];
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
            module2.exports = function(name) {
              if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                var description = "Symbol." + name;
                if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
                  WellKnownSymbolsStore[name] = Symbol2[name];
                } else if (USE_SYMBOL_AS_UID && symbolFor) {
                  WellKnownSymbolsStore[name] = symbolFor(description);
                } else {
                  WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                }
              }
              return WellKnownSymbolsStore[name];
            };
          },
          2076: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(2076);
            var $ = __webpack_require__2(7263);
            var $includes = __webpack_require__2(5766).includes;
            var fails = __webpack_require__2(6544);
            var addToUnscopables = __webpack_require__2(6288);
            var BROKEN_ON_SPARSE = fails(function() {
              return !Array(1).includes();
            });
            $({
              target: "Array",
              proto: true,
              forced: BROKEN_ON_SPARSE
            }, {
              includes: function includes(el) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            addToUnscopables("includes");
          },
          9494: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(9494);
            var global2 = __webpack_require__2(7583);
            var call = __webpack_require__2(8262);
            var ArrayBufferViewCore = __webpack_require__2(3977);
            var lengthOfArrayLike = __webpack_require__2(1825);
            var toOffset = __webpack_require__2(3248);
            var toIndexedObject = __webpack_require__2(1324);
            var fails = __webpack_require__2(6544);
            var RangeError2 = global2.RangeError;
            var Int8Array2 = global2.Int8Array;
            var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
            var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
            var aTypedArray = ArrayBufferViewCore.aTypedArray;
            var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
            var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function() {
              var array = new Uint8ClampedArray(2);
              call($set, array, {
                length: 1,
                0: 3
              }, 1);
              return array[1] !== 3;
            });
            var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
              var array = new Int8Array2(2);
              array.set(1);
              array.set("2", 1);
              return array[0] !== 0 || array[1] !== 2;
            });
            exportTypedArrayMethod("set", function set(arrayLike) {
              aTypedArray(this);
              var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
              var src = toIndexedObject(arrayLike);
              if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS)
                return call($set, this, src, offset);
              var length = this.length;
              var len = lengthOfArrayLike(src);
              var index = 0;
              if (len + offset > length)
                throw RangeError2("Wrong length");
              while (index < len)
                this[offset + index] = src[index++];
            }, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
          },
          4229: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            var $ = __webpack_require__2(7263);
            var global2 = __webpack_require__2(7583);
            var clearImmediate = __webpack_require__2(8117).clear;
            $({
              global: true,
              bind: true,
              enumerable: true,
              forced: global2.clearImmediate !== clearImmediate
            }, {
              clearImmediate
            });
          },
          8192: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            __webpack_require__2(4229);
            __webpack_require__2(5373);
          },
          5373: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
            var $ = __webpack_require__2(7263);
            var global2 = __webpack_require__2(7583);
            var setImmediate = __webpack_require__2(8117).set;
            $({
              global: true,
              bind: true,
              enumerable: true,
              forced: global2.setImmediate !== setImmediate
            }, {
              setImmediate
            });
          },
          1590: (module2) => {
            "use strict";
            var R = typeof Reflect === "object" ? Reflect : null;
            var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args);
            };
            var ReflectOwnKeys;
            if (R && typeof R.ownKeys === "function") {
              ReflectOwnKeys = R.ownKeys;
            } else if (Object.getOwnPropertySymbols) {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
              };
            } else {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target);
              };
            }
            function ProcessEmitWarning(warning) {
              if (console && console.warn)
                console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
              return value !== value;
            };
            function EventEmitter() {
              EventEmitter.init.call(this);
            }
            module2.exports = EventEmitter;
            module2.exports.once = once;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = void 0;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
              if (typeof listener !== "function") {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
              }
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return defaultMaxListeners;
              },
              set: function(arg) {
                if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                  throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                }
                defaultMaxListeners = arg;
              }
            });
            EventEmitter.init = function() {
              if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              }
              this._maxListeners = this._maxListeners || void 0;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
              if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
              }
              this._maxListeners = n;
              return this;
            };
            function _getMaxListeners(that) {
              if (that._maxListeners === void 0)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
              var args = [];
              for (var i = 1; i < arguments.length; i++)
                args.push(arguments[i]);
              var doError = type === "error";
              var events = this._events;
              if (events !== void 0)
                doError = doError && events.error === void 0;
              else if (!doError)
                return false;
              if (doError) {
                var er;
                if (args.length > 0)
                  er = args[0];
                if (er instanceof Error) {
                  throw er;
                }
                var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                err.context = er;
                throw err;
              }
              var handler = events[type];
              if (handler === void 0)
                return false;
              if (typeof handler === "function") {
                ReflectApply(handler, this, args);
              } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  ReflectApply(listeners[i], this, args);
              }
              return true;
            };
            function _addListener(target, type, listener, prepend) {
              var m;
              var events;
              var existing;
              checkListener(listener);
              events = target._events;
              if (events === void 0) {
                events = target._events = /* @__PURE__ */ Object.create(null);
                target._eventsCount = 0;
              } else {
                if (events.newListener !== void 0) {
                  target.emit("newListener", type, listener.listener ? listener.listener : listener);
                  events = target._events;
                }
                existing = events[type];
              }
              if (existing === void 0) {
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === "function") {
                  existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                } else if (prepend) {
                  existing.unshift(listener);
                } else {
                  existing.push(listener);
                }
                m = _getMaxListeners(target);
                if (m > 0 && existing.length > m && !existing.warned) {
                  existing.warned = true;
                  var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  w.name = "MaxListenersExceededWarning";
                  w.emitter = target;
                  w.type = type;
                  w.count = existing.length;
                  ProcessEmitWarning(w);
                }
              }
              return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener(type, listener) {
              return _addListener(this, type, listener, true);
            };
            function onceWrapper() {
              if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0)
                  return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
              }
            }
            function _onceWrap(target, type, listener) {
              var state = {
                fired: false,
                wrapFn: void 0,
                target,
                type,
                listener
              };
              var wrapped = onceWrapper.bind(state);
              wrapped.listener = listener;
              state.wrapFn = wrapped;
              return wrapped;
            }
            EventEmitter.prototype.once = function once2(type, listener) {
              checkListener(listener);
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.removeListener = function removeListener(type, listener) {
              var list, events, position, i, originalListener;
              checkListener(listener);
              events = this._events;
              if (events === void 0)
                return this;
              list = events[type];
              if (list === void 0)
                return this;
              if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else {
                  delete events[type];
                  if (events.removeListener)
                    this.emit("removeListener", type, list.listener || listener);
                }
              } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                  if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                  }
                }
                if (position < 0)
                  return this;
                if (position === 0)
                  list.shift();
                else {
                  spliceOne(list, position);
                }
                if (list.length === 1)
                  events[type] = list[0];
                if (events.removeListener !== void 0)
                  this.emit("removeListener", type, originalListener || listener);
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
              var listeners, events, i;
              events = this._events;
              if (events === void 0)
                return this;
              if (events.removeListener === void 0) {
                if (arguments.length === 0) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== void 0) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else
                    delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === "removeListener")
                    continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === "function") {
                this.removeListener(type, listeners);
              } else if (listeners !== void 0) {
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }
              return this;
            };
            function _listeners(target, type, unwrap) {
              var events = target._events;
              if (events === void 0)
                return [];
              var evlistener = events[type];
              if (evlistener === void 0)
                return [];
              if (typeof evlistener === "function")
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];
              return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
              return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
              return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;
              if (events !== void 0) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                  return 1;
                } else if (evlistener !== void 0) {
                  return evlistener.length;
                }
              }
              return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n) {
              var copy = new Array(n);
              for (var i = 0; i < n; ++i)
                copy[i] = arr[i];
              return copy;
            }
            function spliceOne(list, index) {
              for (; index + 1 < list.length; index++)
                list[index] = list[index + 1];
              list.pop();
            }
            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
              }
              return ret;
            }
            function once(emitter, name) {
              return new Promise(function(resolve2, reject) {
                function errorListener(err) {
                  emitter.removeListener(name, resolver);
                  reject(err);
                }
                function resolver() {
                  if (typeof emitter.removeListener === "function") {
                    emitter.removeListener("error", errorListener);
                  }
                  resolve2([].slice.call(arguments));
                }
                ;
                eventTargetAgnosticAddListener(emitter, name, resolver, {
                  once: true
                });
                if (name !== "error") {
                  addErrorHandlerIfEventEmitter(emitter, errorListener, {
                    once: true
                  });
                }
              });
            }
            function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
              if (typeof emitter.on === "function") {
                eventTargetAgnosticAddListener(emitter, "error", handler, flags);
              }
            }
            function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
              if (typeof emitter.on === "function") {
                if (flags.once) {
                  emitter.once(name, listener);
                } else {
                  emitter.on(name, listener);
                }
              } else if (typeof emitter.addEventListener === "function") {
                emitter.addEventListener(name, function wrapListener(arg) {
                  if (flags.once) {
                    emitter.removeEventListener(name, wrapListener);
                  }
                  listener(arg);
                });
              } else {
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
              }
            }
          },
          4730: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var isCallable = __webpack_require__2(9898);
            var toStr = Object.prototype.toString;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var forEachArray = function forEachArray2(array, iterator, receiver) {
              for (var i = 0, len = array.length; i < len; i++) {
                if (hasOwnProperty.call(array, i)) {
                  if (receiver == null) {
                    iterator(array[i], i, array);
                  } else {
                    iterator.call(receiver, array[i], i, array);
                  }
                }
              }
            };
            var forEachString = function forEachString2(string, iterator, receiver) {
              for (var i = 0, len = string.length; i < len; i++) {
                if (receiver == null) {
                  iterator(string.charAt(i), i, string);
                } else {
                  iterator.call(receiver, string.charAt(i), i, string);
                }
              }
            };
            var forEachObject = function forEachObject2(object, iterator, receiver) {
              for (var k in object) {
                if (hasOwnProperty.call(object, k)) {
                  if (receiver == null) {
                    iterator(object[k], k, object);
                  } else {
                    iterator.call(receiver, object[k], k, object);
                  }
                }
              }
            };
            var forEach = function forEach2(list, iterator, thisArg) {
              if (!isCallable(iterator)) {
                throw new TypeError("iterator must be a function");
              }
              var receiver;
              if (arguments.length >= 3) {
                receiver = thisArg;
              }
              if (toStr.call(list) === "[object Array]") {
                forEachArray(list, iterator, receiver);
              } else if (typeof list === "string") {
                forEachString(list, iterator, receiver);
              } else {
                forEachObject(list, iterator, receiver);
              }
            };
            module2.exports = forEach;
          },
          7193: (module2) => {
            "use strict";
            var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
            var slice = Array.prototype.slice;
            var toStr = Object.prototype.toString;
            var funcType = "[object Function]";
            module2.exports = function bind(that) {
              var target = this;
              if (typeof target !== "function" || toStr.call(target) !== funcType) {
                throw new TypeError(ERROR_MESSAGE + target);
              }
              var args = slice.call(arguments, 1);
              var bound;
              var binder = function() {
                if (this instanceof bound) {
                  var result = target.apply(this, args.concat(slice.call(arguments)));
                  if (Object(result) === result) {
                    return result;
                  }
                  return this;
                } else {
                  return target.apply(that, args.concat(slice.call(arguments)));
                }
              };
              var boundLength = Math.max(0, target.length - args.length);
              var boundArgs = [];
              for (var i = 0; i < boundLength; i++) {
                boundArgs.push("$" + i);
              }
              bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
              if (target.prototype) {
                var Empty = function Empty2() {
                };
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
              }
              return bound;
            };
          },
          4597: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var implementation = __webpack_require__2(7193);
            module2.exports = Function.prototype.bind || implementation;
          },
          3584: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(9494);
            var undefined2;
            var $SyntaxError = SyntaxError;
            var $Function = Function;
            var $TypeError = TypeError;
            var getEvalledConstructor = function(expressionSyntax) {
              try {
                return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
              } catch (e) {
              }
            };
            var $gOPD = Object.getOwnPropertyDescriptor;
            if ($gOPD) {
              try {
                $gOPD({}, "");
              } catch (e) {
                $gOPD = null;
              }
            }
            var throwTypeError = function() {
              throw new $TypeError();
            };
            var ThrowTypeError = $gOPD ? function() {
              try {
                arguments.callee;
                return throwTypeError;
              } catch (calleeThrows) {
                try {
                  return $gOPD(arguments, "callee").get;
                } catch (gOPDthrows) {
                  return throwTypeError;
                }
              }
            }() : throwTypeError;
            var hasSymbols = __webpack_require__2(563)();
            var getProto = Object.getPrototypeOf || function(x) {
              return x.__proto__;
            };
            var needsEval = {};
            var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
            var INTRINSICS = {
              "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
              "%Array%": Array,
              "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
              "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
              "%AsyncFromSyncIteratorPrototype%": undefined2,
              "%AsyncFunction%": needsEval,
              "%AsyncGenerator%": needsEval,
              "%AsyncGeneratorFunction%": needsEval,
              "%AsyncIteratorPrototype%": needsEval,
              "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
              "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
              "%Boolean%": Boolean,
              "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
              "%Date%": Date,
              "%decodeURI%": decodeURI,
              "%decodeURIComponent%": decodeURIComponent,
              "%encodeURI%": encodeURI,
              "%encodeURIComponent%": encodeURIComponent,
              "%Error%": Error,
              "%eval%": eval,
              "%EvalError%": EvalError,
              "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
              "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
              "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
              "%Function%": $Function,
              "%GeneratorFunction%": needsEval,
              "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
              "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
              "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
              "%isFinite%": isFinite,
              "%isNaN%": isNaN,
              "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
              "%JSON%": typeof JSON === "object" ? JSON : undefined2,
              "%Map%": typeof Map === "undefined" ? undefined2 : Map,
              "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
              "%Math%": Math,
              "%Number%": Number,
              "%Object%": Object,
              "%parseFloat%": parseFloat,
              "%parseInt%": parseInt,
              "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
              "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
              "%RangeError%": RangeError,
              "%ReferenceError%": ReferenceError,
              "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
              "%RegExp%": RegExp,
              "%Set%": typeof Set === "undefined" ? undefined2 : Set,
              "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
              "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
              "%String%": String,
              "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
              "%Symbol%": hasSymbols ? Symbol : undefined2,
              "%SyntaxError%": $SyntaxError,
              "%ThrowTypeError%": ThrowTypeError,
              "%TypedArray%": TypedArray,
              "%TypeError%": $TypeError,
              "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
              "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
              "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
              "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
              "%URIError%": URIError,
              "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
              "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
              "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
            };
            var doEval = function doEval2(name) {
              var value;
              if (name === "%AsyncFunction%") {
                value = getEvalledConstructor("async function () {}");
              } else if (name === "%GeneratorFunction%") {
                value = getEvalledConstructor("function* () {}");
              } else if (name === "%AsyncGeneratorFunction%") {
                value = getEvalledConstructor("async function* () {}");
              } else if (name === "%AsyncGenerator%") {
                var fn = doEval2("%AsyncGeneratorFunction%");
                if (fn) {
                  value = fn.prototype;
                }
              } else if (name === "%AsyncIteratorPrototype%") {
                var gen = doEval2("%AsyncGenerator%");
                if (gen) {
                  value = getProto(gen.prototype);
                }
              }
              INTRINSICS[name] = value;
              return value;
            };
            var LEGACY_ALIASES = {
              "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
              "%ArrayPrototype%": ["Array", "prototype"],
              "%ArrayProto_entries%": ["Array", "prototype", "entries"],
              "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
              "%ArrayProto_keys%": ["Array", "prototype", "keys"],
              "%ArrayProto_values%": ["Array", "prototype", "values"],
              "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
              "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
              "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
              "%BooleanPrototype%": ["Boolean", "prototype"],
              "%DataViewPrototype%": ["DataView", "prototype"],
              "%DatePrototype%": ["Date", "prototype"],
              "%ErrorPrototype%": ["Error", "prototype"],
              "%EvalErrorPrototype%": ["EvalError", "prototype"],
              "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
              "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
              "%FunctionPrototype%": ["Function", "prototype"],
              "%Generator%": ["GeneratorFunction", "prototype"],
              "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
              "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
              "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
              "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
              "%JSONParse%": ["JSON", "parse"],
              "%JSONStringify%": ["JSON", "stringify"],
              "%MapPrototype%": ["Map", "prototype"],
              "%NumberPrototype%": ["Number", "prototype"],
              "%ObjectPrototype%": ["Object", "prototype"],
              "%ObjProto_toString%": ["Object", "prototype", "toString"],
              "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
              "%PromisePrototype%": ["Promise", "prototype"],
              "%PromiseProto_then%": ["Promise", "prototype", "then"],
              "%Promise_all%": ["Promise", "all"],
              "%Promise_reject%": ["Promise", "reject"],
              "%Promise_resolve%": ["Promise", "resolve"],
              "%RangeErrorPrototype%": ["RangeError", "prototype"],
              "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
              "%RegExpPrototype%": ["RegExp", "prototype"],
              "%SetPrototype%": ["Set", "prototype"],
              "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
              "%StringPrototype%": ["String", "prototype"],
              "%SymbolPrototype%": ["Symbol", "prototype"],
              "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
              "%TypedArrayPrototype%": ["TypedArray", "prototype"],
              "%TypeErrorPrototype%": ["TypeError", "prototype"],
              "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
              "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
              "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
              "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
              "%URIErrorPrototype%": ["URIError", "prototype"],
              "%WeakMapPrototype%": ["WeakMap", "prototype"],
              "%WeakSetPrototype%": ["WeakSet", "prototype"]
            };
            var bind = __webpack_require__2(4597);
            var hasOwn = __webpack_require__2(8380);
            var $concat = bind.call(Function.call, Array.prototype.concat);
            var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
            var $replace = bind.call(Function.call, String.prototype.replace);
            var $strSlice = bind.call(Function.call, String.prototype.slice);
            var $exec = bind.call(Function.call, RegExp.prototype.exec);
            var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
            var reEscapeChar = /\\(\\)?/g;
            var stringToPath = function stringToPath2(string) {
              var first = $strSlice(string, 0, 1);
              var last = $strSlice(string, -1);
              if (first === "%" && last !== "%") {
                throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
              } else if (last === "%" && first !== "%") {
                throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
              }
              var result = [];
              $replace(string, rePropName, function(match, number, quote, subString) {
                result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
              });
              return result;
            };
            var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
              var intrinsicName = name;
              var alias;
              if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                alias = LEGACY_ALIASES[intrinsicName];
                intrinsicName = "%" + alias[0] + "%";
              }
              if (hasOwn(INTRINSICS, intrinsicName)) {
                var value = INTRINSICS[intrinsicName];
                if (value === needsEval) {
                  value = doEval(intrinsicName);
                }
                if (typeof value === "undefined" && !allowMissing) {
                  throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
                }
                return {
                  alias,
                  name: intrinsicName,
                  value
                };
              }
              throw new $SyntaxError("intrinsic " + name + " does not exist!");
            };
            module2.exports = function GetIntrinsic(name, allowMissing) {
              if (typeof name !== "string" || name.length === 0) {
                throw new $TypeError("intrinsic name must be a non-empty string");
              }
              if (arguments.length > 1 && typeof allowMissing !== "boolean") {
                throw new $TypeError('"allowMissing" argument must be a boolean');
              }
              if ($exec(/^%?[^%]*%?$/g, name) === null) {
                throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
              }
              var parts2 = stringToPath(name);
              var intrinsicBaseName = parts2.length > 0 ? parts2[0] : "";
              var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
              var intrinsicRealName = intrinsic.name;
              var value = intrinsic.value;
              var skipFurtherCaching = false;
              var alias = intrinsic.alias;
              if (alias) {
                intrinsicBaseName = alias[0];
                $spliceApply(parts2, $concat([0, 1], alias));
              }
              for (var i = 1, isOwn = true; i < parts2.length; i += 1) {
                var part = parts2[i];
                var first = $strSlice(part, 0, 1);
                var last = $strSlice(part, -1);
                if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
                  throw new $SyntaxError("property names with quotes must have matching quotes");
                }
                if (part === "constructor" || !isOwn) {
                  skipFurtherCaching = true;
                }
                intrinsicBaseName += "." + part;
                intrinsicRealName = "%" + intrinsicBaseName + "%";
                if (hasOwn(INTRINSICS, intrinsicRealName)) {
                  value = INTRINSICS[intrinsicRealName];
                } else if (value != null) {
                  if (!(part in value)) {
                    if (!allowMissing) {
                      throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                    }
                    return void 0;
                  }
                  if ($gOPD && i + 1 >= parts2.length) {
                    var desc = $gOPD(value, part);
                    isOwn = !!desc;
                    if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                      value = desc.get;
                    } else {
                      value = value[part];
                    }
                  } else {
                    isOwn = hasOwn(value, part);
                    value = value[part];
                  }
                  if (isOwn && !skipFurtherCaching) {
                    INTRINSICS[intrinsicRealName] = value;
                  }
                }
              }
              return value;
            };
          },
          563: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var origSymbol = typeof Symbol !== "undefined" && Symbol;
            var hasSymbolSham = __webpack_require__2(9956);
            module2.exports = function hasNativeSymbols() {
              if (typeof origSymbol !== "function") {
                return false;
              }
              if (typeof Symbol !== "function") {
                return false;
              }
              if (typeof origSymbol("foo") !== "symbol") {
                return false;
              }
              if (typeof Symbol("bar") !== "symbol") {
                return false;
              }
              return hasSymbolSham();
            };
          },
          9956: (module2) => {
            "use strict";
            module2.exports = function hasSymbols() {
              if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
                return false;
              }
              if (typeof Symbol.iterator === "symbol") {
                return true;
              }
              var obj = {};
              var sym = Symbol("test");
              var symObj = Object(sym);
              if (typeof sym === "string") {
                return false;
              }
              if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
                return false;
              }
              if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
                return false;
              }
              var symVal = 42;
              obj[sym] = symVal;
              for (sym in obj) {
                return false;
              }
              if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
                return false;
              }
              if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
                return false;
              }
              var syms = Object.getOwnPropertySymbols(obj);
              if (syms.length !== 1 || syms[0] !== sym) {
                return false;
              }
              if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                return false;
              }
              if (typeof Object.getOwnPropertyDescriptor === "function") {
                var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                  return false;
                }
              }
              return true;
            };
          },
          6323: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var hasSymbols = __webpack_require__2(9956);
            module2.exports = function hasToStringTagShams() {
              return hasSymbols() && !!Symbol.toStringTag;
            };
          },
          8380: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var bind = __webpack_require__2(4597);
            module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
          },
          9804: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var http = __webpack_require__2(5262);
            var url = __webpack_require__2(3149);
            var https = module2.exports;
            for (var key in http) {
              if (http.hasOwnProperty(key))
                https[key] = http[key];
            }
            https.request = function(params, cb) {
              params = validateParams(params);
              return http.request.call(this, params, cb);
            };
            https.get = function(params, cb) {
              params = validateParams(params);
              return http.get.call(this, params, cb);
            };
            function validateParams(params) {
              if (typeof params === "string") {
                params = url.parse(params);
              }
              if (!params.protocol) {
                params.protocol = "https:";
              }
              if (params.protocol !== "https:") {
                throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
              }
              return params;
            }
          },
          9350: (__unused_webpack_module, exports3) => {
            exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? nBytes - 1 : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];
              i += d;
              e = s & (1 << -nBits) - 1;
              s >>= -nBits;
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
              }
              m = e & (1 << -nBits) - 1;
              e >>= -nBits;
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
              }
              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };
            exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
              var i = isLE ? 0 : nBytes - 1;
              var d = isLE ? 1 : -1;
              var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
              value = Math.abs(value);
              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }
                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }
              for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
              }
              e = e << mLen | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
              }
              buffer[offset + i - d] |= s * 128;
            };
          },
          5153: (module2) => {
            if (typeof Object.create === "function") {
              module2.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                  ctor.super_ = superCtor;
                  ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                }
              };
            } else {
              module2.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                  ctor.super_ = superCtor;
                  var TempCtor = function() {
                  };
                  TempCtor.prototype = superCtor.prototype;
                  ctor.prototype = new TempCtor();
                  ctor.prototype.constructor = ctor;
                }
              };
            }
          },
          5401: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var hasToStringTag = __webpack_require__2(6323)();
            var callBound = __webpack_require__2(2648);
            var $toString = callBound("Object.prototype.toString");
            var isStandardArguments = function isArguments(value) {
              if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
                return false;
              }
              return $toString(value) === "[object Arguments]";
            };
            var isLegacyArguments = function isArguments(value) {
              if (isStandardArguments(value)) {
                return true;
              }
              return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
            };
            var supportsStandardArguments = function() {
              return isStandardArguments(arguments);
            }();
            isStandardArguments.isLegacyArguments = isLegacyArguments;
            module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
          },
          9898: (module2) => {
            "use strict";
            var fnToStr = Function.prototype.toString;
            var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
            var badArrayLike;
            var isCallableMarker;
            if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
              try {
                badArrayLike = Object.defineProperty({}, "length", {
                  get: function() {
                    throw isCallableMarker;
                  }
                });
                isCallableMarker = {};
                reflectApply(function() {
                  throw 42;
                }, null, badArrayLike);
              } catch (_) {
                if (_ !== isCallableMarker) {
                  reflectApply = null;
                }
              }
            } else {
              reflectApply = null;
            }
            var constructorRegex = /^\s*class\b/;
            var isES6ClassFn = function isES6ClassFunction(value) {
              try {
                var fnStr = fnToStr.call(value);
                return constructorRegex.test(fnStr);
              } catch (e) {
                return false;
              }
            };
            var tryFunctionObject = function tryFunctionToStr(value) {
              try {
                if (isES6ClassFn(value)) {
                  return false;
                }
                fnToStr.call(value);
                return true;
              } catch (e) {
                return false;
              }
            };
            var toStr = Object.prototype.toString;
            var fnClass = "[object Function]";
            var genClass = "[object GeneratorFunction]";
            var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
            var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
            module2.exports = reflectApply ? function isCallable(value) {
              if (value === documentDotAll) {
                return true;
              }
              if (!value) {
                return false;
              }
              if (typeof value !== "function" && typeof value !== "object") {
                return false;
              }
              if (typeof value === "function" && !value.prototype) {
                return true;
              }
              try {
                reflectApply(value, null, badArrayLike);
              } catch (e) {
                if (e !== isCallableMarker) {
                  return false;
                }
              }
              return !isES6ClassFn(value);
            } : function isCallable(value) {
              if (value === documentDotAll) {
                return true;
              }
              if (!value) {
                return false;
              }
              if (typeof value !== "function" && typeof value !== "object") {
                return false;
              }
              if (typeof value === "function" && !value.prototype) {
                return true;
              }
              if (hasToStringTag) {
                return tryFunctionObject(value);
              }
              if (isES6ClassFn(value)) {
                return false;
              }
              var strClass = toStr.call(value);
              return strClass === fnClass || strClass === genClass;
            };
          },
          3319: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var toStr = Object.prototype.toString;
            var fnToStr = Function.prototype.toString;
            var isFnRegex = /^\s*(?:function)?\*/;
            var hasToStringTag = __webpack_require__2(6323)();
            var getProto = Object.getPrototypeOf;
            var getGeneratorFunc = function() {
              if (!hasToStringTag) {
                return false;
              }
              try {
                return Function("return function*() {}")();
              } catch (e) {
              }
            };
            var GeneratorFunction;
            module2.exports = function isGeneratorFunction(fn) {
              if (typeof fn !== "function") {
                return false;
              }
              if (isFnRegex.test(fnToStr.call(fn))) {
                return true;
              }
              if (!hasToStringTag) {
                var str = toStr.call(fn);
                return str === "[object GeneratorFunction]";
              }
              if (!getProto) {
                return false;
              }
              if (typeof GeneratorFunction === "undefined") {
                var generatorFunc = getGeneratorFunc();
                GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
              }
              return getProto(fn) === GeneratorFunction;
            };
          },
          3513: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var forEach = __webpack_require__2(4730);
            var availableTypedArrays = __webpack_require__2(9808);
            var callBound = __webpack_require__2(2648);
            var $toString = callBound("Object.prototype.toString");
            var hasToStringTag = __webpack_require__2(6323)();
            var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
            var typedArrays = availableTypedArrays();
            var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
              for (var i = 0; i < array.length; i += 1) {
                if (array[i] === value) {
                  return i;
                }
              }
              return -1;
            };
            var $slice = callBound("String.prototype.slice");
            var toStrTags = {};
            var gOPD = __webpack_require__2(9980);
            var getPrototypeOf = Object.getPrototypeOf;
            if (hasToStringTag && gOPD && getPrototypeOf) {
              forEach(typedArrays, function(typedArray) {
                var arr = new g[typedArray]();
                if (Symbol.toStringTag in arr) {
                  var proto = getPrototypeOf(arr);
                  var descriptor = gOPD(proto, Symbol.toStringTag);
                  if (!descriptor) {
                    var superProto = getPrototypeOf(proto);
                    descriptor = gOPD(superProto, Symbol.toStringTag);
                  }
                  toStrTags[typedArray] = descriptor.get;
                }
              });
            }
            var tryTypedArrays = function tryAllTypedArrays(value) {
              var anyTrue = false;
              forEach(toStrTags, function(getter, typedArray) {
                if (!anyTrue) {
                  try {
                    anyTrue = getter.call(value) === typedArray;
                  } catch (e) {
                  }
                }
              });
              return anyTrue;
            };
            module2.exports = function isTypedArray(value) {
              if (!value || typeof value !== "object") {
                return false;
              }
              if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                var tag = $slice($toString(value), 8, -1);
                return $indexOf(typedArrays, tag) > -1;
              }
              if (!gOPD) {
                return false;
              }
              return tryTypedArrays(value);
            };
          },
          7949: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var loader = __webpack_require__2(7501);
            var dumper = __webpack_require__2(8932);
            function renamed(from, to) {
              return function() {
                throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
              };
            }
            module2.exports.Type = __webpack_require__2(2274);
            module2.exports.Schema = __webpack_require__2(9218);
            module2.exports.FAILSAFE_SCHEMA = __webpack_require__2(3552);
            module2.exports.JSON_SCHEMA = __webpack_require__2(8198);
            module2.exports.CORE_SCHEMA = __webpack_require__2(3189);
            module2.exports.DEFAULT_SCHEMA = __webpack_require__2(7345);
            module2.exports.load = loader.load;
            module2.exports.loadAll = loader.loadAll;
            module2.exports.dump = dumper.dump;
            module2.exports.YAMLException = __webpack_require__2(1833);
            module2.exports.types = {
              binary: __webpack_require__2(682),
              float: __webpack_require__2(6633),
              map: __webpack_require__2(584),
              null: __webpack_require__2(3328),
              pairs: __webpack_require__2(3006),
              set: __webpack_require__2(8302),
              timestamp: __webpack_require__2(7692),
              bool: __webpack_require__2(2711),
              int: __webpack_require__2(3512),
              merge: __webpack_require__2(1570),
              omap: __webpack_require__2(9272),
              seq: __webpack_require__2(4566),
              str: __webpack_require__2(4035)
            };
            module2.exports.safeLoad = renamed("safeLoad", "load");
            module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
            module2.exports.safeDump = renamed("safeDump", "dump");
          },
          9249: (module2) => {
            "use strict";
            function isNothing(subject) {
              return typeof subject === "undefined" || subject === null;
            }
            function isObject(subject) {
              return typeof subject === "object" && subject !== null;
            }
            function toArray(sequence) {
              if (Array.isArray(sequence))
                return sequence;
              else if (isNothing(sequence))
                return [];
              return [sequence];
            }
            function extend(target, source) {
              var index, length, key, sourceKeys;
              if (source) {
                sourceKeys = Object.keys(source);
                for (index = 0, length = sourceKeys.length; index < length; index += 1) {
                  key = sourceKeys[index];
                  target[key] = source[key];
                }
              }
              return target;
            }
            function repeat(string, count) {
              var result = "", cycle;
              for (cycle = 0; cycle < count; cycle += 1) {
                result += string;
              }
              return result;
            }
            function isNegativeZero(number) {
              return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
            }
            module2.exports.isNothing = isNothing;
            module2.exports.isObject = isObject;
            module2.exports.toArray = toArray;
            module2.exports.repeat = repeat;
            module2.exports.isNegativeZero = isNegativeZero;
            module2.exports.extend = extend;
          },
          8932: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var common = __webpack_require__2(9249);
            var YAMLException = __webpack_require__2(1833);
            var DEFAULT_SCHEMA = __webpack_require__2(7345);
            var _toString = Object.prototype.toString;
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var CHAR_BOM = 65279;
            var CHAR_TAB = 9;
            var CHAR_LINE_FEED = 10;
            var CHAR_CARRIAGE_RETURN = 13;
            var CHAR_SPACE = 32;
            var CHAR_EXCLAMATION = 33;
            var CHAR_DOUBLE_QUOTE = 34;
            var CHAR_SHARP = 35;
            var CHAR_PERCENT = 37;
            var CHAR_AMPERSAND = 38;
            var CHAR_SINGLE_QUOTE = 39;
            var CHAR_ASTERISK = 42;
            var CHAR_COMMA = 44;
            var CHAR_MINUS = 45;
            var CHAR_COLON = 58;
            var CHAR_EQUALS = 61;
            var CHAR_GREATER_THAN = 62;
            var CHAR_QUESTION = 63;
            var CHAR_COMMERCIAL_AT = 64;
            var CHAR_LEFT_SQUARE_BRACKET = 91;
            var CHAR_RIGHT_SQUARE_BRACKET = 93;
            var CHAR_GRAVE_ACCENT = 96;
            var CHAR_LEFT_CURLY_BRACKET = 123;
            var CHAR_VERTICAL_LINE = 124;
            var CHAR_RIGHT_CURLY_BRACKET = 125;
            var ESCAPE_SEQUENCES = {};
            ESCAPE_SEQUENCES[0] = "\\0";
            ESCAPE_SEQUENCES[7] = "\\a";
            ESCAPE_SEQUENCES[8] = "\\b";
            ESCAPE_SEQUENCES[9] = "\\t";
            ESCAPE_SEQUENCES[10] = "\\n";
            ESCAPE_SEQUENCES[11] = "\\v";
            ESCAPE_SEQUENCES[12] = "\\f";
            ESCAPE_SEQUENCES[13] = "\\r";
            ESCAPE_SEQUENCES[27] = "\\e";
            ESCAPE_SEQUENCES[34] = '\\"';
            ESCAPE_SEQUENCES[92] = "\\\\";
            ESCAPE_SEQUENCES[133] = "\\N";
            ESCAPE_SEQUENCES[160] = "\\_";
            ESCAPE_SEQUENCES[8232] = "\\L";
            ESCAPE_SEQUENCES[8233] = "\\P";
            var DEPRECATED_BOOLEANS_SYNTAX = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"];
            var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
            function compileStyleMap(schema, map) {
              var result, keys, index, length, tag, style, type;
              if (map === null)
                return {};
              result = {};
              keys = Object.keys(map);
              for (index = 0, length = keys.length; index < length; index += 1) {
                tag = keys[index];
                style = String(map[tag]);
                if (tag.slice(0, 2) === "!!") {
                  tag = "tag:yaml.org,2002:" + tag.slice(2);
                }
                type = schema.compiledTypeMap["fallback"][tag];
                if (type && _hasOwnProperty.call(type.styleAliases, style)) {
                  style = type.styleAliases[style];
                }
                result[tag] = style;
              }
              return result;
            }
            function encodeHex(character) {
              var string, handle, length;
              string = character.toString(16).toUpperCase();
              if (character <= 255) {
                handle = "x";
                length = 2;
              } else if (character <= 65535) {
                handle = "u";
                length = 4;
              } else if (character <= 4294967295) {
                handle = "U";
                length = 8;
              } else {
                throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
              }
              return "\\" + handle + common.repeat("0", length - string.length) + string;
            }
            var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
            function State(options2) {
              this.schema = options2["schema"] || DEFAULT_SCHEMA;
              this.indent = Math.max(1, options2["indent"] || 2);
              this.noArrayIndent = options2["noArrayIndent"] || false;
              this.skipInvalid = options2["skipInvalid"] || false;
              this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
              this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
              this.sortKeys = options2["sortKeys"] || false;
              this.lineWidth = options2["lineWidth"] || 80;
              this.noRefs = options2["noRefs"] || false;
              this.noCompatMode = options2["noCompatMode"] || false;
              this.condenseFlow = options2["condenseFlow"] || false;
              this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
              this.forceQuotes = options2["forceQuotes"] || false;
              this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
              this.implicitTypes = this.schema.compiledImplicit;
              this.explicitTypes = this.schema.compiledExplicit;
              this.tag = null;
              this.result = "";
              this.duplicates = [];
              this.usedDuplicates = null;
            }
            function indentString(string, spaces) {
              var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
              while (position < length) {
                next = string.indexOf("\n", position);
                if (next === -1) {
                  line = string.slice(position);
                  position = length;
                } else {
                  line = string.slice(position, next + 1);
                  position = next + 1;
                }
                if (line.length && line !== "\n")
                  result += ind;
                result += line;
              }
              return result;
            }
            function generateNextLine(state, level) {
              return "\n" + common.repeat(" ", state.indent * level);
            }
            function testImplicitResolving(state, str) {
              var index, length, type;
              for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
                type = state.implicitTypes[index];
                if (type.resolve(str)) {
                  return true;
                }
              }
              return false;
            }
            function isWhitespace(c) {
              return c === CHAR_SPACE || c === CHAR_TAB;
            }
            function isPrintable(c) {
              return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
            }
            function isNsCharOrWhitespace(c) {
              return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
            }
            function isPlainSafe(c, prev, inblock) {
              var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
              var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
              return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
            }
            function isPlainSafeFirst(c) {
              return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
            }
            function isPlainSafeLast(c) {
              return !isWhitespace(c) && c !== CHAR_COLON;
            }
            function codePointAt(string, pos) {
              var first = string.charCodeAt(pos), second;
              if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
                second = string.charCodeAt(pos + 1);
                if (second >= 56320 && second <= 57343) {
                  return (first - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return first;
            }
            function needIndentIndicator(string) {
              var leadingSpaceRe = /^\n* /;
              return leadingSpaceRe.test(string);
            }
            var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
            function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
              var i;
              var char = 0;
              var prevChar = null;
              var hasLineBreak = false;
              var hasFoldableLine = false;
              var shouldTrackWidth = lineWidth !== -1;
              var previousLineBreak = -1;
              var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
              if (singleLineOnly || forceQuotes) {
                for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
                  char = codePointAt(string, i);
                  if (!isPrintable(char)) {
                    return STYLE_DOUBLE;
                  }
                  plain = plain && isPlainSafe(char, prevChar, inblock);
                  prevChar = char;
                }
              } else {
                for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
                  char = codePointAt(string, i);
                  if (char === CHAR_LINE_FEED) {
                    hasLineBreak = true;
                    if (shouldTrackWidth) {
                      hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                      previousLineBreak = i;
                    }
                  } else if (!isPrintable(char)) {
                    return STYLE_DOUBLE;
                  }
                  plain = plain && isPlainSafe(char, prevChar, inblock);
                  prevChar = char;
                }
                hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              }
              if (!hasLineBreak && !hasFoldableLine) {
                if (plain && !forceQuotes && !testAmbiguousType(string)) {
                  return STYLE_PLAIN;
                }
                return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
              }
              if (indentPerLevel > 9 && needIndentIndicator(string)) {
                return STYLE_DOUBLE;
              }
              if (!forceQuotes) {
                return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
              }
              return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
            }
            function writeScalar(state, string, level, iskey, inblock) {
              state.dump = function() {
                if (string.length === 0) {
                  return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
                }
                if (!state.noCompatMode) {
                  if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
                    return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
                  }
                }
                var indent = state.indent * Math.max(1, level);
                var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
                var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
                function testAmbiguity(string2) {
                  return testImplicitResolving(state, string2);
                }
                switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
                  case STYLE_PLAIN:
                    return string;
                  case STYLE_SINGLE:
                    return "'" + string.replace(/'/g, "''") + "'";
                  case STYLE_LITERAL:
                    return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
                  case STYLE_FOLDED:
                    return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
                  case STYLE_DOUBLE:
                    return '"' + escapeString(string, lineWidth) + '"';
                  default:
                    throw new YAMLException("impossible error: invalid scalar style");
                }
              }();
            }
            function blockHeader(string, indentPerLevel) {
              var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
              var clip = string[string.length - 1] === "\n";
              var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
              var chomp = keep ? "+" : clip ? "" : "-";
              return indentIndicator + chomp + "\n";
            }
            function dropEndingNewline(string) {
              return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
            }
            function foldString(string, width) {
              var lineRe = /(\n+)([^\n]*)/g;
              var result = function() {
                var nextLF = string.indexOf("\n");
                nextLF = nextLF !== -1 ? nextLF : string.length;
                lineRe.lastIndex = nextLF;
                return foldLine(string.slice(0, nextLF), width);
              }();
              var prevMoreIndented = string[0] === "\n" || string[0] === " ";
              var moreIndented;
              var match;
              while (match = lineRe.exec(string)) {
                var prefix = match[1], line = match[2];
                moreIndented = line[0] === " ";
                result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
                prevMoreIndented = moreIndented;
              }
              return result;
            }
            function foldLine(line, width) {
              if (line === "" || line[0] === " ")
                return line;
              var breakRe = / [^ ]/g;
              var match;
              var start = 0, end, curr = 0, next = 0;
              var result = "";
              while (match = breakRe.exec(line)) {
                next = match.index;
                if (next - start > width) {
                  end = curr > start ? curr : next;
                  result += "\n" + line.slice(start, end);
                  start = end + 1;
                }
                curr = next;
              }
              result += "\n";
              if (line.length - start > width && curr > start) {
                result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
              } else {
                result += line.slice(start);
              }
              return result.slice(1);
            }
            function escapeString(string) {
              var result = "";
              var char = 0;
              var escapeSeq;
              for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
                char = codePointAt(string, i);
                escapeSeq = ESCAPE_SEQUENCES[char];
                if (!escapeSeq && isPrintable(char)) {
                  result += string[i];
                  if (char >= 65536)
                    result += string[i + 1];
                } else {
                  result += escapeSeq || encodeHex(char);
                }
              }
              return result;
            }
            function writeFlowSequence(state, level, object) {
              var _result = "", _tag = state.tag, index, length, value;
              for (index = 0, length = object.length; index < length; index += 1) {
                value = object[index];
                if (state.replacer) {
                  value = state.replacer.call(object, String(index), value);
                }
                if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
                  if (_result !== "")
                    _result += "," + (!state.condenseFlow ? " " : "");
                  _result += state.dump;
                }
              }
              state.tag = _tag;
              state.dump = "[" + _result + "]";
            }
            function writeBlockSequence(state, level, object, compact) {
              var _result = "", _tag = state.tag, index, length, value;
              for (index = 0, length = object.length; index < length; index += 1) {
                value = object[index];
                if (state.replacer) {
                  value = state.replacer.call(object, String(index), value);
                }
                if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
                  if (!compact || _result !== "") {
                    _result += generateNextLine(state, level);
                  }
                  if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                    _result += "-";
                  } else {
                    _result += "- ";
                  }
                  _result += state.dump;
                }
              }
              state.tag = _tag;
              state.dump = _result || "[]";
            }
            function writeFlowMapping(state, level, object) {
              var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                pairBuffer = "";
                if (_result !== "")
                  pairBuffer += ", ";
                if (state.condenseFlow)
                  pairBuffer += '"';
                objectKey = objectKeyList[index];
                objectValue = object[objectKey];
                if (state.replacer) {
                  objectValue = state.replacer.call(object, objectKey, objectValue);
                }
                if (!writeNode(state, level, objectKey, false, false)) {
                  continue;
                }
                if (state.dump.length > 1024)
                  pairBuffer += "? ";
                pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
                if (!writeNode(state, level, objectValue, false, false)) {
                  continue;
                }
                pairBuffer += state.dump;
                _result += pairBuffer;
              }
              state.tag = _tag;
              state.dump = "{" + _result + "}";
            }
            function writeBlockMapping(state, level, object, compact) {
              var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
              if (state.sortKeys === true) {
                objectKeyList.sort();
              } else if (typeof state.sortKeys === "function") {
                objectKeyList.sort(state.sortKeys);
              } else if (state.sortKeys) {
                throw new YAMLException("sortKeys must be a boolean or a function");
              }
              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                pairBuffer = "";
                if (!compact || _result !== "") {
                  pairBuffer += generateNextLine(state, level);
                }
                objectKey = objectKeyList[index];
                objectValue = object[objectKey];
                if (state.replacer) {
                  objectValue = state.replacer.call(object, objectKey, objectValue);
                }
                if (!writeNode(state, level + 1, objectKey, true, true, true)) {
                  continue;
                }
                explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
                if (explicitPair) {
                  if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                    pairBuffer += "?";
                  } else {
                    pairBuffer += "? ";
                  }
                }
                pairBuffer += state.dump;
                if (explicitPair) {
                  pairBuffer += generateNextLine(state, level);
                }
                if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                  continue;
                }
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  pairBuffer += ":";
                } else {
                  pairBuffer += ": ";
                }
                pairBuffer += state.dump;
                _result += pairBuffer;
              }
              state.tag = _tag;
              state.dump = _result || "{}";
            }
            function detectType(state, object, explicit) {
              var _result, typeList, index, length, type, style;
              typeList = explicit ? state.explicitTypes : state.implicitTypes;
              for (index = 0, length = typeList.length; index < length; index += 1) {
                type = typeList[index];
                if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
                  if (explicit) {
                    if (type.multi && type.representName) {
                      state.tag = type.representName(object);
                    } else {
                      state.tag = type.tag;
                    }
                  } else {
                    state.tag = "?";
                  }
                  if (type.represent) {
                    style = state.styleMap[type.tag] || type.defaultStyle;
                    if (_toString.call(type.represent) === "[object Function]") {
                      _result = type.represent(object, style);
                    } else if (_hasOwnProperty.call(type.represent, style)) {
                      _result = type.represent[style](object, style);
                    } else {
                      throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                    }
                    state.dump = _result;
                  }
                  return true;
                }
              }
              return false;
            }
            function writeNode(state, level, object, block2, compact, iskey, isblockseq) {
              state.tag = null;
              state.dump = object;
              if (!detectType(state, object, false)) {
                detectType(state, object, true);
              }
              var type = _toString.call(state.dump);
              var inblock = block2;
              var tagStr;
              if (block2) {
                block2 = state.flowLevel < 0 || state.flowLevel > level;
              }
              var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
              if (objectOrArray) {
                duplicateIndex = state.duplicates.indexOf(object);
                duplicate = duplicateIndex !== -1;
              }
              if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
                compact = false;
              }
              if (duplicate && state.usedDuplicates[duplicateIndex]) {
                state.dump = "*ref_" + duplicateIndex;
              } else {
                if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
                  state.usedDuplicates[duplicateIndex] = true;
                }
                if (type === "[object Object]") {
                  if (block2 && Object.keys(state.dump).length !== 0) {
                    writeBlockMapping(state, level, state.dump, compact);
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + state.dump;
                    }
                  } else {
                    writeFlowMapping(state, level, state.dump);
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                    }
                  }
                } else if (type === "[object Array]") {
                  if (block2 && state.dump.length !== 0) {
                    if (state.noArrayIndent && !isblockseq && level > 0) {
                      writeBlockSequence(state, level - 1, state.dump, compact);
                    } else {
                      writeBlockSequence(state, level, state.dump, compact);
                    }
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + state.dump;
                    }
                  } else {
                    writeFlowSequence(state, level, state.dump);
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                    }
                  }
                } else if (type === "[object String]") {
                  if (state.tag !== "?") {
                    writeScalar(state, state.dump, level, iskey, inblock);
                  }
                } else if (type === "[object Undefined]") {
                  return false;
                } else {
                  if (state.skipInvalid)
                    return false;
                  throw new YAMLException("unacceptable kind of an object to dump " + type);
                }
                if (state.tag !== null && state.tag !== "?") {
                  tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
                  if (state.tag[0] === "!") {
                    tagStr = "!" + tagStr;
                  } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
                    tagStr = "!!" + tagStr.slice(18);
                  } else {
                    tagStr = "!<" + tagStr + ">";
                  }
                  state.dump = tagStr + " " + state.dump;
                }
              }
              return true;
            }
            function getDuplicateReferences(object, state) {
              var objects = [], duplicatesIndexes = [], index, length;
              inspectNode(object, objects, duplicatesIndexes);
              for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
                state.duplicates.push(objects[duplicatesIndexes[index]]);
              }
              state.usedDuplicates = new Array(length);
            }
            function inspectNode(object, objects, duplicatesIndexes) {
              var objectKeyList, index, length;
              if (object !== null && typeof object === "object") {
                index = objects.indexOf(object);
                if (index !== -1) {
                  if (duplicatesIndexes.indexOf(index) === -1) {
                    duplicatesIndexes.push(index);
                  }
                } else {
                  objects.push(object);
                  if (Array.isArray(object)) {
                    for (index = 0, length = object.length; index < length; index += 1) {
                      inspectNode(object[index], objects, duplicatesIndexes);
                    }
                  } else {
                    objectKeyList = Object.keys(object);
                    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                      inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                    }
                  }
                }
              }
            }
            function dump(input, options2) {
              options2 = options2 || {};
              var state = new State(options2);
              if (!state.noRefs)
                getDuplicateReferences(input, state);
              var value = input;
              if (state.replacer) {
                value = state.replacer.call({
                  "": value
                }, "", value);
              }
              if (writeNode(state, 0, value, true, true))
                return state.dump + "\n";
              return "";
            }
            module2.exports.dump = dump;
          },
          1833: (module2) => {
            "use strict";
            function formatError(exception, compact) {
              var where = "", message = exception.reason || "(unknown reason)";
              if (!exception.mark)
                return message;
              if (exception.mark.name) {
                where += 'in "' + exception.mark.name + '" ';
              }
              where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
              if (!compact && exception.mark.snippet) {
                where += "\n\n" + exception.mark.snippet;
              }
              return message + " " + where;
            }
            function YAMLException(reason, mark) {
              Error.call(this);
              this.name = "YAMLException";
              this.reason = reason;
              this.mark = mark;
              this.message = formatError(this, false);
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              } else {
                this.stack = new Error().stack || "";
              }
            }
            YAMLException.prototype = Object.create(Error.prototype);
            YAMLException.prototype.constructor = YAMLException;
            YAMLException.prototype.toString = function toString(compact) {
              return this.name + ": " + formatError(this, compact);
            };
            module2.exports = YAMLException;
          },
          7501: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var common = __webpack_require__2(9249);
            var YAMLException = __webpack_require__2(1833);
            var makeSnippet = __webpack_require__2(3920);
            var DEFAULT_SCHEMA = __webpack_require__2(7345);
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var CONTEXT_FLOW_IN = 1;
            var CONTEXT_FLOW_OUT = 2;
            var CONTEXT_BLOCK_IN = 3;
            var CONTEXT_BLOCK_OUT = 4;
            var CHOMPING_CLIP = 1;
            var CHOMPING_STRIP = 2;
            var CHOMPING_KEEP = 3;
            var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
            var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
            var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
            var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
            function _class(obj) {
              return Object.prototype.toString.call(obj);
            }
            function is_EOL(c) {
              return c === 10 || c === 13;
            }
            function is_WHITE_SPACE(c) {
              return c === 9 || c === 32;
            }
            function is_WS_OR_EOL(c) {
              return c === 9 || c === 32 || c === 10 || c === 13;
            }
            function is_FLOW_INDICATOR(c) {
              return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
            }
            function fromHexCode(c) {
              var lc;
              if (48 <= c && c <= 57) {
                return c - 48;
              }
              lc = c | 32;
              if (97 <= lc && lc <= 102) {
                return lc - 97 + 10;
              }
              return -1;
            }
            function escapedHexLen(c) {
              if (c === 120) {
                return 2;
              }
              if (c === 117) {
                return 4;
              }
              if (c === 85) {
                return 8;
              }
              return 0;
            }
            function fromDecimalCode(c) {
              if (48 <= c && c <= 57) {
                return c - 48;
              }
              return -1;
            }
            function simpleEscapeSequence(c) {
              return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
            }
            function charFromCodepoint(c) {
              if (c <= 65535) {
                return String.fromCharCode(c);
              }
              return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
            }
            var simpleEscapeCheck = new Array(256);
            var simpleEscapeMap = new Array(256);
            for (var i = 0; i < 256; i++) {
              simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
              simpleEscapeMap[i] = simpleEscapeSequence(i);
            }
            function State(input, options2) {
              this.input = input;
              this.filename = options2["filename"] || null;
              this.schema = options2["schema"] || DEFAULT_SCHEMA;
              this.onWarning = options2["onWarning"] || null;
              this.legacy = options2["legacy"] || false;
              this.json = options2["json"] || false;
              this.listener = options2["listener"] || null;
              this.implicitTypes = this.schema.compiledImplicit;
              this.typeMap = this.schema.compiledTypeMap;
              this.length = input.length;
              this.position = 0;
              this.line = 0;
              this.lineStart = 0;
              this.lineIndent = 0;
              this.firstTabInLine = -1;
              this.documents = [];
            }
            function generateError(state, message) {
              var mark = {
                name: state.filename,
                buffer: state.input.slice(0, -1),
                position: state.position,
                line: state.line,
                column: state.position - state.lineStart
              };
              mark.snippet = makeSnippet(mark);
              return new YAMLException(message, mark);
            }
            function throwError(state, message) {
              throw generateError(state, message);
            }
            function throwWarning(state, message) {
              if (state.onWarning) {
                state.onWarning.call(null, generateError(state, message));
              }
            }
            var directiveHandlers = {
              YAML: function handleYamlDirective(state, name, args) {
                var match, major, minor;
                if (state.version !== null) {
                  throwError(state, "duplication of %YAML directive");
                }
                if (args.length !== 1) {
                  throwError(state, "YAML directive accepts exactly one argument");
                }
                match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
                if (match === null) {
                  throwError(state, "ill-formed argument of the YAML directive");
                }
                major = parseInt(match[1], 10);
                minor = parseInt(match[2], 10);
                if (major !== 1) {
                  throwError(state, "unacceptable YAML version of the document");
                }
                state.version = args[0];
                state.checkLineBreaks = minor < 2;
                if (minor !== 1 && minor !== 2) {
                  throwWarning(state, "unsupported YAML version of the document");
                }
              },
              TAG: function handleTagDirective(state, name, args) {
                var handle, prefix;
                if (args.length !== 2) {
                  throwError(state, "TAG directive accepts exactly two arguments");
                }
                handle = args[0];
                prefix = args[1];
                if (!PATTERN_TAG_HANDLE.test(handle)) {
                  throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
                }
                if (_hasOwnProperty.call(state.tagMap, handle)) {
                  throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
                }
                if (!PATTERN_TAG_URI.test(prefix)) {
                  throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
                }
                try {
                  prefix = decodeURIComponent(prefix);
                } catch (err) {
                  throwError(state, "tag prefix is malformed: " + prefix);
                }
                state.tagMap[handle] = prefix;
              }
            };
            function captureSegment(state, start, end, checkJson) {
              var _position, _length, _character, _result;
              if (start < end) {
                _result = state.input.slice(start, end);
                if (checkJson) {
                  for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                    _character = _result.charCodeAt(_position);
                    if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                      throwError(state, "expected valid JSON character");
                    }
                  }
                } else if (PATTERN_NON_PRINTABLE.test(_result)) {
                  throwError(state, "the stream contains non-printable characters");
                }
                state.result += _result;
              }
            }
            function mergeMappings(state, destination, source, overridableKeys) {
              var sourceKeys, key, index, quantity;
              if (!common.isObject(source)) {
                throwError(state, "cannot merge mappings; the provided source object is unacceptable");
              }
              sourceKeys = Object.keys(source);
              for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
                key = sourceKeys[index];
                if (!_hasOwnProperty.call(destination, key)) {
                  destination[key] = source[key];
                  overridableKeys[key] = true;
                }
              }
            }
            function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
              var index, quantity;
              if (Array.isArray(keyNode)) {
                keyNode = Array.prototype.slice.call(keyNode);
                for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
                  if (Array.isArray(keyNode[index])) {
                    throwError(state, "nested arrays are not supported inside keys");
                  }
                  if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                    keyNode[index] = "[object Object]";
                  }
                }
              }
              if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
                keyNode = "[object Object]";
              }
              keyNode = String(keyNode);
              if (_result === null) {
                _result = {};
              }
              if (keyTag === "tag:yaml.org,2002:merge") {
                if (Array.isArray(valueNode)) {
                  for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                    mergeMappings(state, _result, valueNode[index], overridableKeys);
                  }
                } else {
                  mergeMappings(state, _result, valueNode, overridableKeys);
                }
              } else {
                if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
                  state.line = startLine || state.line;
                  state.lineStart = startLineStart || state.lineStart;
                  state.position = startPos || state.position;
                  throwError(state, "duplicated mapping key");
                }
                if (keyNode === "__proto__") {
                  Object.defineProperty(_result, keyNode, {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: valueNode
                  });
                } else {
                  _result[keyNode] = valueNode;
                }
                delete overridableKeys[keyNode];
              }
              return _result;
            }
            function readLineBreak(state) {
              var ch;
              ch = state.input.charCodeAt(state.position);
              if (ch === 10) {
                state.position++;
              } else if (ch === 13) {
                state.position++;
                if (state.input.charCodeAt(state.position) === 10) {
                  state.position++;
                }
              } else {
                throwError(state, "a line break is expected");
              }
              state.line += 1;
              state.lineStart = state.position;
              state.firstTabInLine = -1;
            }
            function skipSeparationSpace(state, allowComments, checkIndent) {
              var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
              while (ch !== 0) {
                while (is_WHITE_SPACE(ch)) {
                  if (ch === 9 && state.firstTabInLine === -1) {
                    state.firstTabInLine = state.position;
                  }
                  ch = state.input.charCodeAt(++state.position);
                }
                if (allowComments && ch === 35) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (ch !== 10 && ch !== 13 && ch !== 0);
                }
                if (is_EOL(ch)) {
                  readLineBreak(state);
                  ch = state.input.charCodeAt(state.position);
                  lineBreaks++;
                  state.lineIndent = 0;
                  while (ch === 32) {
                    state.lineIndent++;
                    ch = state.input.charCodeAt(++state.position);
                  }
                } else {
                  break;
                }
              }
              if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
                throwWarning(state, "deficient indentation");
              }
              return lineBreaks;
            }
            function testDocumentSeparator(state) {
              var _position = state.position, ch;
              ch = state.input.charCodeAt(_position);
              if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
                _position += 3;
                ch = state.input.charCodeAt(_position);
                if (ch === 0 || is_WS_OR_EOL(ch)) {
                  return true;
                }
              }
              return false;
            }
            function writeFoldedLines(state, count) {
              if (count === 1) {
                state.result += " ";
              } else if (count > 1) {
                state.result += common.repeat("\n", count - 1);
              }
            }
            function readPlainScalar(state, nodeIndent, withinFlowCollection) {
              var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
              ch = state.input.charCodeAt(state.position);
              if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
                return false;
              }
              if (ch === 63 || ch === 45) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                  return false;
                }
              }
              state.kind = "scalar";
              state.result = "";
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
              while (ch !== 0) {
                if (ch === 58) {
                  following = state.input.charCodeAt(state.position + 1);
                  if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                    break;
                  }
                } else if (ch === 35) {
                  preceding = state.input.charCodeAt(state.position - 1);
                  if (is_WS_OR_EOL(preceding)) {
                    break;
                  }
                } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
                  break;
                } else if (is_EOL(ch)) {
                  _line = state.line;
                  _lineStart = state.lineStart;
                  _lineIndent = state.lineIndent;
                  skipSeparationSpace(state, false, -1);
                  if (state.lineIndent >= nodeIndent) {
                    hasPendingContent = true;
                    ch = state.input.charCodeAt(state.position);
                    continue;
                  } else {
                    state.position = captureEnd;
                    state.line = _line;
                    state.lineStart = _lineStart;
                    state.lineIndent = _lineIndent;
                    break;
                  }
                }
                if (hasPendingContent) {
                  captureSegment(state, captureStart, captureEnd, false);
                  writeFoldedLines(state, state.line - _line);
                  captureStart = captureEnd = state.position;
                  hasPendingContent = false;
                }
                if (!is_WHITE_SPACE(ch)) {
                  captureEnd = state.position + 1;
                }
                ch = state.input.charCodeAt(++state.position);
              }
              captureSegment(state, captureStart, captureEnd, false);
              if (state.result) {
                return true;
              }
              state.kind = _kind;
              state.result = _result;
              return false;
            }
            function readSingleQuotedScalar(state, nodeIndent) {
              var ch, captureStart, captureEnd;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 39) {
                return false;
              }
              state.kind = "scalar";
              state.result = "";
              state.position++;
              captureStart = captureEnd = state.position;
              while ((ch = state.input.charCodeAt(state.position)) !== 0) {
                if (ch === 39) {
                  captureSegment(state, captureStart, state.position, true);
                  ch = state.input.charCodeAt(++state.position);
                  if (ch === 39) {
                    captureStart = state.position;
                    state.position++;
                    captureEnd = state.position;
                  } else {
                    return true;
                  }
                } else if (is_EOL(ch)) {
                  captureSegment(state, captureStart, captureEnd, true);
                  writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                  captureStart = captureEnd = state.position;
                } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                  throwError(state, "unexpected end of the document within a single quoted scalar");
                } else {
                  state.position++;
                  captureEnd = state.position;
                }
              }
              throwError(state, "unexpected end of the stream within a single quoted scalar");
            }
            function readDoubleQuotedScalar(state, nodeIndent) {
              var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 34) {
                return false;
              }
              state.kind = "scalar";
              state.result = "";
              state.position++;
              captureStart = captureEnd = state.position;
              while ((ch = state.input.charCodeAt(state.position)) !== 0) {
                if (ch === 34) {
                  captureSegment(state, captureStart, state.position, true);
                  state.position++;
                  return true;
                } else if (ch === 92) {
                  captureSegment(state, captureStart, state.position, true);
                  ch = state.input.charCodeAt(++state.position);
                  if (is_EOL(ch)) {
                    skipSeparationSpace(state, false, nodeIndent);
                  } else if (ch < 256 && simpleEscapeCheck[ch]) {
                    state.result += simpleEscapeMap[ch];
                    state.position++;
                  } else if ((tmp = escapedHexLen(ch)) > 0) {
                    hexLength = tmp;
                    hexResult = 0;
                    for (; hexLength > 0; hexLength--) {
                      ch = state.input.charCodeAt(++state.position);
                      if ((tmp = fromHexCode(ch)) >= 0) {
                        hexResult = (hexResult << 4) + tmp;
                      } else {
                        throwError(state, "expected hexadecimal character");
                      }
                    }
                    state.result += charFromCodepoint(hexResult);
                    state.position++;
                  } else {
                    throwError(state, "unknown escape sequence");
                  }
                  captureStart = captureEnd = state.position;
                } else if (is_EOL(ch)) {
                  captureSegment(state, captureStart, captureEnd, true);
                  writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                  captureStart = captureEnd = state.position;
                } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                  throwError(state, "unexpected end of the document within a double quoted scalar");
                } else {
                  state.position++;
                  captureEnd = state.position;
                }
              }
              throwError(state, "unexpected end of the stream within a double quoted scalar");
            }
            function readFlowCollection(state, nodeIndent) {
              var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch === 91) {
                terminator = 93;
                isMapping = false;
                _result = [];
              } else if (ch === 123) {
                terminator = 125;
                isMapping = true;
                _result = {};
              } else {
                return false;
              }
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = _result;
              }
              ch = state.input.charCodeAt(++state.position);
              while (ch !== 0) {
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if (ch === terminator) {
                  state.position++;
                  state.tag = _tag;
                  state.anchor = _anchor;
                  state.kind = isMapping ? "mapping" : "sequence";
                  state.result = _result;
                  return true;
                } else if (!readNext) {
                  throwError(state, "missed comma between flow collection entries");
                } else if (ch === 44) {
                  throwError(state, "expected the node content, but found ','");
                }
                keyTag = keyNode = valueNode = null;
                isPair = isExplicitPair = false;
                if (ch === 63) {
                  following = state.input.charCodeAt(state.position + 1);
                  if (is_WS_OR_EOL(following)) {
                    isPair = isExplicitPair = true;
                    state.position++;
                    skipSeparationSpace(state, true, nodeIndent);
                  }
                }
                _line = state.line;
                _lineStart = state.lineStart;
                _pos = state.position;
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                keyTag = state.tag;
                keyNode = state.result;
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if ((isExplicitPair || state.line === _line) && ch === 58) {
                  isPair = true;
                  ch = state.input.charCodeAt(++state.position);
                  skipSeparationSpace(state, true, nodeIndent);
                  composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                  valueNode = state.result;
                }
                if (isMapping) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
                } else if (isPair) {
                  _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
                } else {
                  _result.push(keyNode);
                }
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if (ch === 44) {
                  readNext = true;
                  ch = state.input.charCodeAt(++state.position);
                } else {
                  readNext = false;
                }
              }
              throwError(state, "unexpected end of the stream within a flow collection");
            }
            function readBlockScalar(state, nodeIndent) {
              var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch === 124) {
                folding = false;
              } else if (ch === 62) {
                folding = true;
              } else {
                return false;
              }
              state.kind = "scalar";
              state.result = "";
              while (ch !== 0) {
                ch = state.input.charCodeAt(++state.position);
                if (ch === 43 || ch === 45) {
                  if (CHOMPING_CLIP === chomping) {
                    chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
                  } else {
                    throwError(state, "repeat of a chomping mode identifier");
                  }
                } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                  if (tmp === 0) {
                    throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
                  } else if (!detectedIndent) {
                    textIndent = nodeIndent + tmp - 1;
                    detectedIndent = true;
                  } else {
                    throwError(state, "repeat of an indentation width identifier");
                  }
                } else {
                  break;
                }
              }
              if (is_WHITE_SPACE(ch)) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (is_WHITE_SPACE(ch));
                if (ch === 35) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (!is_EOL(ch) && ch !== 0);
                }
              }
              while (ch !== 0) {
                readLineBreak(state);
                state.lineIndent = 0;
                ch = state.input.charCodeAt(state.position);
                while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
                  state.lineIndent++;
                  ch = state.input.charCodeAt(++state.position);
                }
                if (!detectedIndent && state.lineIndent > textIndent) {
                  textIndent = state.lineIndent;
                }
                if (is_EOL(ch)) {
                  emptyLines++;
                  continue;
                }
                if (state.lineIndent < textIndent) {
                  if (chomping === CHOMPING_KEEP) {
                    state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                  } else if (chomping === CHOMPING_CLIP) {
                    if (didReadContent) {
                      state.result += "\n";
                    }
                  }
                  break;
                }
                if (folding) {
                  if (is_WHITE_SPACE(ch)) {
                    atMoreIndented = true;
                    state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                  } else if (atMoreIndented) {
                    atMoreIndented = false;
                    state.result += common.repeat("\n", emptyLines + 1);
                  } else if (emptyLines === 0) {
                    if (didReadContent) {
                      state.result += " ";
                    }
                  } else {
                    state.result += common.repeat("\n", emptyLines);
                  }
                } else {
                  state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                }
                didReadContent = true;
                detectedIndent = true;
                emptyLines = 0;
                captureStart = state.position;
                while (!is_EOL(ch) && ch !== 0) {
                  ch = state.input.charCodeAt(++state.position);
                }
                captureSegment(state, captureStart, state.position, false);
              }
              return true;
            }
            function readBlockSequence(state, nodeIndent) {
              var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
              if (state.firstTabInLine !== -1)
                return false;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = _result;
              }
              ch = state.input.charCodeAt(state.position);
              while (ch !== 0) {
                if (state.firstTabInLine !== -1) {
                  state.position = state.firstTabInLine;
                  throwError(state, "tab characters must not be used in indentation");
                }
                if (ch !== 45) {
                  break;
                }
                following = state.input.charCodeAt(state.position + 1);
                if (!is_WS_OR_EOL(following)) {
                  break;
                }
                detected = true;
                state.position++;
                if (skipSeparationSpace(state, true, -1)) {
                  if (state.lineIndent <= nodeIndent) {
                    _result.push(null);
                    ch = state.input.charCodeAt(state.position);
                    continue;
                  }
                }
                _line = state.line;
                composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
                _result.push(state.result);
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
                if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
                  throwError(state, "bad indentation of a sequence entry");
                } else if (state.lineIndent < nodeIndent) {
                  break;
                }
              }
              if (detected) {
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = "sequence";
                state.result = _result;
                return true;
              }
              return false;
            }
            function readBlockMapping(state, nodeIndent, flowIndent) {
              var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
              if (state.firstTabInLine !== -1)
                return false;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = _result;
              }
              ch = state.input.charCodeAt(state.position);
              while (ch !== 0) {
                if (!atExplicitKey && state.firstTabInLine !== -1) {
                  state.position = state.firstTabInLine;
                  throwError(state, "tab characters must not be used in indentation");
                }
                following = state.input.charCodeAt(state.position + 1);
                _line = state.line;
                if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
                  if (ch === 63) {
                    if (atExplicitKey) {
                      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = true;
                    allowCompact = true;
                  } else if (atExplicitKey) {
                    atExplicitKey = false;
                    allowCompact = true;
                  } else {
                    throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
                  }
                  state.position += 1;
                  ch = following;
                } else {
                  _keyLine = state.line;
                  _keyLineStart = state.lineStart;
                  _keyPos = state.position;
                  if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
                    break;
                  }
                  if (state.line === _line) {
                    ch = state.input.charCodeAt(state.position);
                    while (is_WHITE_SPACE(ch)) {
                      ch = state.input.charCodeAt(++state.position);
                    }
                    if (ch === 58) {
                      ch = state.input.charCodeAt(++state.position);
                      if (!is_WS_OR_EOL(ch)) {
                        throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                      }
                      if (atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                        keyTag = keyNode = valueNode = null;
                      }
                      detected = true;
                      atExplicitKey = false;
                      allowCompact = false;
                      keyTag = state.tag;
                      keyNode = state.result;
                    } else if (detected) {
                      throwError(state, "can not read an implicit mapping pair; a colon is missed");
                    } else {
                      state.tag = _tag;
                      state.anchor = _anchor;
                      return true;
                    }
                  } else if (detected) {
                    throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
                  } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true;
                  }
                }
                if (state.line === _line || state.lineIndent > nodeIndent) {
                  if (atExplicitKey) {
                    _keyLine = state.line;
                    _keyLineStart = state.lineStart;
                    _keyPos = state.position;
                  }
                  if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                    if (atExplicitKey) {
                      keyNode = state.result;
                    } else {
                      valueNode = state.result;
                    }
                  }
                  if (!atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
                    keyTag = keyNode = valueNode = null;
                  }
                  skipSeparationSpace(state, true, -1);
                  ch = state.input.charCodeAt(state.position);
                }
                if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
                  throwError(state, "bad indentation of a mapping entry");
                } else if (state.lineIndent < nodeIndent) {
                  break;
                }
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              }
              if (detected) {
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = "mapping";
                state.result = _result;
              }
              return detected;
            }
            function readTagProperty(state) {
              var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 33)
                return false;
              if (state.tag !== null) {
                throwError(state, "duplication of a tag property");
              }
              ch = state.input.charCodeAt(++state.position);
              if (ch === 60) {
                isVerbatim = true;
                ch = state.input.charCodeAt(++state.position);
              } else if (ch === 33) {
                isNamed = true;
                tagHandle = "!!";
                ch = state.input.charCodeAt(++state.position);
              } else {
                tagHandle = "!";
              }
              _position = state.position;
              if (isVerbatim) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && ch !== 62);
                if (state.position < state.length) {
                  tagName = state.input.slice(_position, state.position);
                  ch = state.input.charCodeAt(++state.position);
                } else {
                  throwError(state, "unexpected end of the stream within a verbatim tag");
                }
              } else {
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  if (ch === 33) {
                    if (!isNamed) {
                      tagHandle = state.input.slice(_position - 1, state.position + 1);
                      if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                        throwError(state, "named tag handle cannot contain such characters");
                      }
                      isNamed = true;
                      _position = state.position + 1;
                    } else {
                      throwError(state, "tag suffix cannot contain exclamation marks");
                    }
                  }
                  ch = state.input.charCodeAt(++state.position);
                }
                tagName = state.input.slice(_position, state.position);
                if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                  throwError(state, "tag suffix cannot contain flow indicator characters");
                }
              }
              if (tagName && !PATTERN_TAG_URI.test(tagName)) {
                throwError(state, "tag name cannot contain such characters: " + tagName);
              }
              try {
                tagName = decodeURIComponent(tagName);
              } catch (err) {
                throwError(state, "tag name is malformed: " + tagName);
              }
              if (isVerbatim) {
                state.tag = tagName;
              } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
                state.tag = state.tagMap[tagHandle] + tagName;
              } else if (tagHandle === "!") {
                state.tag = "!" + tagName;
              } else if (tagHandle === "!!") {
                state.tag = "tag:yaml.org,2002:" + tagName;
              } else {
                throwError(state, 'undeclared tag handle "' + tagHandle + '"');
              }
              return true;
            }
            function readAnchorProperty(state) {
              var _position, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 38)
                return false;
              if (state.anchor !== null) {
                throwError(state, "duplication of an anchor property");
              }
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (state.position === _position) {
                throwError(state, "name of an anchor node must contain at least one character");
              }
              state.anchor = state.input.slice(_position, state.position);
              return true;
            }
            function readAlias(state) {
              var _position, alias, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 42)
                return false;
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (state.position === _position) {
                throwError(state, "name of an alias node must contain at least one character");
              }
              alias = state.input.slice(_position, state.position);
              if (!_hasOwnProperty.call(state.anchorMap, alias)) {
                throwError(state, 'unidentified alias "' + alias + '"');
              }
              state.result = state.anchorMap[alias];
              skipSeparationSpace(state, true, -1);
              return true;
            }
            function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
              var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
              if (state.listener !== null) {
                state.listener("open", state);
              }
              state.tag = null;
              state.anchor = null;
              state.kind = null;
              state.result = null;
              allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
              if (allowToSeek) {
                if (skipSeparationSpace(state, true, -1)) {
                  atNewLine = true;
                  if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                  } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                  } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                  }
                }
              }
              if (indentStatus === 1) {
                while (readTagProperty(state) || readAnchorProperty(state)) {
                  if (skipSeparationSpace(state, true, -1)) {
                    atNewLine = true;
                    allowBlockCollections = allowBlockStyles;
                    if (state.lineIndent > parentIndent) {
                      indentStatus = 1;
                    } else if (state.lineIndent === parentIndent) {
                      indentStatus = 0;
                    } else if (state.lineIndent < parentIndent) {
                      indentStatus = -1;
                    }
                  } else {
                    allowBlockCollections = false;
                  }
                }
              }
              if (allowBlockCollections) {
                allowBlockCollections = atNewLine || allowCompact;
              }
              if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
                if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
                  flowIndent = parentIndent;
                } else {
                  flowIndent = parentIndent + 1;
                }
                blockIndent = state.position - state.lineStart;
                if (indentStatus === 1) {
                  if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                    hasContent = true;
                  } else {
                    if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                      hasContent = true;
                    } else if (readAlias(state)) {
                      hasContent = true;
                      if (state.tag !== null || state.anchor !== null) {
                        throwError(state, "alias node should not have any properties");
                      }
                    } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                      hasContent = true;
                      if (state.tag === null) {
                        state.tag = "?";
                      }
                    }
                    if (state.anchor !== null) {
                      state.anchorMap[state.anchor] = state.result;
                    }
                  }
                } else if (indentStatus === 0) {
                  hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
                }
              }
              if (state.tag === null) {
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              } else if (state.tag === "?") {
                if (state.result !== null && state.kind !== "scalar") {
                  throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
                }
                for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                  type = state.implicitTypes[typeIndex];
                  if (type.resolve(state.result)) {
                    state.result = type.construct(state.result);
                    state.tag = type.tag;
                    if (state.anchor !== null) {
                      state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                  }
                }
              } else if (state.tag !== "!") {
                if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
                  type = state.typeMap[state.kind || "fallback"][state.tag];
                } else {
                  type = null;
                  typeList = state.typeMap.multi[state.kind || "fallback"];
                  for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
                    if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                      type = typeList[typeIndex];
                      break;
                    }
                  }
                }
                if (!type) {
                  throwError(state, "unknown tag !<" + state.tag + ">");
                }
                if (state.result !== null && type.kind !== state.kind) {
                  throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
                }
                if (!type.resolve(state.result, state.tag)) {
                  throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
                } else {
                  state.result = type.construct(state.result, state.tag);
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              }
              if (state.listener !== null) {
                state.listener("close", state);
              }
              return state.tag !== null || state.anchor !== null || hasContent;
            }
            function readDocument(state) {
              var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
              state.version = null;
              state.checkLineBreaks = state.legacy;
              state.tagMap = /* @__PURE__ */ Object.create(null);
              state.anchorMap = /* @__PURE__ */ Object.create(null);
              while ((ch = state.input.charCodeAt(state.position)) !== 0) {
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
                if (state.lineIndent > 0 || ch !== 37) {
                  break;
                }
                hasDirectives = true;
                ch = state.input.charCodeAt(++state.position);
                _position = state.position;
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                directiveName = state.input.slice(_position, state.position);
                directiveArgs = [];
                if (directiveName.length < 1) {
                  throwError(state, "directive name must not be less than one character in length");
                }
                while (ch !== 0) {
                  while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  if (ch === 35) {
                    do {
                      ch = state.input.charCodeAt(++state.position);
                    } while (ch !== 0 && !is_EOL(ch));
                    break;
                  }
                  if (is_EOL(ch))
                    break;
                  _position = state.position;
                  while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  directiveArgs.push(state.input.slice(_position, state.position));
                }
                if (ch !== 0)
                  readLineBreak(state);
                if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
                  directiveHandlers[directiveName](state, directiveName, directiveArgs);
                } else {
                  throwWarning(state, 'unknown document directive "' + directiveName + '"');
                }
              }
              skipSeparationSpace(state, true, -1);
              if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              } else if (hasDirectives) {
                throwError(state, "directives end mark is expected");
              }
              composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
              skipSeparationSpace(state, true, -1);
              if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
                throwWarning(state, "non-ASCII line breaks are interpreted as content");
              }
              state.documents.push(state.result);
              if (state.position === state.lineStart && testDocumentSeparator(state)) {
                if (state.input.charCodeAt(state.position) === 46) {
                  state.position += 3;
                  skipSeparationSpace(state, true, -1);
                }
                return;
              }
              if (state.position < state.length - 1) {
                throwError(state, "end of the stream or a document separator is expected");
              } else {
                return;
              }
            }
            function loadDocuments(input, options2) {
              input = String(input);
              options2 = options2 || {};
              if (input.length !== 0) {
                if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
                  input += "\n";
                }
                if (input.charCodeAt(0) === 65279) {
                  input = input.slice(1);
                }
              }
              var state = new State(input, options2);
              var nullpos = input.indexOf("\0");
              if (nullpos !== -1) {
                state.position = nullpos;
                throwError(state, "null byte is not allowed in input");
              }
              state.input += "\0";
              while (state.input.charCodeAt(state.position) === 32) {
                state.lineIndent += 1;
                state.position += 1;
              }
              while (state.position < state.length - 1) {
                readDocument(state);
              }
              return state.documents;
            }
            function loadAll(input, iterator, options2) {
              if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
                options2 = iterator;
                iterator = null;
              }
              var documents = loadDocuments(input, options2);
              if (typeof iterator !== "function") {
                return documents;
              }
              for (var index = 0, length = documents.length; index < length; index += 1) {
                iterator(documents[index]);
              }
            }
            function load(input, options2) {
              var documents = loadDocuments(input, options2);
              if (documents.length === 0) {
                return void 0;
              } else if (documents.length === 1) {
                return documents[0];
              }
              throw new YAMLException("expected a single document in the stream, but found more");
            }
            module2.exports.loadAll = loadAll;
            module2.exports.load = load;
          },
          9218: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var YAMLException = __webpack_require__2(1833);
            var Type = __webpack_require__2(2274);
            function compileList(schema, name) {
              var result = [];
              schema[name].forEach(function(currentType) {
                var newIndex = result.length;
                result.forEach(function(previousType, previousIndex) {
                  if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
                    newIndex = previousIndex;
                  }
                });
                result[newIndex] = currentType;
              });
              return result;
            }
            function compileMap() {
              var result = {
                scalar: {},
                sequence: {},
                mapping: {},
                fallback: {},
                multi: {
                  scalar: [],
                  sequence: [],
                  mapping: [],
                  fallback: []
                }
              }, index, length;
              function collectType(type) {
                if (type.multi) {
                  result.multi[type.kind].push(type);
                  result.multi["fallback"].push(type);
                } else {
                  result[type.kind][type.tag] = result["fallback"][type.tag] = type;
                }
              }
              for (index = 0, length = arguments.length; index < length; index += 1) {
                arguments[index].forEach(collectType);
              }
              return result;
            }
            function Schema(definition) {
              return this.extend(definition);
            }
            Schema.prototype.extend = function extend(definition) {
              var implicit = [];
              var explicit = [];
              if (definition instanceof Type) {
                explicit.push(definition);
              } else if (Array.isArray(definition)) {
                explicit = explicit.concat(definition);
              } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
                if (definition.implicit)
                  implicit = implicit.concat(definition.implicit);
                if (definition.explicit)
                  explicit = explicit.concat(definition.explicit);
              } else {
                throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
              }
              implicit.forEach(function(type) {
                if (!(type instanceof Type)) {
                  throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
                }
                if (type.loadKind && type.loadKind !== "scalar") {
                  throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
                }
                if (type.multi) {
                  throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
                }
              });
              explicit.forEach(function(type) {
                if (!(type instanceof Type)) {
                  throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
                }
              });
              var result = Object.create(Schema.prototype);
              result.implicit = (this.implicit || []).concat(implicit);
              result.explicit = (this.explicit || []).concat(explicit);
              result.compiledImplicit = compileList(result, "implicit");
              result.compiledExplicit = compileList(result, "explicit");
              result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
              return result;
            };
            module2.exports = Schema;
          },
          3189: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            module2.exports = __webpack_require__2(8198);
          },
          7345: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            module2.exports = __webpack_require__2(3189).extend({
              implicit: [__webpack_require__2(7692), __webpack_require__2(1570)],
              explicit: [__webpack_require__2(682), __webpack_require__2(9272), __webpack_require__2(3006), __webpack_require__2(8302)]
            });
          },
          3552: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Schema = __webpack_require__2(9218);
            module2.exports = new Schema({
              explicit: [__webpack_require__2(4035), __webpack_require__2(4566), __webpack_require__2(584)]
            });
          },
          8198: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            module2.exports = __webpack_require__2(3552).extend({
              implicit: [__webpack_require__2(3328), __webpack_require__2(2711), __webpack_require__2(3512), __webpack_require__2(6633)]
            });
          },
          3920: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var common = __webpack_require__2(9249);
            function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
              var head = "";
              var tail = "";
              var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
              if (position - lineStart > maxHalfLength) {
                head = " ... ";
                lineStart = position - maxHalfLength + head.length;
              }
              if (lineEnd - position > maxHalfLength) {
                tail = " ...";
                lineEnd = position + maxHalfLength - tail.length;
              }
              return {
                str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
                pos: position - lineStart + head.length
              };
            }
            function padStart(string, max) {
              return common.repeat(" ", max - string.length) + string;
            }
            function makeSnippet(mark, options2) {
              options2 = Object.create(options2 || null);
              if (!mark.buffer)
                return null;
              if (!options2.maxLength)
                options2.maxLength = 79;
              if (typeof options2.indent !== "number")
                options2.indent = 1;
              if (typeof options2.linesBefore !== "number")
                options2.linesBefore = 3;
              if (typeof options2.linesAfter !== "number")
                options2.linesAfter = 2;
              var re = /\r?\n|\r|\0/g;
              var lineStarts = [0];
              var lineEnds = [];
              var match;
              var foundLineNo = -1;
              while (match = re.exec(mark.buffer)) {
                lineEnds.push(match.index);
                lineStarts.push(match.index + match[0].length);
                if (mark.position <= match.index && foundLineNo < 0) {
                  foundLineNo = lineStarts.length - 2;
                }
              }
              if (foundLineNo < 0)
                foundLineNo = lineStarts.length - 1;
              var result = "", i, line;
              var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
              var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
              for (i = 1; i <= options2.linesBefore; i++) {
                if (foundLineNo - i < 0)
                  break;
                line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
                result = common.repeat(" ", options2.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
              }
              line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
              result += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
              result += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
              for (i = 1; i <= options2.linesAfter; i++) {
                if (foundLineNo + i >= lineEnds.length)
                  break;
                line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
                result += common.repeat(" ", options2.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
              }
              return result.replace(/\n$/, "");
            }
            module2.exports = makeSnippet;
          },
          2274: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var YAMLException = __webpack_require__2(1833);
            var TYPE_CONSTRUCTOR_OPTIONS = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"];
            var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
            function compileStyleAliases(map) {
              var result = {};
              if (map !== null) {
                Object.keys(map).forEach(function(style) {
                  map[style].forEach(function(alias) {
                    result[String(alias)] = style;
                  });
                });
              }
              return result;
            }
            function Type(tag, options2) {
              options2 = options2 || {};
              Object.keys(options2).forEach(function(name) {
                if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
                  throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
                }
              });
              this.options = options2;
              this.tag = tag;
              this.kind = options2["kind"] || null;
              this.resolve = options2["resolve"] || function() {
                return true;
              };
              this.construct = options2["construct"] || function(data) {
                return data;
              };
              this.instanceOf = options2["instanceOf"] || null;
              this.predicate = options2["predicate"] || null;
              this.represent = options2["represent"] || null;
              this.representName = options2["representName"] || null;
              this.defaultStyle = options2["defaultStyle"] || null;
              this.multi = options2["multi"] || false;
              this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
              if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
                throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
              }
            }
            module2.exports = Type;
          },
          682: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(9494);
            var Type = __webpack_require__2(2274);
            var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
            function resolveYamlBinary(data) {
              if (data === null)
                return false;
              var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
              for (idx = 0; idx < max; idx++) {
                code = map.indexOf(data.charAt(idx));
                if (code > 64)
                  continue;
                if (code < 0)
                  return false;
                bitlen += 6;
              }
              return bitlen % 8 === 0;
            }
            function constructYamlBinary(data) {
              var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
              for (idx = 0; idx < max; idx++) {
                if (idx % 4 === 0 && idx) {
                  result.push(bits >> 16 & 255);
                  result.push(bits >> 8 & 255);
                  result.push(bits & 255);
                }
                bits = bits << 6 | map.indexOf(input.charAt(idx));
              }
              tailbits = max % 4 * 6;
              if (tailbits === 0) {
                result.push(bits >> 16 & 255);
                result.push(bits >> 8 & 255);
                result.push(bits & 255);
              } else if (tailbits === 18) {
                result.push(bits >> 10 & 255);
                result.push(bits >> 2 & 255);
              } else if (tailbits === 12) {
                result.push(bits >> 4 & 255);
              }
              return new Uint8Array(result);
            }
            function representYamlBinary(object) {
              var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
              for (idx = 0; idx < max; idx++) {
                if (idx % 3 === 0 && idx) {
                  result += map[bits >> 18 & 63];
                  result += map[bits >> 12 & 63];
                  result += map[bits >> 6 & 63];
                  result += map[bits & 63];
                }
                bits = (bits << 8) + object[idx];
              }
              tail = max % 3;
              if (tail === 0) {
                result += map[bits >> 18 & 63];
                result += map[bits >> 12 & 63];
                result += map[bits >> 6 & 63];
                result += map[bits & 63];
              } else if (tail === 2) {
                result += map[bits >> 10 & 63];
                result += map[bits >> 4 & 63];
                result += map[bits << 2 & 63];
                result += map[64];
              } else if (tail === 1) {
                result += map[bits >> 2 & 63];
                result += map[bits << 4 & 63];
                result += map[64];
                result += map[64];
              }
              return result;
            }
            function isBinary(obj) {
              return Object.prototype.toString.call(obj) === "[object Uint8Array]";
            }
            module2.exports = new Type("tag:yaml.org,2002:binary", {
              kind: "scalar",
              resolve: resolveYamlBinary,
              construct: constructYamlBinary,
              predicate: isBinary,
              represent: representYamlBinary
            });
          },
          2711: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            function resolveYamlBoolean(data) {
              if (data === null)
                return false;
              var max = data.length;
              return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
            }
            function constructYamlBoolean(data) {
              return data === "true" || data === "True" || data === "TRUE";
            }
            function isBoolean(object) {
              return Object.prototype.toString.call(object) === "[object Boolean]";
            }
            module2.exports = new Type("tag:yaml.org,2002:bool", {
              kind: "scalar",
              resolve: resolveYamlBoolean,
              construct: constructYamlBoolean,
              predicate: isBoolean,
              represent: {
                lowercase: function(object) {
                  return object ? "true" : "false";
                },
                uppercase: function(object) {
                  return object ? "TRUE" : "FALSE";
                },
                camelcase: function(object) {
                  return object ? "True" : "False";
                }
              },
              defaultStyle: "lowercase"
            });
          },
          6633: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var common = __webpack_require__2(9249);
            var Type = __webpack_require__2(2274);
            var YAML_FLOAT_PATTERN = new RegExp(
              "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
            );
            function resolveYamlFloat(data) {
              if (data === null)
                return false;
              if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
                return false;
              }
              return true;
            }
            function constructYamlFloat(data) {
              var value, sign;
              value = data.replace(/_/g, "").toLowerCase();
              sign = value[0] === "-" ? -1 : 1;
              if ("+-".indexOf(value[0]) >= 0) {
                value = value.slice(1);
              }
              if (value === ".inf") {
                return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
              } else if (value === ".nan") {
                return NaN;
              }
              return sign * parseFloat(value, 10);
            }
            var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
            function representYamlFloat(object, style) {
              var res;
              if (isNaN(object)) {
                switch (style) {
                  case "lowercase":
                    return ".nan";
                  case "uppercase":
                    return ".NAN";
                  case "camelcase":
                    return ".NaN";
                }
              } else if (Number.POSITIVE_INFINITY === object) {
                switch (style) {
                  case "lowercase":
                    return ".inf";
                  case "uppercase":
                    return ".INF";
                  case "camelcase":
                    return ".Inf";
                }
              } else if (Number.NEGATIVE_INFINITY === object) {
                switch (style) {
                  case "lowercase":
                    return "-.inf";
                  case "uppercase":
                    return "-.INF";
                  case "camelcase":
                    return "-.Inf";
                }
              } else if (common.isNegativeZero(object)) {
                return "-0.0";
              }
              res = object.toString(10);
              return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
            }
            function isFloat(object) {
              return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
            }
            module2.exports = new Type("tag:yaml.org,2002:float", {
              kind: "scalar",
              resolve: resolveYamlFloat,
              construct: constructYamlFloat,
              predicate: isFloat,
              represent: representYamlFloat,
              defaultStyle: "lowercase"
            });
          },
          3512: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var common = __webpack_require__2(9249);
            var Type = __webpack_require__2(2274);
            function isHexCode(c) {
              return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
            }
            function isOctCode(c) {
              return 48 <= c && c <= 55;
            }
            function isDecCode(c) {
              return 48 <= c && c <= 57;
            }
            function resolveYamlInteger(data) {
              if (data === null)
                return false;
              var max = data.length, index = 0, hasDigits = false, ch;
              if (!max)
                return false;
              ch = data[index];
              if (ch === "-" || ch === "+") {
                ch = data[++index];
              }
              if (ch === "0") {
                if (index + 1 === max)
                  return true;
                ch = data[++index];
                if (ch === "b") {
                  index++;
                  for (; index < max; index++) {
                    ch = data[index];
                    if (ch === "_")
                      continue;
                    if (ch !== "0" && ch !== "1")
                      return false;
                    hasDigits = true;
                  }
                  return hasDigits && ch !== "_";
                }
                if (ch === "x") {
                  index++;
                  for (; index < max; index++) {
                    ch = data[index];
                    if (ch === "_")
                      continue;
                    if (!isHexCode(data.charCodeAt(index)))
                      return false;
                    hasDigits = true;
                  }
                  return hasDigits && ch !== "_";
                }
                if (ch === "o") {
                  index++;
                  for (; index < max; index++) {
                    ch = data[index];
                    if (ch === "_")
                      continue;
                    if (!isOctCode(data.charCodeAt(index)))
                      return false;
                    hasDigits = true;
                  }
                  return hasDigits && ch !== "_";
                }
              }
              if (ch === "_")
                return false;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_")
                  continue;
                if (!isDecCode(data.charCodeAt(index))) {
                  return false;
                }
                hasDigits = true;
              }
              if (!hasDigits || ch === "_")
                return false;
              return true;
            }
            function constructYamlInteger(data) {
              var value = data, sign = 1, ch;
              if (value.indexOf("_") !== -1) {
                value = value.replace(/_/g, "");
              }
              ch = value[0];
              if (ch === "-" || ch === "+") {
                if (ch === "-")
                  sign = -1;
                value = value.slice(1);
                ch = value[0];
              }
              if (value === "0")
                return 0;
              if (ch === "0") {
                if (value[1] === "b")
                  return sign * parseInt(value.slice(2), 2);
                if (value[1] === "x")
                  return sign * parseInt(value.slice(2), 16);
                if (value[1] === "o")
                  return sign * parseInt(value.slice(2), 8);
              }
              return sign * parseInt(value, 10);
            }
            function isInteger(object) {
              return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
            }
            module2.exports = new Type("tag:yaml.org,2002:int", {
              kind: "scalar",
              resolve: resolveYamlInteger,
              construct: constructYamlInteger,
              predicate: isInteger,
              represent: {
                binary: function(obj) {
                  return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
                },
                octal: function(obj) {
                  return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
                },
                decimal: function(obj) {
                  return obj.toString(10);
                },
                hexadecimal: function(obj) {
                  return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
                }
              },
              defaultStyle: "decimal",
              styleAliases: {
                binary: [2, "bin"],
                octal: [8, "oct"],
                decimal: [10, "dec"],
                hexadecimal: [16, "hex"]
              }
            });
          },
          584: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            module2.exports = new Type("tag:yaml.org,2002:map", {
              kind: "mapping",
              construct: function(data) {
                return data !== null ? data : {};
              }
            });
          },
          1570: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            function resolveYamlMerge(data) {
              return data === "<<" || data === null;
            }
            module2.exports = new Type("tag:yaml.org,2002:merge", {
              kind: "scalar",
              resolve: resolveYamlMerge
            });
          },
          3328: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            function resolveYamlNull(data) {
              if (data === null)
                return true;
              var max = data.length;
              return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
            }
            function constructYamlNull() {
              return null;
            }
            function isNull(object) {
              return object === null;
            }
            module2.exports = new Type("tag:yaml.org,2002:null", {
              kind: "scalar",
              resolve: resolveYamlNull,
              construct: constructYamlNull,
              predicate: isNull,
              represent: {
                canonical: function() {
                  return "~";
                },
                lowercase: function() {
                  return "null";
                },
                uppercase: function() {
                  return "NULL";
                },
                camelcase: function() {
                  return "Null";
                },
                empty: function() {
                  return "";
                }
              },
              defaultStyle: "lowercase"
            });
          },
          9272: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var _toString = Object.prototype.toString;
            function resolveYamlOmap(data) {
              if (data === null)
                return true;
              var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
              for (index = 0, length = object.length; index < length; index += 1) {
                pair = object[index];
                pairHasKey = false;
                if (_toString.call(pair) !== "[object Object]")
                  return false;
                for (pairKey in pair) {
                  if (_hasOwnProperty.call(pair, pairKey)) {
                    if (!pairHasKey)
                      pairHasKey = true;
                    else
                      return false;
                  }
                }
                if (!pairHasKey)
                  return false;
                if (objectKeys.indexOf(pairKey) === -1)
                  objectKeys.push(pairKey);
                else
                  return false;
              }
              return true;
            }
            function constructYamlOmap(data) {
              return data !== null ? data : [];
            }
            module2.exports = new Type("tag:yaml.org,2002:omap", {
              kind: "sequence",
              resolve: resolveYamlOmap,
              construct: constructYamlOmap
            });
          },
          3006: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            var _toString = Object.prototype.toString;
            function resolveYamlPairs(data) {
              if (data === null)
                return true;
              var index, length, pair, keys, result, object = data;
              result = new Array(object.length);
              for (index = 0, length = object.length; index < length; index += 1) {
                pair = object[index];
                if (_toString.call(pair) !== "[object Object]")
                  return false;
                keys = Object.keys(pair);
                if (keys.length !== 1)
                  return false;
                result[index] = [keys[0], pair[keys[0]]];
              }
              return true;
            }
            function constructYamlPairs(data) {
              if (data === null)
                return [];
              var index, length, pair, keys, result, object = data;
              result = new Array(object.length);
              for (index = 0, length = object.length; index < length; index += 1) {
                pair = object[index];
                keys = Object.keys(pair);
                result[index] = [keys[0], pair[keys[0]]];
              }
              return result;
            }
            module2.exports = new Type("tag:yaml.org,2002:pairs", {
              kind: "sequence",
              resolve: resolveYamlPairs,
              construct: constructYamlPairs
            });
          },
          4566: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            module2.exports = new Type("tag:yaml.org,2002:seq", {
              kind: "sequence",
              construct: function(data) {
                return data !== null ? data : [];
              }
            });
          },
          8302: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            function resolveYamlSet(data) {
              if (data === null)
                return true;
              var key, object = data;
              for (key in object) {
                if (_hasOwnProperty.call(object, key)) {
                  if (object[key] !== null)
                    return false;
                }
              }
              return true;
            }
            function constructYamlSet(data) {
              return data !== null ? data : {};
            }
            module2.exports = new Type("tag:yaml.org,2002:set", {
              kind: "mapping",
              resolve: resolveYamlSet,
              construct: constructYamlSet
            });
          },
          4035: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            module2.exports = new Type("tag:yaml.org,2002:str", {
              kind: "scalar",
              construct: function(data) {
                return data !== null ? data : "";
              }
            });
          },
          7692: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var Type = __webpack_require__2(2274);
            var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
            var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
            function resolveYamlTimestamp(data) {
              if (data === null)
                return false;
              if (YAML_DATE_REGEXP.exec(data) !== null)
                return true;
              if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
                return true;
              return false;
            }
            function constructYamlTimestamp(data) {
              var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
              match = YAML_DATE_REGEXP.exec(data);
              if (match === null)
                match = YAML_TIMESTAMP_REGEXP.exec(data);
              if (match === null)
                throw new Error("Date resolve error");
              year = +match[1];
              month = +match[2] - 1;
              day = +match[3];
              if (!match[4]) {
                return new Date(Date.UTC(year, month, day));
              }
              hour = +match[4];
              minute = +match[5];
              second = +match[6];
              if (match[7]) {
                fraction = match[7].slice(0, 3);
                while (fraction.length < 3) {
                  fraction += "0";
                }
                fraction = +fraction;
              }
              if (match[9]) {
                tz_hour = +match[10];
                tz_minute = +(match[11] || 0);
                delta = (tz_hour * 60 + tz_minute) * 6e4;
                if (match[9] === "-")
                  delta = -delta;
              }
              date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
              if (delta)
                date.setTime(date.getTime() - delta);
              return date;
            }
            function representYamlTimestamp(object) {
              return object.toISOString();
            }
            module2.exports = new Type("tag:yaml.org,2002:timestamp", {
              kind: "scalar",
              resolve: resolveYamlTimestamp,
              construct: constructYamlTimestamp,
              instanceOf: Date,
              represent: representYamlTimestamp
            });
          },
          5448: (module2, exports3, __webpack_require__2) => {
            module2 = __webpack_require__2.nmd(module2);
            var LARGE_ARRAY_SIZE = 200;
            var HASH_UNDEFINED = "__lodash_hash_undefined__";
            var MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
            var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reFlags = /\w*$/;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
            var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g && __webpack_require__2.g.Object === Object && __webpack_require__2.g;
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var freeExports = exports3 && !exports3.nodeType && exports3;
            var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            function addMapEntry(map, pair) {
              map.set(pair[0], pair[1]);
              return map;
            }
            function addSetEntry(set, value) {
              set.add(value);
              return set;
            }
            function arrayEach(array, iteratee) {
              var index = -1, length = array ? array.length : 0;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayPush(array, values) {
              var index = -1, length = values.length, offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1, length = array ? array.length : 0;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            function baseTimes(n, iteratee) {
              var index = -1, result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function getValue(object, key) {
              return object == null ? void 0 : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != "function") {
                try {
                  result = !!(value + "");
                } catch (e) {
                }
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1, result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
            var coreJsData = root["__core-js_shared__"];
            var maskSrcKey = function() {
              var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
              return uid ? "Symbol(src)_1." + uid : "";
            }();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
            var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
            var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
            var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
            var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            function Hash(entries) {
              var index = -1, length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? void 0 : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype["delete"] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1, length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__, index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__, index = assocIndexOf(data, key);
              return index < 0 ? void 0 : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__, index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype["delete"] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1, length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                "hash": new Hash(),
                "map": new (Map2 || ListCache)(),
                "string": new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)["delete"](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype["delete"] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__["delete"](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype["delete"] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
              var length = result.length, skipIndexes = !!length;
              for (var key in value) {
                if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
                  result.push(key);
                }
              }
              return result;
            }
            function assignValue(object, key, value) {
              var objValue = object[key];
              if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
                object[key] = value;
              }
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            function baseAssign(object, source) {
              return object && copyObject(source, keys(source), object);
            }
            function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
              var result;
              if (customizer) {
                result = object ? customizer(value, key, object, stack) : customizer(value);
              }
              if (result !== void 0) {
                return result;
              }
              if (!isObject(value)) {
                return value;
              }
              var isArr = isArray(value);
              if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                  return copyArray(value, result);
                }
              } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                  return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                  if (isHostObject(value)) {
                    return object ? value : {};
                  }
                  result = initCloneObject(isFunc ? {} : value);
                  if (!isDeep) {
                    return copySymbols(value, baseAssign(result, value));
                  }
                } else {
                  if (!cloneableTags[tag]) {
                    return object ? value : {};
                  }
                  result = initCloneByTag(value, tag, baseClone, isDeep);
                }
              }
              stack || (stack = new Stack());
              var stacked = stack.get(value);
              if (stacked) {
                return stacked;
              }
              stack.set(value, result);
              if (!isArr) {
                var props = isFull ? getAllKeys(value) : keys(value);
              }
              arrayEach(props || value, function(subValue, key2) {
                if (props) {
                  key2 = subValue;
                  subValue = value[key2];
                }
                assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
              });
              return result;
            }
            function baseCreate(proto) {
              return isObject(proto) ? objectCreate(proto) : {};
            }
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
              var result = keysFunc(object);
              return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != "constructor") {
                  result.push(key);
                }
              }
              return result;
            }
            function cloneBuffer(buffer, isDeep) {
              if (isDeep) {
                return buffer.slice();
              }
              var result = new buffer.constructor(buffer.length);
              buffer.copy(result);
              return result;
            }
            function cloneArrayBuffer(arrayBuffer) {
              var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
              new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
              return result;
            }
            function cloneDataView(dataView, isDeep) {
              var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
              return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
            }
            function cloneMap(map, isDeep, cloneFunc) {
              var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
              return arrayReduce(array, addMapEntry, new map.constructor());
            }
            function cloneRegExp(regexp) {
              var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
              result.lastIndex = regexp.lastIndex;
              return result;
            }
            function cloneSet(set, isDeep, cloneFunc) {
              var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
              return arrayReduce(array, addSetEntry, new set.constructor());
            }
            function cloneSymbol(symbol) {
              return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
            }
            function cloneTypedArray(typedArray, isDeep) {
              var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
              return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
            }
            function copyArray(source, array) {
              var index = -1, length = source.length;
              array || (array = Array(length));
              while (++index < length) {
                array[index] = source[index];
              }
              return array;
            }
            function copyObject(source, props, object, customizer) {
              object || (object = {});
              var index = -1, length = props.length;
              while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                assignValue(object, key, newValue === void 0 ? source[key] : newValue);
              }
              return object;
            }
            function copySymbols(source, object) {
              return copyObject(source, getSymbols(source), object);
            }
            function getAllKeys(object) {
              return baseGetAllKeys(object, keys, getSymbols);
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : void 0;
            }
            var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
            var getTag = baseGetTag;
            if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
              getTag = function(value) {
                var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function initCloneArray(array) {
              var length = array.length, result = array.constructor(length);
              if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input;
              }
              return result;
            }
            function initCloneObject(object) {
              return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
            }
            function initCloneByTag(object, tag, cloneFunc, isDeep) {
              var Ctor = object.constructor;
              switch (tag) {
                case arrayBufferTag:
                  return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                  return new Ctor(+object);
                case dataViewTag:
                  return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                  return cloneTypedArray(object, isDeep);
                case mapTag:
                  return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                  return new Ctor(object);
                case regexpTag:
                  return cloneRegExp(object);
                case setTag:
                  return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                  return cloneSymbol(object);
              }
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
              return value === proto;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {
                }
                try {
                  return func + "";
                } catch (e) {
                }
              }
              return "";
            }
            function cloneDeepWith(value, customizer) {
              return baseClone(value, true, true, customizer);
            }
            function eq(value, other) {
              return value === other || value !== value && other !== other;
            }
            function isArguments(value) {
              return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return value != null && isLength(value.length) && !isFunction(value);
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            var isBuffer = nativeIsBuffer || stubFalse;
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : "";
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == "object" || type == "function");
            }
            function isObjectLike(value) {
              return !!value && typeof value == "object";
            }
            function keys(object) {
              return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            function stubArray() {
              return [];
            }
            function stubFalse() {
              return false;
            }
            module2.exports = cloneDeepWith;
          },
          2790: (module2) => {
            var process2 = module2.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
              throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
              throw new Error("clearTimeout has not been defined");
            }
            (function() {
              try {
                if (typeof setTimeout === "function") {
                  cachedSetTimeout = setTimeout;
                } else {
                  cachedSetTimeout = defaultSetTimout;
                }
              } catch (e) {
                cachedSetTimeout = defaultSetTimout;
              }
              try {
                if (typeof clearTimeout === "function") {
                  cachedClearTimeout = clearTimeout;
                } else {
                  cachedClearTimeout = defaultClearTimeout;
                }
              } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
              }
            })();
            function runTimeout(fun) {
              if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
              }
              if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
              }
              try {
                return cachedSetTimeout(fun, 0);
              } catch (e) {
                try {
                  return cachedSetTimeout.call(null, fun, 0);
                } catch (e2) {
                  return cachedSetTimeout.call(this, fun, 0);
                }
              }
            }
            function runClearTimeout(marker2) {
              if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker2);
              }
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker2);
              }
              try {
                return cachedClearTimeout(marker2);
              } catch (e) {
                try {
                  return cachedClearTimeout.call(null, marker2);
                } catch (e2) {
                  return cachedClearTimeout.call(this, marker2);
                }
              }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
              if (!draining || !currentQueue) {
                return;
              }
              draining = false;
              if (currentQueue.length) {
                queue = currentQueue.concat(queue);
              } else {
                queueIndex = -1;
              }
              if (queue.length) {
                drainQueue();
              }
            }
            function drainQueue() {
              if (draining) {
                return;
              }
              var timeout = runTimeout(cleanUpNextTick);
              draining = true;
              var len = queue.length;
              while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                  if (currentQueue) {
                    currentQueue[queueIndex].run();
                  }
                }
                queueIndex = -1;
                len = queue.length;
              }
              currentQueue = null;
              draining = false;
              runClearTimeout(timeout);
            }
            process2.nextTick = function(fun) {
              var args = new Array(arguments.length - 1);
              if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                  args[i - 1] = arguments[i];
                }
              }
              queue.push(new Item(fun, args));
              if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
              }
            };
            function Item(fun, array) {
              this.fun = fun;
              this.array = array;
            }
            Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            };
            process2.title = "browser";
            process2.browser = true;
            process2.env = {};
            process2.argv = [];
            process2.version = "";
            process2.versions = {};
            function noop() {
            }
            process2.on = noop;
            process2.addListener = noop;
            process2.once = noop;
            process2.off = noop;
            process2.removeListener = noop;
            process2.removeAllListeners = noop;
            process2.emit = noop;
            process2.prependListener = noop;
            process2.prependOnceListener = noop;
            process2.listeners = function(name) {
              return [];
            };
            process2.binding = function(name) {
              throw new Error("process.binding is not supported");
            };
            process2.cwd = function() {
              return "/";
            };
            process2.chdir = function(dir) {
              throw new Error("process.chdir is not supported");
            };
            process2.umask = function() {
              return 0;
            };
          },
          4806: (module2) => {
            "use strict";
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            module2.exports = function(qs, sep, eq, options2) {
              sep = sep || "&";
              eq = eq || "=";
              var obj = {};
              if (typeof qs !== "string" || qs.length === 0) {
                return obj;
              }
              var regexp = /\+/g;
              qs = qs.split(sep);
              var maxKeys = 1e3;
              if (options2 && typeof options2.maxKeys === "number") {
                maxKeys = options2.maxKeys;
              }
              var len = qs.length;
              if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
              }
              for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                if (idx >= 0) {
                  kstr = x.substr(0, idx);
                  vstr = x.substr(idx + 1);
                } else {
                  kstr = x;
                  vstr = "";
                }
                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);
                if (!hasOwnProperty(obj, k)) {
                  obj[k] = v;
                } else if (Array.isArray(obj[k])) {
                  obj[k].push(v);
                } else {
                  obj[k] = [obj[k], v];
                }
              }
              return obj;
            };
          },
          5491: (module2) => {
            "use strict";
            var stringifyPrimitive = function(v) {
              switch (typeof v) {
                case "string":
                  return v;
                case "boolean":
                  return v ? "true" : "false";
                case "number":
                  return isFinite(v) ? v : "";
                default:
                  return "";
              }
            };
            module2.exports = function(obj, sep, eq, name) {
              sep = sep || "&";
              eq = eq || "=";
              if (obj === null) {
                obj = void 0;
              }
              if (typeof obj === "object") {
                return Object.keys(obj).map(function(k) {
                  var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                  if (Array.isArray(obj[k])) {
                    return obj[k].map(function(v) {
                      return ks + encodeURIComponent(stringifyPrimitive(v));
                    }).join(sep);
                  } else {
                    return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                  }
                }).join(sep);
              }
              if (!name)
                return "";
              return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
            };
          },
          4126: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            exports3.decode = exports3.parse = __webpack_require__2(4806);
            exports3.encode = exports3.stringify = __webpack_require__2(5491);
          },
          352: (module2) => {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              subClass.__proto__ = superClass;
            }
            var codes = {};
            function createErrorType(code, message, Base) {
              if (!Base) {
                Base = Error;
              }
              function getMessage(arg1, arg2, arg3) {
                if (typeof message === "string") {
                  return message;
                } else {
                  return message(arg1, arg2, arg3);
                }
              }
              var NodeError = function(_Base) {
                _inheritsLoose(NodeError2, _Base);
                function NodeError2(arg1, arg2, arg3) {
                  return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
                }
                return NodeError2;
              }(Base);
              NodeError.prototype.name = Base.name;
              NodeError.prototype.code = code;
              codes[code] = NodeError;
            }
            function oneOf(expected, thing) {
              if (Array.isArray(expected)) {
                var len = expected.length;
                expected = expected.map(function(i) {
                  return String(i);
                });
                if (len > 2) {
                  return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                } else if (len === 2) {
                  return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                } else {
                  return "of ".concat(thing, " ").concat(expected[0]);
                }
              } else {
                return "of ".concat(thing, " ").concat(String(expected));
              }
            }
            function startsWith(str, search, pos) {
              return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
            }
            function endsWith2(str, search, this_len) {
              if (this_len === void 0 || this_len > str.length) {
                this_len = str.length;
              }
              return str.substring(this_len - search.length, this_len) === search;
            }
            function includes(str, search, start) {
              if (typeof start !== "number") {
                start = 0;
              }
              if (start + search.length > str.length) {
                return false;
              } else {
                return str.indexOf(search, start) !== -1;
              }
            }
            createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
              return 'The value "' + value + '" is invalid for option "' + name + '"';
            }, TypeError);
            createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
              var determiner;
              if (typeof expected === "string" && startsWith(expected, "not ")) {
                determiner = "must not be";
                expected = expected.replace(/^not /, "");
              } else {
                determiner = "must be";
              }
              var msg;
              if (endsWith2(name, " argument")) {
                msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
              } else {
                var type = includes(name, ".") ? "property" : "argument";
                msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
              }
              msg += ". Received type ".concat(typeof actual);
              return msg;
            }, TypeError);
            createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
            createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
              return "The " + name + " method is not implemented";
            });
            createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
            createErrorType("ERR_STREAM_DESTROYED", function(name) {
              return "Cannot call " + name + " after a stream was destroyed";
            });
            createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
            createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
            createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
            createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
            createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
              return "Unknown encoding: " + arg;
            }, TypeError);
            createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
            module2.exports.codes = codes;
          },
          3653: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            var objectKeys = Object.keys || function(obj) {
              var keys2 = [];
              for (var key in obj) {
                keys2.push(key);
              }
              return keys2;
            };
            module2.exports = Duplex;
            var Readable = __webpack_require__2(8817);
            var Writable = __webpack_require__2(2248);
            __webpack_require__2(5153)(Duplex, Readable);
            {
              var keys = objectKeys(Writable.prototype);
              for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method])
                  Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options2) {
              if (!(this instanceof Duplex))
                return new Duplex(options2);
              Readable.call(this, options2);
              Writable.call(this, options2);
              this.allowHalfOpen = true;
              if (options2) {
                if (options2.readable === false)
                  this.readable = false;
                if (options2.writable === false)
                  this.writable = false;
                if (options2.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function onend() {
              if (this._writableState.ended)
                return;
              process2.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set(value) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            });
          },
          8210: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            module2.exports = PassThrough;
            var Transform = __webpack_require__2(5500);
            __webpack_require__2(5153)(PassThrough, Transform);
            function PassThrough(options2) {
              if (!(this instanceof PassThrough))
                return new PassThrough(options2);
              Transform.call(this, options2);
            }
            PassThrough.prototype._transform = function(chunk, encoding, cb) {
              cb(null, chunk);
            };
          },
          8817: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            __webpack_require__2(9494);
            module2.exports = Readable;
            var Duplex;
            Readable.ReadableState = ReadableState;
            var EE = __webpack_require__2(1590).EventEmitter;
            var EElistenerCount = function EElistenerCount2(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = __webpack_require__2(1773);
            var Buffer2 = __webpack_require__2(5851).Buffer;
            var OurUint8Array = __webpack_require__2.g.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var debugUtil = __webpack_require__2(4616);
            var debug;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug2() {
              };
            }
            var BufferList = __webpack_require__2(2923);
            var destroyImpl = __webpack_require__2(1735);
            var _require = __webpack_require__2(9604), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = __webpack_require__2(352).codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from;
            __webpack_require__2(5153)(Readable, Stream);
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options2, stream, isDuplex) {
              Duplex = Duplex || __webpack_require__2(3653);
              options2 = options2 || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options2.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options2.readableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true;
              this.emitClose = options2.emitClose !== false;
              this.autoDestroy = !!options2.autoDestroy;
              this.destroyed = false;
              this.defaultEncoding = options2.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options2.encoding) {
                if (!StringDecoder)
                  StringDecoder = __webpack_require__2(1907).StringDecoder;
                this.decoder = new StringDecoder(options2.encoding);
                this.encoding = options2.encoding;
              }
            }
            function Readable(options2) {
              Duplex = Duplex || __webpack_require__2(3653);
              if (!(this instanceof Readable))
                return new Readable(options2);
              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options2, this, isDuplex);
              this.readable = true;
              if (options2) {
                if (typeof options2.read === "function")
                  this._read = options2.read;
                if (typeof options2.destroy === "function")
                  this._destroy = options2.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function set(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer2.from(chunk, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk);
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state.destroyed) {
                    return false;
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                  maybeReadMore(stream, state);
                }
              }
              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                state.awaitDrain = 0;
                stream.emit("data", chunk);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
              }
              return er;
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = __webpack_require__2(1907).StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              var p = this._readableState.buffer.head;
              var content = "";
              while (p !== null) {
                content += decoder.write(p.data);
                p = p.next;
              }
              this._readableState.buffer.clear();
              if (content !== "")
                this._readableState.buffer.push(content);
              this._readableState.length = content.length;
              return this;
            };
            var MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n) {
              if (n >= MAX_HWM) {
                n = MAX_HWM;
              } else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }
              return n;
            }
            function howMuchToRead(n, state) {
              if (n <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n !== n) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n);
              if (n <= state.length)
                return n;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n) {
              debug("read", n);
              n = parseInt(n, 10);
              var state = this._readableState;
              var nOrig = n;
              if (n !== 0)
                state.emittedReadable = false;
              if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n = howMuchToRead(n, state);
              if (n === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n > 0)
                ret = fromList(n, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n = 0;
              } else {
                state.length -= n;
                state.awaitDrain = 0;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              if (state.sync) {
                emitReadable(stream);
              } else {
                state.needReadable = false;
                if (!state.emittedReadable) {
                  state.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process2.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              var state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);
              if (!state.destroyed && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              }
              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                process2.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                var len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                process2.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                var ret = dest.write(chunk);
                debug("dest.write", ret);
                if (ret === false) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  errorOrDestroy(dest, er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function pipeOnDrainFunctionResult() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = {
                hasUnpiped: false
              };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) {
                  dests[i].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                }
                return this;
              }
              var index = indexOf(state.pipes, dest);
              if (index === -1)
                return this;
              state.pipes.splice(index, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state = this._readableState;
              if (ev === "data") {
                state.readableListening = this.listenerCount("readable") > 0;
                if (state.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);
                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process2.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process2.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.removeAllListeners = function(ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process2.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              var state = self2._readableState;
              state.readableListening = self2.listenerCount("readable") > 0;
              if (state.resumeScheduled && !state.paused) {
                state.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = !state.readableListening;
                resume(this, state);
              }
              state.paused = false;
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process2.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              debug("resume", state.reading);
              if (!state.reading) {
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState.paused = true;
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null) {
                ;
              }
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === void 0 && typeof stream[i] === "function") {
                  this[i] = function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }
              for (var n = 0; n < kProxyEvents.length; n++) {
                stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
              }
              this._read = function(n2) {
                debug("wrapped _read", n2);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function() {
                if (createReadableStreamAsyncIterator === void 0) {
                  createReadableStreamAsyncIterator = __webpack_require__2(4258);
                }
                return createReadableStreamAsyncIterator(this);
              };
            }
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              enumerable: false,
              get: function get() {
                return this._readableState.highWaterMark;
              }
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              enumerable: false,
              get: function get() {
                return this._readableState && this._readableState.buffer;
              }
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              enumerable: false,
              get: function get() {
                return this._readableState.flowing;
              },
              set: function set(state) {
                if (this._readableState) {
                  this._readableState.flowing = state;
                }
              }
            });
            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              enumerable: false,
              get: function get() {
                return this._readableState.length;
              }
            });
            function fromList(n, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n || n >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.first();
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = state.buffer.consume(n, state.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              debug("endReadable", state.endEmitted);
              if (!state.endEmitted) {
                state.ended = true;
                process2.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length);
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
                if (state.autoDestroy) {
                  var wState = stream._writableState;
                  if (!wState || wState.autoDestroy && wState.finished) {
                    stream.destroy();
                  }
                }
              }
            }
            if (typeof Symbol === "function") {
              Readable.from = function(iterable, opts) {
                if (from === void 0) {
                  from = __webpack_require__2(7766);
                }
                return from(Readable, iterable, opts);
              };
            }
            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x)
                  return i;
              }
              return -1;
            }
          },
          5500: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            module2.exports = Transform;
            var _require$codes = __webpack_require__2(352).codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
            var Duplex = __webpack_require__2(3653);
            __webpack_require__2(5153)(Transform, Duplex);
            function afterTransform(er, data) {
              var ts = this._transformState;
              ts.transforming = false;
              var cb = ts.writecb;
              if (cb === null) {
                return this.emit("error", new ERR_MULTIPLE_CALLBACK());
              }
              ts.writechunk = null;
              ts.writecb = null;
              if (data != null)
                this.push(data);
              cb(er);
              var rs = this._readableState;
              rs.reading = false;
              if (rs.needReadable || rs.length < rs.highWaterMark) {
                this._read(rs.highWaterMark);
              }
            }
            function Transform(options2) {
              if (!(this instanceof Transform))
                return new Transform(options2);
              Duplex.call(this, options2);
              this._transformState = {
                afterTransform: afterTransform.bind(this),
                needTransform: false,
                transforming: false,
                writecb: null,
                writechunk: null,
                writeencoding: null
              };
              this._readableState.needReadable = true;
              this._readableState.sync = false;
              if (options2) {
                if (typeof options2.transform === "function")
                  this._transform = options2.transform;
                if (typeof options2.flush === "function")
                  this._flush = options2.flush;
              }
              this.on("prefinish", prefinish);
            }
            function prefinish() {
              var _this = this;
              if (typeof this._flush === "function" && !this._readableState.destroyed) {
                this._flush(function(er, data) {
                  done(_this, er, data);
                });
              } else {
                done(this, null, null);
              }
            }
            Transform.prototype.push = function(chunk, encoding) {
              this._transformState.needTransform = false;
              return Duplex.prototype.push.call(this, chunk, encoding);
            };
            Transform.prototype._transform = function(chunk, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
            };
            Transform.prototype._write = function(chunk, encoding, cb) {
              var ts = this._transformState;
              ts.writecb = cb;
              ts.writechunk = chunk;
              ts.writeencoding = encoding;
              if (!ts.transforming) {
                var rs = this._readableState;
                if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                  this._read(rs.highWaterMark);
              }
            };
            Transform.prototype._read = function(n) {
              var ts = this._transformState;
              if (ts.writechunk !== null && !ts.transforming) {
                ts.transforming = true;
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
              } else {
                ts.needTransform = true;
              }
            };
            Transform.prototype._destroy = function(err, cb) {
              Duplex.prototype._destroy.call(this, err, function(err2) {
                cb(err2);
              });
            };
            function done(stream, er, data) {
              if (er)
                return stream.emit("error", er);
              if (data != null)
                stream.push(data);
              if (stream._writableState.length)
                throw new ERR_TRANSFORM_WITH_LENGTH_0();
              if (stream._transformState.transforming)
                throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
              return stream.push(null);
            }
          },
          2248: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            __webpack_require__2(9494);
            module2.exports = Writable;
            function WriteReq(chunk, encoding, cb) {
              this.chunk = chunk;
              this.encoding = encoding;
              this.callback = cb;
              this.next = null;
            }
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var Duplex;
            Writable.WritableState = WritableState;
            var internalUtil = {
              deprecate: __webpack_require__2(6276)
            };
            var Stream = __webpack_require__2(1773);
            var Buffer2 = __webpack_require__2(5851).Buffer;
            var OurUint8Array = __webpack_require__2.g.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = __webpack_require__2(1735);
            var _require = __webpack_require__2(9604), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = __webpack_require__2(352).codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            __webpack_require__2(5153)(Writable, Stream);
            function nop() {
            }
            function WritableState(options2, stream, isDuplex) {
              Duplex = Duplex || __webpack_require__2(3653);
              options2 = options2 || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options2.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options2.writableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options2.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options2.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = options2.emitClose !== false;
              this.autoDestroy = !!options2.autoDestroy;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(function writableStateBufferGetter() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch (_) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function value(object) {
                  if (realHasInstance.call(this, object))
                    return true;
                  if (this !== Writable)
                    return false;
                  return object && object._writableState instanceof WritableState;
                }
              });
            } else {
              realHasInstance = function realHasInstance2(object) {
                return object instanceof this;
              };
            }
            function Writable(options2) {
              Duplex = Duplex || __webpack_require__2(3653);
              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this))
                return new Writable(options2);
              this._writableState = new WritableState(options2, this, isDuplex);
              this.writable = true;
              if (options2) {
                if (typeof options2.write === "function")
                  this._write = options2.write;
                if (typeof options2.writev === "function")
                  this._writev = options2.writev;
                if (typeof options2.destroy === "function")
                  this._destroy = options2.destroy;
                if (typeof options2.final === "function")
                  this._final = options2.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END();
              errorOrDestroy(stream, er);
              process2.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var er;
              if (chunk === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk !== "string" && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
              }
              if (er) {
                errorOrDestroy(stream, er);
                process2.nextTick(cb, er);
                return false;
              }
              return true;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer2.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ending)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new ERR_UNKNOWN_ENCODING(encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableBuffer", {
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer2.from(chunk, encoding);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk,
                  encoding,
                  isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed)
                state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                process2.nextTick(cb, er);
                process2.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              if (typeof cb !== "function")
                throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state) || stream.destroyed;
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  process2.nextTick(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending)
                endWritable(this, state, cb);
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableLength", {
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                  errorOrDestroy(stream, err);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.pendingcb++;
                  state.finalCalled = true;
                  process2.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                  if (state.autoDestroy) {
                    var rState = stream._readableState;
                    if (!rState || rState.autoDestroy && rState.endEmitted) {
                      stream.destroy();
                    }
                  }
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  process2.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              state.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              enumerable: false,
              get: function get() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function set(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              cb(err);
            };
          },
          4258: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            var _Object$setPrototypeO;
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var finished = __webpack_require__2(6591);
            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");
            function createIterResult(value, done) {
              return {
                value,
                done
              };
            }
            function readAndResolve(iter) {
              var resolve2 = iter[kLastResolve];
              if (resolve2 !== null) {
                var data = iter[kStream].read();
                if (data !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve2(createIterResult(data, false));
                }
              }
            }
            function onReadable(iter) {
              process2.nextTick(readAndResolve, iter);
            }
            function wrapForNext(lastPromise, iter) {
              return function(resolve2, reject) {
                lastPromise.then(function() {
                  if (iter[kEnded]) {
                    resolve2(createIterResult(void 0, true));
                    return;
                  }
                  iter[kHandlePromise](resolve2, reject);
                }, reject);
              };
            }
            var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
            });
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
              get stream() {
                return this[kStream];
              },
              next: function next() {
                var _this = this;
                var error = this[kError];
                if (error !== null) {
                  return Promise.reject(error);
                }
                if (this[kEnded]) {
                  return Promise.resolve(createIterResult(void 0, true));
                }
                if (this[kStream].destroyed) {
                  return new Promise(function(resolve2, reject) {
                    process2.nextTick(function() {
                      if (_this[kError]) {
                        reject(_this[kError]);
                      } else {
                        resolve2(createIterResult(void 0, true));
                      }
                    });
                  });
                }
                var lastPromise = this[kLastPromise];
                var promise;
                if (lastPromise) {
                  promise = new Promise(wrapForNext(lastPromise, this));
                } else {
                  var data = this[kStream].read();
                  if (data !== null) {
                    return Promise.resolve(createIterResult(data, false));
                  }
                  promise = new Promise(this[kHandlePromise]);
                }
                this[kLastPromise] = promise;
                return promise;
              }
            }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
              return this;
            }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
              var _this2 = this;
              return new Promise(function(resolve2, reject) {
                _this2[kStream].destroy(null, function(err) {
                  if (err) {
                    reject(err);
                    return;
                  }
                  resolve2(createIterResult(void 0, true));
                });
              });
            }), _Object$setPrototypeO), AsyncIteratorPrototype);
            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
              var _Object$create;
              var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                value: stream,
                writable: true
              }), _defineProperty(_Object$create, kLastResolve, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kLastReject, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kError, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kEnded, {
                value: stream._readableState.endEmitted,
                writable: true
              }), _defineProperty(_Object$create, kHandlePromise, {
                value: function value(resolve2, reject) {
                  var data = iterator[kStream].read();
                  if (data) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve2(createIterResult(data, false));
                  } else {
                    iterator[kLastResolve] = resolve2;
                    iterator[kLastReject] = reject;
                  }
                },
                writable: true
              }), _Object$create));
              iterator[kLastPromise] = null;
              finished(stream, function(err) {
                if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject];
                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err);
                  }
                  iterator[kError] = err;
                  return;
                }
                var resolve2 = iterator[kLastResolve];
                if (resolve2 !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve2(createIterResult(void 0, true));
                }
                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };
            module2.exports = createReadableStreamAsyncIterator;
          },
          2923: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            function ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly)
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function _objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              return Constructor;
            }
            var _require = __webpack_require__2(5851), Buffer2 = _require.Buffer;
            var _require2 = __webpack_require__2(2361), inspect = _require2.inspect;
            var custom = inspect && inspect.custom || "inspect";
            function copyBuffer(src, target, offset) {
              Buffer2.prototype.copy.call(src, target, offset);
            }
            module2.exports = function() {
              function BufferList() {
                _classCallCheck(this, BufferList);
                this.head = null;
                this.tail = null;
                this.length = 0;
              }
              _createClass(BufferList, [{
                key: "push",
                value: function push(v) {
                  var entry = {
                    data: v,
                    next: null
                  };
                  if (this.length > 0)
                    this.tail.next = entry;
                  else
                    this.head = entry;
                  this.tail = entry;
                  ++this.length;
                }
              }, {
                key: "unshift",
                value: function unshift(v) {
                  var entry = {
                    data: v,
                    next: this.head
                  };
                  if (this.length === 0)
                    this.tail = entry;
                  this.head = entry;
                  ++this.length;
                }
              }, {
                key: "shift",
                value: function shift() {
                  if (this.length === 0)
                    return;
                  var ret = this.head.data;
                  if (this.length === 1)
                    this.head = this.tail = null;
                  else
                    this.head = this.head.next;
                  --this.length;
                  return ret;
                }
              }, {
                key: "clear",
                value: function clear() {
                  this.head = this.tail = null;
                  this.length = 0;
                }
              }, {
                key: "join",
                value: function join(s) {
                  if (this.length === 0)
                    return "";
                  var p = this.head;
                  var ret = "" + p.data;
                  while (p = p.next) {
                    ret += s + p.data;
                  }
                  return ret;
                }
              }, {
                key: "concat",
                value: function concat(n) {
                  if (this.length === 0)
                    return Buffer2.alloc(0);
                  var ret = Buffer2.allocUnsafe(n >>> 0);
                  var p = this.head;
                  var i = 0;
                  while (p) {
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                  }
                  return ret;
                }
              }, {
                key: "consume",
                value: function consume(n, hasStrings) {
                  var ret;
                  if (n < this.head.data.length) {
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                  } else if (n === this.head.data.length) {
                    ret = this.shift();
                  } else {
                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                  }
                  return ret;
                }
              }, {
                key: "first",
                value: function first() {
                  return this.head.data;
                }
              }, {
                key: "_getString",
                value: function _getString(n) {
                  var p = this.head;
                  var c = 1;
                  var ret = p.data;
                  n -= ret.length;
                  while (p = p.next) {
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length)
                      ret += str;
                    else
                      ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                      if (nb === str.length) {
                        ++c;
                        if (p.next)
                          this.head = p.next;
                        else
                          this.head = this.tail = null;
                      } else {
                        this.head = p;
                        p.data = str.slice(nb);
                      }
                      break;
                    }
                    ++c;
                  }
                  this.length -= c;
                  return ret;
                }
              }, {
                key: "_getBuffer",
                value: function _getBuffer(n) {
                  var ret = Buffer2.allocUnsafe(n);
                  var p = this.head;
                  var c = 1;
                  p.data.copy(ret);
                  n -= p.data.length;
                  while (p = p.next) {
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                      if (nb === buf.length) {
                        ++c;
                        if (p.next)
                          this.head = p.next;
                        else
                          this.head = this.tail = null;
                      } else {
                        this.head = p;
                        p.data = buf.slice(nb);
                      }
                      break;
                    }
                    ++c;
                  }
                  this.length -= c;
                  return ret;
                }
              }, {
                key: custom,
                value: function value(_, options2) {
                  return inspect(this, _objectSpread({}, options2, {
                    depth: 0,
                    customInspect: false
                  }));
                }
              }]);
              return BufferList;
            }();
          },
          1735: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var process2 = __webpack_require__2(2790);
            function destroy(err, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err) {
                  if (!this._writableState) {
                    process2.nextTick(emitErrorNT, this, err);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process2.nextTick(emitErrorNT, this, err);
                  }
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err || null, function(err2) {
                if (!cb && err2) {
                  if (!_this._writableState) {
                    process2.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process2.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else {
                    process2.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process2.nextTick(emitCloseNT, _this);
                  cb(err2);
                } else {
                  process2.nextTick(emitCloseNT, _this);
                }
              });
              return this;
            }
            function emitErrorAndCloseNT(self2, err) {
              emitErrorNT(self2, err);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              if (self2._writableState && !self2._writableState.emitClose)
                return;
              if (self2._readableState && !self2._readableState.emitClose)
                return;
              self2.emit("close");
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err) {
              self2.emit("error", err);
            }
            function errorOrDestroy(stream, err) {
              var rState = stream._readableState;
              var wState = stream._writableState;
              if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                stream.destroy(err);
              else
                stream.emit("error", err);
            }
            module2.exports = {
              destroy,
              undestroy,
              errorOrDestroy
            };
          },
          6591: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__2(352).codes.ERR_STREAM_PREMATURE_CLOSE;
            function once(callback) {
              var called = false;
              return function() {
                if (called)
                  return;
                called = true;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                callback.apply(this, args);
              };
            }
            function noop() {
            }
            function isRequest(stream) {
              return stream.setHeader && typeof stream.abort === "function";
            }
            function eos(stream, opts, callback) {
              if (typeof opts === "function")
                return eos(stream, null, opts);
              if (!opts)
                opts = {};
              callback = once(callback || noop);
              var readable = opts.readable || opts.readable !== false && stream.readable;
              var writable = opts.writable || opts.writable !== false && stream.writable;
              var onlegacyfinish = function onlegacyfinish2() {
                if (!stream.writable)
                  onfinish();
              };
              var writableEnded = stream._writableState && stream._writableState.finished;
              var onfinish = function onfinish2() {
                writable = false;
                writableEnded = true;
                if (!readable)
                  callback.call(stream);
              };
              var readableEnded = stream._readableState && stream._readableState.endEmitted;
              var onend = function onend2() {
                readable = false;
                readableEnded = true;
                if (!writable)
                  callback.call(stream);
              };
              var onerror = function onerror2(err) {
                callback.call(stream, err);
              };
              var onclose = function onclose2() {
                var err;
                if (readable && !readableEnded) {
                  if (!stream._readableState || !stream._readableState.ended)
                    err = new ERR_STREAM_PREMATURE_CLOSE();
                  return callback.call(stream, err);
                }
                if (writable && !writableEnded) {
                  if (!stream._writableState || !stream._writableState.ended)
                    err = new ERR_STREAM_PREMATURE_CLOSE();
                  return callback.call(stream, err);
                }
              };
              var onrequest = function onrequest2() {
                stream.req.on("finish", onfinish);
              };
              if (isRequest(stream)) {
                stream.on("complete", onfinish);
                stream.on("abort", onclose);
                if (stream.req)
                  onrequest();
                else
                  stream.on("request", onrequest);
              } else if (writable && !stream._writableState) {
                stream.on("end", onlegacyfinish);
                stream.on("close", onlegacyfinish);
              }
              stream.on("end", onend);
              stream.on("finish", onfinish);
              if (opts.error !== false)
                stream.on("error", onerror);
              stream.on("close", onclose);
              return function() {
                stream.removeListener("complete", onfinish);
                stream.removeListener("abort", onclose);
                stream.removeListener("request", onrequest);
                if (stream.req)
                  stream.req.removeListener("finish", onfinish);
                stream.removeListener("end", onlegacyfinish);
                stream.removeListener("close", onlegacyfinish);
                stream.removeListener("finish", onfinish);
                stream.removeListener("end", onend);
                stream.removeListener("error", onerror);
                stream.removeListener("close", onclose);
              };
            }
            module2.exports = eos;
          },
          7766: (module2) => {
            module2.exports = function() {
              throw new Error("Readable.from is not available in the browser");
            };
          },
          5879: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var eos;
            function once(callback) {
              var called = false;
              return function() {
                if (called)
                  return;
                called = true;
                callback.apply(void 0, arguments);
              };
            }
            var _require$codes = __webpack_require__2(352).codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
            function noop(err) {
              if (err)
                throw err;
            }
            function isRequest(stream) {
              return stream.setHeader && typeof stream.abort === "function";
            }
            function destroyer(stream, reading, writing, callback) {
              callback = once(callback);
              var closed = false;
              stream.on("close", function() {
                closed = true;
              });
              if (eos === void 0)
                eos = __webpack_require__2(6591);
              eos(stream, {
                readable: reading,
                writable: writing
              }, function(err) {
                if (err)
                  return callback(err);
                closed = true;
                callback();
              });
              var destroyed = false;
              return function(err) {
                if (closed)
                  return;
                if (destroyed)
                  return;
                destroyed = true;
                if (isRequest(stream))
                  return stream.abort();
                if (typeof stream.destroy === "function")
                  return stream.destroy();
                callback(err || new ERR_STREAM_DESTROYED("pipe"));
              };
            }
            function call(fn) {
              fn();
            }
            function pipe(from, to) {
              return from.pipe(to);
            }
            function popCallback(streams) {
              if (!streams.length)
                return noop;
              if (typeof streams[streams.length - 1] !== "function")
                return noop;
              return streams.pop();
            }
            function pipeline() {
              for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
                streams[_key] = arguments[_key];
              }
              var callback = popCallback(streams);
              if (Array.isArray(streams[0]))
                streams = streams[0];
              if (streams.length < 2) {
                throw new ERR_MISSING_ARGS("streams");
              }
              var error;
              var destroys = streams.map(function(stream, i) {
                var reading = i < streams.length - 1;
                var writing = i > 0;
                return destroyer(stream, reading, writing, function(err) {
                  if (!error)
                    error = err;
                  if (err)
                    destroys.forEach(call);
                  if (reading)
                    return;
                  destroys.forEach(call);
                  callback(error);
                });
              });
              return streams.reduce(pipe);
            }
            module2.exports = pipeline;
          },
          9604: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var ERR_INVALID_OPT_VALUE = __webpack_require__2(352).codes.ERR_INVALID_OPT_VALUE;
            function highWaterMarkFrom(options2, isDuplex, duplexKey) {
              return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
            }
            function getHighWaterMark(state, options2, duplexKey, isDuplex) {
              var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
              if (hwm != null) {
                if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                  var name = isDuplex ? duplexKey : "highWaterMark";
                  throw new ERR_INVALID_OPT_VALUE(name, hwm);
                }
                return Math.floor(hwm);
              }
              return state.objectMode ? 16 : 16 * 1024;
            }
            module2.exports = {
              getHighWaterMark
            };
          },
          1773: (module2, __unused_webpack_exports, __webpack_require__2) => {
            module2.exports = __webpack_require__2(1590).EventEmitter;
          },
          9970: (module2, exports3, __webpack_require__2) => {
            exports3 = module2.exports = __webpack_require__2(8817);
            exports3.Stream = exports3;
            exports3.Readable = exports3;
            exports3.Writable = __webpack_require__2(2248);
            exports3.Duplex = __webpack_require__2(3653);
            exports3.Transform = __webpack_require__2(5500);
            exports3.PassThrough = __webpack_require__2(8210);
            exports3.finished = __webpack_require__2(6591);
            exports3.pipeline = __webpack_require__2(5879);
          },
          3311: (module2, exports3, __webpack_require__2) => {
            var buffer = __webpack_require__2(5851);
            var Buffer2 = buffer.Buffer;
            function copyProps(src, dst) {
              for (var key in src) {
                dst[key] = src[key];
              }
            }
            if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
              module2.exports = buffer;
            } else {
              copyProps(buffer, exports3);
              exports3.Buffer = SafeBuffer;
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
              return Buffer2(arg, encodingOrOffset, length);
            }
            SafeBuffer.prototype = Object.create(Buffer2.prototype);
            copyProps(Buffer2, SafeBuffer);
            SafeBuffer.from = function(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                throw new TypeError("Argument must not be a number");
              }
              return Buffer2(arg, encodingOrOffset, length);
            };
            SafeBuffer.alloc = function(size, fill, encoding) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              var buf = Buffer2(size);
              if (fill !== void 0) {
                if (typeof encoding === "string") {
                  buf.fill(fill, encoding);
                } else {
                  buf.fill(fill);
                }
              } else {
                buf.fill(0);
              }
              return buf;
            };
            SafeBuffer.allocUnsafe = function(size) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              return Buffer2(size);
            };
            SafeBuffer.allocUnsafeSlow = function(size) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              return buffer.SlowBuffer(size);
            };
          },
          5262: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var ClientRequest = __webpack_require__2(69);
            var response = __webpack_require__2(4089);
            var extend = __webpack_require__2(2786);
            var statusCodes = __webpack_require__2(1403);
            var url = __webpack_require__2(3149);
            var http = exports3;
            http.request = function(opts, cb) {
              if (typeof opts === "string")
                opts = url.parse(opts);
              else
                opts = extend(opts);
              var defaultProtocol = __webpack_require__2.g.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
              var protocol2 = opts.protocol || defaultProtocol;
              var host = opts.hostname || opts.host;
              var port = opts.port;
              var path = opts.path || "/";
              if (host && host.indexOf(":") !== -1)
                host = "[" + host + "]";
              opts.url = (host ? protocol2 + "//" + host : "") + (port ? ":" + port : "") + path;
              opts.method = (opts.method || "GET").toUpperCase();
              opts.headers = opts.headers || {};
              var req = new ClientRequest(opts);
              if (cb)
                req.on("response", cb);
              return req;
            };
            http.get = function get(opts, cb) {
              var req = http.request(opts, cb);
              req.end();
              return req;
            };
            http.ClientRequest = ClientRequest;
            http.IncomingMessage = response.IncomingMessage;
            http.Agent = function() {
            };
            http.Agent.defaultMaxSockets = 4;
            http.globalAgent = new http.Agent();
            http.STATUS_CODES = statusCodes;
            http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
          },
          5757: (__unused_webpack_module, exports3, __webpack_require__2) => {
            exports3.fetch = isFunction(__webpack_require__2.g.fetch) && isFunction(__webpack_require__2.g.ReadableStream);
            exports3.writableStream = isFunction(__webpack_require__2.g.WritableStream);
            exports3.abortController = isFunction(__webpack_require__2.g.AbortController);
            var xhr;
            function getXHR() {
              if (xhr !== void 0)
                return xhr;
              if (__webpack_require__2.g.XMLHttpRequest) {
                xhr = new __webpack_require__2.g.XMLHttpRequest();
                try {
                  xhr.open("GET", __webpack_require__2.g.XDomainRequest ? "/" : "https://example.com");
                } catch (e) {
                  xhr = null;
                }
              } else {
                xhr = null;
              }
              return xhr;
            }
            function checkTypeSupport(type) {
              var xhr2 = getXHR();
              if (!xhr2)
                return false;
              try {
                xhr2.responseType = type;
                return xhr2.responseType === type;
              } catch (e) {
              }
              return false;
            }
            exports3.arraybuffer = exports3.fetch || checkTypeSupport("arraybuffer");
            exports3.msstream = !exports3.fetch && checkTypeSupport("ms-stream");
            exports3.mozchunkedarraybuffer = !exports3.fetch && checkTypeSupport("moz-chunked-arraybuffer");
            exports3.overrideMimeType = exports3.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
            function isFunction(value) {
              return typeof value === "function";
            }
            xhr = null;
          },
          69: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            var process2 = __webpack_require__2(2790);
            var capability = __webpack_require__2(5757);
            var inherits = __webpack_require__2(5153);
            var response = __webpack_require__2(4089);
            var stream = __webpack_require__2(9970);
            var IncomingMessage = response.IncomingMessage;
            var rStates = response.readyStates;
            function decideMode(preferBinary, useFetch) {
              if (capability.fetch && useFetch) {
                return "fetch";
              } else if (capability.mozchunkedarraybuffer) {
                return "moz-chunked-arraybuffer";
              } else if (capability.msstream) {
                return "ms-stream";
              } else if (capability.arraybuffer && preferBinary) {
                return "arraybuffer";
              } else {
                return "text";
              }
            }
            var ClientRequest = module2.exports = function(opts) {
              var self2 = this;
              stream.Writable.call(self2);
              self2._opts = opts;
              self2._body = [];
              self2._headers = {};
              if (opts.auth)
                self2.setHeader("Authorization", "Basic " + Buffer2.from(opts.auth).toString("base64"));
              Object.keys(opts.headers).forEach(function(name) {
                self2.setHeader(name, opts.headers[name]);
              });
              var preferBinary;
              var useFetch = true;
              if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
                useFetch = false;
                preferBinary = true;
              } else if (opts.mode === "prefer-streaming") {
                preferBinary = false;
              } else if (opts.mode === "allow-wrong-content-type") {
                preferBinary = !capability.overrideMimeType;
              } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
                preferBinary = true;
              } else {
                throw new Error("Invalid value for opts.mode");
              }
              self2._mode = decideMode(preferBinary, useFetch);
              self2._fetchTimer = null;
              self2._socketTimeout = null;
              self2._socketTimer = null;
              self2.on("finish", function() {
                self2._onFinish();
              });
            };
            inherits(ClientRequest, stream.Writable);
            ClientRequest.prototype.setHeader = function(name, value) {
              var self2 = this;
              var lowerName = name.toLowerCase();
              if (unsafeHeaders.indexOf(lowerName) !== -1)
                return;
              self2._headers[lowerName] = {
                name,
                value
              };
            };
            ClientRequest.prototype.getHeader = function(name) {
              var header = this._headers[name.toLowerCase()];
              if (header)
                return header.value;
              return null;
            };
            ClientRequest.prototype.removeHeader = function(name) {
              var self2 = this;
              delete self2._headers[name.toLowerCase()];
            };
            ClientRequest.prototype._onFinish = function() {
              var self2 = this;
              if (self2._destroyed)
                return;
              var opts = self2._opts;
              if ("timeout" in opts && opts.timeout !== 0) {
                self2.setTimeout(opts.timeout);
              }
              var headersObj = self2._headers;
              var body = null;
              if (opts.method !== "GET" && opts.method !== "HEAD") {
                body = new Blob(self2._body, {
                  type: (headersObj["content-type"] || {}).value || ""
                });
              }
              var headersList = [];
              Object.keys(headersObj).forEach(function(keyName) {
                var name = headersObj[keyName].name;
                var value = headersObj[keyName].value;
                if (Array.isArray(value)) {
                  value.forEach(function(v) {
                    headersList.push([name, v]);
                  });
                } else {
                  headersList.push([name, value]);
                }
              });
              if (self2._mode === "fetch") {
                var signal = null;
                if (capability.abortController) {
                  var controller = new AbortController();
                  signal = controller.signal;
                  self2._fetchAbortController = controller;
                  if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                    self2._fetchTimer = __webpack_require__2.g.setTimeout(function() {
                      self2.emit("requestTimeout");
                      if (self2._fetchAbortController)
                        self2._fetchAbortController.abort();
                    }, opts.requestTimeout);
                  }
                }
                __webpack_require__2.g.fetch(self2._opts.url, {
                  method: self2._opts.method,
                  headers: headersList,
                  body: body || void 0,
                  mode: "cors",
                  credentials: opts.withCredentials ? "include" : "same-origin",
                  signal
                }).then(function(response2) {
                  self2._fetchResponse = response2;
                  self2._resetTimers(false);
                  self2._connect();
                }, function(reason) {
                  self2._resetTimers(true);
                  if (!self2._destroyed)
                    self2.emit("error", reason);
                });
              } else {
                var xhr = self2._xhr = new __webpack_require__2.g.XMLHttpRequest();
                try {
                  xhr.open(self2._opts.method, self2._opts.url, true);
                } catch (err) {
                  process2.nextTick(function() {
                    self2.emit("error", err);
                  });
                  return;
                }
                if ("responseType" in xhr)
                  xhr.responseType = self2._mode;
                if ("withCredentials" in xhr)
                  xhr.withCredentials = !!opts.withCredentials;
                if (self2._mode === "text" && "overrideMimeType" in xhr)
                  xhr.overrideMimeType("text/plain; charset=x-user-defined");
                if ("requestTimeout" in opts) {
                  xhr.timeout = opts.requestTimeout;
                  xhr.ontimeout = function() {
                    self2.emit("requestTimeout");
                  };
                }
                headersList.forEach(function(header) {
                  xhr.setRequestHeader(header[0], header[1]);
                });
                self2._response = null;
                xhr.onreadystatechange = function() {
                  switch (xhr.readyState) {
                    case rStates.LOADING:
                    case rStates.DONE:
                      self2._onXHRProgress();
                      break;
                  }
                };
                if (self2._mode === "moz-chunked-arraybuffer") {
                  xhr.onprogress = function() {
                    self2._onXHRProgress();
                  };
                }
                xhr.onerror = function() {
                  if (self2._destroyed)
                    return;
                  self2._resetTimers(true);
                  self2.emit("error", new Error("XHR error"));
                };
                try {
                  xhr.send(body);
                } catch (err) {
                  process2.nextTick(function() {
                    self2.emit("error", err);
                  });
                  return;
                }
              }
            };
            function statusValid(xhr) {
              try {
                var status = xhr.status;
                return status !== null && status !== 0;
              } catch (e) {
                return false;
              }
            }
            ClientRequest.prototype._onXHRProgress = function() {
              var self2 = this;
              self2._resetTimers(false);
              if (!statusValid(self2._xhr) || self2._destroyed)
                return;
              if (!self2._response)
                self2._connect();
              self2._response._onXHRProgress(self2._resetTimers.bind(self2));
            };
            ClientRequest.prototype._connect = function() {
              var self2 = this;
              if (self2._destroyed)
                return;
              self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
              self2._response.on("error", function(err) {
                self2.emit("error", err);
              });
              self2.emit("response", self2._response);
            };
            ClientRequest.prototype._write = function(chunk, encoding, cb) {
              var self2 = this;
              self2._body.push(chunk);
              cb();
            };
            ClientRequest.prototype._resetTimers = function(done) {
              var self2 = this;
              __webpack_require__2.g.clearTimeout(self2._socketTimer);
              self2._socketTimer = null;
              if (done) {
                __webpack_require__2.g.clearTimeout(self2._fetchTimer);
                self2._fetchTimer = null;
              } else if (self2._socketTimeout) {
                self2._socketTimer = __webpack_require__2.g.setTimeout(function() {
                  self2.emit("timeout");
                }, self2._socketTimeout);
              }
            };
            ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
              var self2 = this;
              self2._destroyed = true;
              self2._resetTimers(true);
              if (self2._response)
                self2._response._destroyed = true;
              if (self2._xhr)
                self2._xhr.abort();
              else if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
              if (err)
                self2.emit("error", err);
            };
            ClientRequest.prototype.end = function(data, encoding, cb) {
              var self2 = this;
              if (typeof data === "function") {
                cb = data;
                data = void 0;
              }
              stream.Writable.prototype.end.call(self2, data, encoding, cb);
            };
            ClientRequest.prototype.setTimeout = function(timeout, cb) {
              var self2 = this;
              if (cb)
                self2.once("timeout", cb);
              self2._socketTimeout = timeout;
              self2._resetTimers(false);
            };
            ClientRequest.prototype.flushHeaders = function() {
            };
            ClientRequest.prototype.setNoDelay = function() {
            };
            ClientRequest.prototype.setSocketKeepAlive = function() {
            };
            var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
          },
          4089: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var process2 = __webpack_require__2(2790);
            var Buffer2 = __webpack_require__2(5851)["Buffer"];
            __webpack_require__2(9494);
            var capability = __webpack_require__2(5757);
            var inherits = __webpack_require__2(5153);
            var stream = __webpack_require__2(9970);
            var rStates = exports3.readyStates = {
              UNSENT: 0,
              OPENED: 1,
              HEADERS_RECEIVED: 2,
              LOADING: 3,
              DONE: 4
            };
            var IncomingMessage = exports3.IncomingMessage = function(xhr, response, mode, resetTimers) {
              var self2 = this;
              stream.Readable.call(self2);
              self2._mode = mode;
              self2.headers = {};
              self2.rawHeaders = [];
              self2.trailers = {};
              self2.rawTrailers = [];
              self2.on("end", function() {
                process2.nextTick(function() {
                  self2.emit("close");
                });
              });
              if (mode === "fetch") {
                let read2 = function() {
                  reader.read().then(function(result) {
                    if (self2._destroyed)
                      return;
                    resetTimers(result.done);
                    if (result.done) {
                      self2.push(null);
                      return;
                    }
                    self2.push(Buffer2.from(result.value));
                    read2();
                  }).catch(function(err) {
                    resetTimers(true);
                    if (!self2._destroyed)
                      self2.emit("error", err);
                  });
                };
                var read = read2;
                self2._fetchResponse = response;
                self2.url = response.url;
                self2.statusCode = response.status;
                self2.statusMessage = response.statusText;
                response.headers.forEach(function(header, key) {
                  self2.headers[key.toLowerCase()] = header;
                  self2.rawHeaders.push(key, header);
                });
                if (capability.writableStream) {
                  var writable = new WritableStream({
                    write: function(chunk) {
                      resetTimers(false);
                      return new Promise(function(resolve2, reject) {
                        if (self2._destroyed) {
                          reject();
                        } else if (self2.push(Buffer2.from(chunk))) {
                          resolve2();
                        } else {
                          self2._resumeFetch = resolve2;
                        }
                      });
                    },
                    close: function() {
                      resetTimers(true);
                      if (!self2._destroyed)
                        self2.push(null);
                    },
                    abort: function(err) {
                      resetTimers(true);
                      if (!self2._destroyed)
                        self2.emit("error", err);
                    }
                  });
                  try {
                    response.body.pipeTo(writable).catch(function(err) {
                      resetTimers(true);
                      if (!self2._destroyed)
                        self2.emit("error", err);
                    });
                    return;
                  } catch (e) {
                  }
                }
                var reader = response.body.getReader();
                read2();
              } else {
                self2._xhr = xhr;
                self2._pos = 0;
                self2.url = xhr.responseURL;
                self2.statusCode = xhr.status;
                self2.statusMessage = xhr.statusText;
                var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                headers.forEach(function(header) {
                  var matches = header.match(/^([^:]+):\s*(.*)/);
                  if (matches) {
                    var key = matches[1].toLowerCase();
                    if (key === "set-cookie") {
                      if (self2.headers[key] === void 0) {
                        self2.headers[key] = [];
                      }
                      self2.headers[key].push(matches[2]);
                    } else if (self2.headers[key] !== void 0) {
                      self2.headers[key] += ", " + matches[2];
                    } else {
                      self2.headers[key] = matches[2];
                    }
                    self2.rawHeaders.push(matches[1], matches[2]);
                  }
                });
                self2._charset = "x-user-defined";
                if (!capability.overrideMimeType) {
                  var mimeType = self2.rawHeaders["mime-type"];
                  if (mimeType) {
                    var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                    if (charsetMatch) {
                      self2._charset = charsetMatch[1].toLowerCase();
                    }
                  }
                  if (!self2._charset)
                    self2._charset = "utf-8";
                }
              }
            };
            inherits(IncomingMessage, stream.Readable);
            IncomingMessage.prototype._read = function() {
              var self2 = this;
              var resolve2 = self2._resumeFetch;
              if (resolve2) {
                self2._resumeFetch = null;
                resolve2();
              }
            };
            IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
              var self2 = this;
              var xhr = self2._xhr;
              var response = null;
              switch (self2._mode) {
                case "text":
                  response = xhr.responseText;
                  if (response.length > self2._pos) {
                    var newData = response.substr(self2._pos);
                    if (self2._charset === "x-user-defined") {
                      var buffer = Buffer2.alloc(newData.length);
                      for (var i = 0; i < newData.length; i++)
                        buffer[i] = newData.charCodeAt(i) & 255;
                      self2.push(buffer);
                    } else {
                      self2.push(newData, self2._charset);
                    }
                    self2._pos = response.length;
                  }
                  break;
                case "arraybuffer":
                  if (xhr.readyState !== rStates.DONE || !xhr.response)
                    break;
                  response = xhr.response;
                  self2.push(Buffer2.from(new Uint8Array(response)));
                  break;
                case "moz-chunked-arraybuffer":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING || !response)
                    break;
                  self2.push(Buffer2.from(new Uint8Array(response)));
                  break;
                case "ms-stream":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING)
                    break;
                  var reader = new __webpack_require__2.g.MSStreamReader();
                  reader.onprogress = function() {
                    if (reader.result.byteLength > self2._pos) {
                      self2.push(Buffer2.from(new Uint8Array(reader.result.slice(self2._pos))));
                      self2._pos = reader.result.byteLength;
                    }
                  };
                  reader.onload = function() {
                    resetTimers(true);
                    self2.push(null);
                  };
                  reader.readAsArrayBuffer(response);
                  break;
              }
              if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
                resetTimers(true);
                self2.push(null);
              }
            };
          },
          1907: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            var Buffer2 = __webpack_require__2(3311).Buffer;
            var isEncoding = Buffer2.isEncoding || function(encoding) {
              encoding = "" + encoding;
              switch (encoding && encoding.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                  return true;
                default:
                  return false;
              }
            };
            function _normalizeEncoding(enc) {
              if (!enc)
                return "utf8";
              var retried;
              while (true) {
                switch (enc) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return enc;
                  default:
                    if (retried)
                      return;
                    enc = ("" + enc).toLowerCase();
                    retried = true;
                }
              }
            }
            ;
            function normalizeEncoding(enc) {
              var nenc = _normalizeEncoding(enc);
              if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
                throw new Error("Unknown encoding: " + enc);
              return nenc || enc;
            }
            exports3.StringDecoder = StringDecoder;
            function StringDecoder(encoding) {
              this.encoding = normalizeEncoding(encoding);
              var nb;
              switch (this.encoding) {
                case "utf16le":
                  this.text = utf16Text;
                  this.end = utf16End;
                  nb = 4;
                  break;
                case "utf8":
                  this.fillLast = utf8FillLast;
                  nb = 4;
                  break;
                case "base64":
                  this.text = base64Text;
                  this.end = base64End;
                  nb = 3;
                  break;
                default:
                  this.write = simpleWrite;
                  this.end = simpleEnd;
                  return;
              }
              this.lastNeed = 0;
              this.lastTotal = 0;
              this.lastChar = Buffer2.allocUnsafe(nb);
            }
            StringDecoder.prototype.write = function(buf) {
              if (buf.length === 0)
                return "";
              var r;
              var i;
              if (this.lastNeed) {
                r = this.fillLast(buf);
                if (r === void 0)
                  return "";
                i = this.lastNeed;
                this.lastNeed = 0;
              } else {
                i = 0;
              }
              if (i < buf.length)
                return r ? r + this.text(buf, i) : this.text(buf, i);
              return r || "";
            };
            StringDecoder.prototype.end = utf8End;
            StringDecoder.prototype.text = utf8Text;
            StringDecoder.prototype.fillLast = function(buf) {
              if (this.lastNeed <= buf.length) {
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                return this.lastChar.toString(this.encoding, 0, this.lastTotal);
              }
              buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
              this.lastNeed -= buf.length;
            };
            function utf8CheckByte(byte) {
              if (byte <= 127)
                return 0;
              else if (byte >> 5 === 6)
                return 2;
              else if (byte >> 4 === 14)
                return 3;
              else if (byte >> 3 === 30)
                return 4;
              return byte >> 6 === 2 ? -1 : -2;
            }
            function utf8CheckIncomplete(self2, buf, i) {
              var j = buf.length - 1;
              if (j < i)
                return 0;
              var nb = utf8CheckByte(buf[j]);
              if (nb >= 0) {
                if (nb > 0)
                  self2.lastNeed = nb - 1;
                return nb;
              }
              if (--j < i || nb === -2)
                return 0;
              nb = utf8CheckByte(buf[j]);
              if (nb >= 0) {
                if (nb > 0)
                  self2.lastNeed = nb - 2;
                return nb;
              }
              if (--j < i || nb === -2)
                return 0;
              nb = utf8CheckByte(buf[j]);
              if (nb >= 0) {
                if (nb > 0) {
                  if (nb === 2)
                    nb = 0;
                  else
                    self2.lastNeed = nb - 3;
                }
                return nb;
              }
              return 0;
            }
            function utf8CheckExtraBytes(self2, buf, p) {
              if ((buf[0] & 192) !== 128) {
                self2.lastNeed = 0;
                return "\uFFFD";
              }
              if (self2.lastNeed > 1 && buf.length > 1) {
                if ((buf[1] & 192) !== 128) {
                  self2.lastNeed = 1;
                  return "\uFFFD";
                }
                if (self2.lastNeed > 2 && buf.length > 2) {
                  if ((buf[2] & 192) !== 128) {
                    self2.lastNeed = 2;
                    return "\uFFFD";
                  }
                }
              }
            }
            function utf8FillLast(buf) {
              var p = this.lastTotal - this.lastNeed;
              var r = utf8CheckExtraBytes(this, buf, p);
              if (r !== void 0)
                return r;
              if (this.lastNeed <= buf.length) {
                buf.copy(this.lastChar, p, 0, this.lastNeed);
                return this.lastChar.toString(this.encoding, 0, this.lastTotal);
              }
              buf.copy(this.lastChar, p, 0, buf.length);
              this.lastNeed -= buf.length;
            }
            function utf8Text(buf, i) {
              var total = utf8CheckIncomplete(this, buf, i);
              if (!this.lastNeed)
                return buf.toString("utf8", i);
              this.lastTotal = total;
              var end = buf.length - (total - this.lastNeed);
              buf.copy(this.lastChar, 0, end);
              return buf.toString("utf8", i, end);
            }
            function utf8End(buf) {
              var r = buf && buf.length ? this.write(buf) : "";
              if (this.lastNeed)
                return r + "\uFFFD";
              return r;
            }
            function utf16Text(buf, i) {
              if ((buf.length - i) % 2 === 0) {
                var r = buf.toString("utf16le", i);
                if (r) {
                  var c = r.charCodeAt(r.length - 1);
                  if (c >= 55296 && c <= 56319) {
                    this.lastNeed = 2;
                    this.lastTotal = 4;
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                    return r.slice(0, -1);
                  }
                }
                return r;
              }
              this.lastNeed = 1;
              this.lastTotal = 2;
              this.lastChar[0] = buf[buf.length - 1];
              return buf.toString("utf16le", i, buf.length - 1);
            }
            function utf16End(buf) {
              var r = buf && buf.length ? this.write(buf) : "";
              if (this.lastNeed) {
                var end = this.lastTotal - this.lastNeed;
                return r + this.lastChar.toString("utf16le", 0, end);
              }
              return r;
            }
            function base64Text(buf, i) {
              var n = (buf.length - i) % 3;
              if (n === 0)
                return buf.toString("base64", i);
              this.lastNeed = 3 - n;
              this.lastTotal = 3;
              if (n === 1) {
                this.lastChar[0] = buf[buf.length - 1];
              } else {
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
              }
              return buf.toString("base64", i, buf.length - n);
            }
            function base64End(buf) {
              var r = buf && buf.length ? this.write(buf) : "";
              if (this.lastNeed)
                return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
              return r;
            }
            function simpleWrite(buf) {
              return buf.toString(this.encoding);
            }
            function simpleEnd(buf) {
              return buf && buf.length ? this.write(buf) : "";
            }
          },
          1749: function(module2, exports3, __webpack_require__2) {
            module2 = __webpack_require__2.nmd(module2);
            var __WEBPACK_AMD_DEFINE_RESULT__;
            ;
            (function(root) {
              var freeExports = exports3 && !exports3.nodeType && exports3;
              var freeModule = module2 && !module2.nodeType && module2;
              var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g;
              if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                root = freeGlobal;
              }
              var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                "overflow": "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
              }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
              function error(type) {
                throw RangeError(errors[type]);
              }
              function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array[length]);
                }
                return result;
              }
              function mapDomain(string, fn) {
                var parts2 = string.split("@");
                var result = "";
                if (parts2.length > 1) {
                  result = parts2[0] + "@";
                  string = parts2[1];
                }
                string = string.replace(regexSeparators, ".");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
              }
              function ucs2decode(string) {
                var output = [], counter = 0, length = string.length, value, extra;
                while (counter < length) {
                  value = string.charCodeAt(counter++);
                  if (value >= 55296 && value <= 56319 && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                      output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                    } else {
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }
              function ucs2encode(array) {
                return map(array, function(value) {
                  var output = "";
                  if (value > 65535) {
                    value -= 65536;
                    output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                    value = 56320 | value & 1023;
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join("");
              }
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }
              function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
              }
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
              }
              function decode(input) {
                var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }
                for (j = 0; j < basic; ++j) {
                  if (input.charCodeAt(j) >= 128) {
                    error("not-basic");
                  }
                  output.push(input.charCodeAt(j));
                }
                for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                  for (oldi = i, w = 1, k = base; ; k += base) {
                    if (index >= inputLength) {
                      error("invalid-input");
                    }
                    digit = basicToDigit(input.charCodeAt(index++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                      error("overflow");
                    }
                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (digit < t) {
                      break;
                    }
                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                      error("overflow");
                    }
                    w *= baseMinusT;
                  }
                  out = output.length + 1;
                  bias = adapt(i - oldi, out, oldi == 0);
                  if (floor(i / out) > maxInt - n) {
                    error("overflow");
                  }
                  n += floor(i / out);
                  i %= out;
                  output.splice(i++, 0, n);
                }
                return ucs2encode(output);
              }
              function encode(input) {
                var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                input = ucs2decode(input);
                inputLength = input.length;
                n = initialN;
                delta = 0;
                bias = initialBias;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < 128) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) {
                  output.push(delimiter);
                }
                while (handledCPCount < inputLength) {
                  for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue;
                    }
                  }
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error("overflow");
                  }
                  delta += (m - n) * handledCPCountPlusOne;
                  n = m;
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < n && ++delta > maxInt) {
                      error("overflow");
                    }
                    if (currentValue == n) {
                      for (q = delta, k = base; ; k += base) {
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                          break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = floor(qMinusT / baseMinusT);
                      }
                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                      delta = 0;
                      ++handledCPCount;
                    }
                  }
                  ++delta;
                  ++n;
                }
                return output.join("");
              }
              function toUnicode(input) {
                return mapDomain(input, function(string) {
                  return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                });
              }
              function toASCII(input) {
                return mapDomain(input, function(string) {
                  return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                });
              }
              punycode = {
                "version": "1.3.2",
                "ucs2": {
                  "decode": ucs2decode,
                  "encode": ucs2encode
                },
                "decode": decode,
                "encode": encode,
                "toASCII": toASCII,
                "toUnicode": toUnicode
              };
              if (true) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                  return punycode;
                }.call(exports3, __webpack_require__2, exports3, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
            })(this);
          },
          3149: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            var punycode = __webpack_require__2(1749);
            var util = __webpack_require__2(4249);
            exports3.parse = urlParse;
            exports3.resolve = urlResolve;
            exports3.resolveObject = urlResolveObject;
            exports3.format = urlFormat;
            exports3.Url = Url;
            function Url() {
              this.protocol = null;
              this.slashes = null;
              this.auth = null;
              this.host = null;
              this.port = null;
              this.hostname = null;
              this.hash = null;
              this.search = null;
              this.query = null;
              this.pathname = null;
              this.path = null;
              this.href = null;
            }
            var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
              "javascript": true,
              "javascript:": true
            }, hostlessProtocol = {
              "javascript": true,
              "javascript:": true
            }, slashedProtocol = {
              "http": true,
              "https": true,
              "ftp": true,
              "gopher": true,
              "file": true,
              "http:": true,
              "https:": true,
              "ftp:": true,
              "gopher:": true,
              "file:": true
            }, querystring = __webpack_require__2(4126);
            function urlParse(url, parseQueryString, slashesDenoteHost) {
              if (url && util.isObject(url) && url instanceof Url)
                return url;
              var u = new Url();
              u.parse(url, parseQueryString, slashesDenoteHost);
              return u;
            }
            Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
              if (!util.isString(url)) {
                throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
              }
              var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
              uSplit[0] = uSplit[0].replace(slashRegex, "/");
              url = uSplit.join(splitter);
              var rest = url;
              rest = rest.trim();
              if (!slashesDenoteHost && url.split("#").length === 1) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) {
                  this.path = rest;
                  this.href = rest;
                  this.pathname = simplePath[1];
                  if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                      this.query = querystring.parse(this.search.substr(1));
                    } else {
                      this.query = this.search.substr(1);
                    }
                  } else if (parseQueryString) {
                    this.search = "";
                    this.query = {};
                  }
                  return this;
                }
              }
              var proto = protocolPattern.exec(rest);
              if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                this.protocol = lowerProto;
                rest = rest.substr(proto.length);
              }
              if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === "//";
                if (slashes && !(proto && hostlessProtocol[proto])) {
                  rest = rest.substr(2);
                  this.slashes = true;
                }
              }
              if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                var hostEnd = -1;
                for (var i = 0; i < hostEndingChars.length; i++) {
                  var hec = rest.indexOf(hostEndingChars[i]);
                  if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                    hostEnd = hec;
                }
                var auth, atSign;
                if (hostEnd === -1) {
                  atSign = rest.lastIndexOf("@");
                } else {
                  atSign = rest.lastIndexOf("@", hostEnd);
                }
                if (atSign !== -1) {
                  auth = rest.slice(0, atSign);
                  rest = rest.slice(atSign + 1);
                  this.auth = decodeURIComponent(auth);
                }
                hostEnd = -1;
                for (var i = 0; i < nonHostChars.length; i++) {
                  var hec = rest.indexOf(nonHostChars[i]);
                  if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                    hostEnd = hec;
                }
                if (hostEnd === -1)
                  hostEnd = rest.length;
                this.host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);
                this.parseHost();
                this.hostname = this.hostname || "";
                var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                if (!ipv6Hostname) {
                  var hostparts = this.hostname.split(/\./);
                  for (var i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part)
                      continue;
                    if (!part.match(hostnamePartPattern)) {
                      var newpart = "";
                      for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                          newpart += "x";
                        } else {
                          newpart += part[j];
                        }
                      }
                      if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                          validParts.push(bit[1]);
                          notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                          rest = "/" + notHost.join(".") + rest;
                        }
                        this.hostname = validParts.join(".");
                        break;
                      }
                    }
                  }
                }
                if (this.hostname.length > hostnameMaxLen) {
                  this.hostname = "";
                } else {
                  this.hostname = this.hostname.toLowerCase();
                }
                if (!ipv6Hostname) {
                  this.hostname = punycode.toASCII(this.hostname);
                }
                var p = this.port ? ":" + this.port : "";
                var h = this.hostname || "";
                this.host = h + p;
                this.href += this.host;
                if (ipv6Hostname) {
                  this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                  if (rest[0] !== "/") {
                    rest = "/" + rest;
                  }
                }
              }
              if (!unsafeProtocol[lowerProto]) {
                for (var i = 0, l = autoEscape.length; i < l; i++) {
                  var ae = autoEscape[i];
                  if (rest.indexOf(ae) === -1)
                    continue;
                  var esc = encodeURIComponent(ae);
                  if (esc === ae) {
                    esc = escape(ae);
                  }
                  rest = rest.split(ae).join(esc);
                }
              }
              var hash = rest.indexOf("#");
              if (hash !== -1) {
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
              }
              var qm = rest.indexOf("?");
              if (qm !== -1) {
                this.search = rest.substr(qm);
                this.query = rest.substr(qm + 1);
                if (parseQueryString) {
                  this.query = querystring.parse(this.query);
                }
                rest = rest.slice(0, qm);
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              if (rest)
                this.pathname = rest;
              if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = "/";
              }
              if (this.pathname || this.search) {
                var p = this.pathname || "";
                var s = this.search || "";
                this.path = p + s;
              }
              this.href = this.format();
              return this;
            };
            function urlFormat(obj) {
              if (util.isString(obj))
                obj = urlParse(obj);
              if (!(obj instanceof Url))
                return Url.prototype.format.call(obj);
              return obj.format();
            }
            Url.prototype.format = function() {
              var auth = this.auth || "";
              if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ":");
                auth += "@";
              }
              var protocol2 = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
              if (this.host) {
                host = auth + this.host;
              } else if (this.hostname) {
                host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                if (this.port) {
                  host += ":" + this.port;
                }
              }
              if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                query = querystring.stringify(this.query);
              }
              var search = this.search || query && "?" + query || "";
              if (protocol2 && protocol2.substr(-1) !== ":")
                protocol2 += ":";
              if (this.slashes || (!protocol2 || slashedProtocol[protocol2]) && host !== false) {
                host = "//" + (host || "");
                if (pathname && pathname.charAt(0) !== "/")
                  pathname = "/" + pathname;
              } else if (!host) {
                host = "";
              }
              if (hash && hash.charAt(0) !== "#")
                hash = "#" + hash;
              if (search && search.charAt(0) !== "?")
                search = "?" + search;
              pathname = pathname.replace(/[?#]/g, function(match) {
                return encodeURIComponent(match);
              });
              search = search.replace("#", "%23");
              return protocol2 + host + pathname + search + hash;
            };
            function urlResolve(source, relative) {
              return urlParse(source, false, true).resolve(relative);
            }
            Url.prototype.resolve = function(relative) {
              return this.resolveObject(urlParse(relative, false, true)).format();
            };
            function urlResolveObject(source, relative) {
              if (!source)
                return relative;
              return urlParse(source, false, true).resolveObject(relative);
            }
            Url.prototype.resolveObject = function(relative) {
              if (util.isString(relative)) {
                var rel = new Url();
                rel.parse(relative, false, true);
                relative = rel;
              }
              var result = new Url();
              var tkeys = Object.keys(this);
              for (var tk = 0; tk < tkeys.length; tk++) {
                var tkey = tkeys[tk];
                result[tkey] = this[tkey];
              }
              result.hash = relative.hash;
              if (relative.href === "") {
                result.href = result.format();
                return result;
              }
              if (relative.slashes && !relative.protocol) {
                var rkeys = Object.keys(relative);
                for (var rk = 0; rk < rkeys.length; rk++) {
                  var rkey = rkeys[rk];
                  if (rkey !== "protocol")
                    result[rkey] = relative[rkey];
                }
                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                  result.path = result.pathname = "/";
                }
                result.href = result.format();
                return result;
              }
              if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                  var keys = Object.keys(relative);
                  for (var v = 0; v < keys.length; v++) {
                    var k = keys[v];
                    result[k] = relative[k];
                  }
                  result.href = result.format();
                  return result;
                }
                result.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                  var relPath = (relative.pathname || "").split("/");
                  while (relPath.length && !(relative.host = relPath.shift()))
                    ;
                  if (!relative.host)
                    relative.host = "";
                  if (!relative.hostname)
                    relative.hostname = "";
                  if (relPath[0] !== "")
                    relPath.unshift("");
                  if (relPath.length < 2)
                    relPath.unshift("");
                  result.pathname = relPath.join("/");
                } else {
                  result.pathname = relative.pathname;
                }
                result.search = relative.search;
                result.query = relative.query;
                result.host = relative.host || "";
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result.port = relative.port;
                if (result.pathname || result.search) {
                  var p = result.pathname || "";
                  var s = result.search || "";
                  result.path = p + s;
                }
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
              }
              var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
              if (psychotic) {
                result.hostname = "";
                result.port = null;
                if (result.host) {
                  if (srcPath[0] === "")
                    srcPath[0] = result.host;
                  else
                    srcPath.unshift(result.host);
                }
                result.host = "";
                if (relative.protocol) {
                  relative.hostname = null;
                  relative.port = null;
                  if (relative.host) {
                    if (relPath[0] === "")
                      relPath[0] = relative.host;
                    else
                      relPath.unshift(relative.host);
                  }
                  relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
              }
              if (isRelAbs) {
                result.host = relative.host || relative.host === "" ? relative.host : result.host;
                result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                result.search = relative.search;
                result.query = relative.query;
                srcPath = relPath;
              } else if (relPath.length) {
                if (!srcPath)
                  srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
                result.query = relative.query;
              } else if (!util.isNullOrUndefined(relative.search)) {
                if (psychotic) {
                  result.hostname = result.host = srcPath.shift();
                  var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                  if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                  }
                }
                result.search = relative.search;
                result.query = relative.query;
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                  result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                }
                result.href = result.format();
                return result;
              }
              if (!srcPath.length) {
                result.pathname = null;
                if (result.search) {
                  result.path = "/" + result.search;
                } else {
                  result.path = null;
                }
                result.href = result.format();
                return result;
              }
              var last = srcPath.slice(-1)[0];
              var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
              var up = 0;
              for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last === ".") {
                  srcPath.splice(i, 1);
                } else if (last === "..") {
                  srcPath.splice(i, 1);
                  up++;
                } else if (up) {
                  srcPath.splice(i, 1);
                  up--;
                }
              }
              if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                  srcPath.unshift("..");
                }
              }
              if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                srcPath.unshift("");
              }
              if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                srcPath.push("");
              }
              var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
              if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                  result.auth = authInHost.shift();
                  result.host = result.hostname = authInHost.shift();
                }
              }
              mustEndAbs = mustEndAbs || result.host && srcPath.length;
              if (mustEndAbs && !isAbsolute) {
                srcPath.unshift("");
              }
              if (!srcPath.length) {
                result.pathname = null;
                result.path = null;
              } else {
                result.pathname = srcPath.join("/");
              }
              if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
              }
              result.auth = relative.auth || result.auth;
              result.slashes = result.slashes || relative.slashes;
              result.href = result.format();
              return result;
            };
            Url.prototype.parseHost = function() {
              var host = this.host;
              var port = portPattern.exec(host);
              if (port) {
                port = port[0];
                if (port !== ":") {
                  this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
              }
              if (host)
                this.hostname = host;
            };
          },
          4249: (module2) => {
            "use strict";
            module2.exports = {
              isString: function(arg) {
                return typeof arg === "string";
              },
              isObject: function(arg) {
                return typeof arg === "object" && arg !== null;
              },
              isNull: function(arg) {
                return arg === null;
              },
              isNullOrUndefined: function(arg) {
                return arg == null;
              }
            };
          },
          6276: (module2, __unused_webpack_exports, __webpack_require__2) => {
            module2.exports = deprecate;
            function deprecate(fn, msg) {
              if (config("noDeprecation")) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config(name) {
              try {
                if (!__webpack_require__2.g.localStorage)
                  return false;
              } catch (_) {
                return false;
              }
              var val = __webpack_require__2.g.localStorage[name];
              if (null == val)
                return false;
              return String(val).toLowerCase() === "true";
            }
          },
          3370: (module2) => {
            module2.exports = function isBuffer(arg) {
              return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
            };
          },
          5702: (__unused_webpack_module, exports3, __webpack_require__2) => {
            "use strict";
            __webpack_require__2(9494);
            var isArgumentsObject = __webpack_require__2(5401);
            var isGeneratorFunction = __webpack_require__2(3319);
            var whichTypedArray = __webpack_require__2(7971);
            var isTypedArray = __webpack_require__2(3513);
            function uncurryThis(f) {
              return f.call.bind(f);
            }
            var BigIntSupported = typeof BigInt !== "undefined";
            var SymbolSupported = typeof Symbol !== "undefined";
            var ObjectToString = uncurryThis(Object.prototype.toString);
            var numberValue = uncurryThis(Number.prototype.valueOf);
            var stringValue = uncurryThis(String.prototype.valueOf);
            var booleanValue = uncurryThis(Boolean.prototype.valueOf);
            if (BigIntSupported) {
              var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
            }
            if (SymbolSupported) {
              var symbolValue = uncurryThis(Symbol.prototype.valueOf);
            }
            function checkBoxedPrimitive(value, prototypeValueOf) {
              if (typeof value !== "object") {
                return false;
              }
              try {
                prototypeValueOf(value);
                return true;
              } catch (e) {
                return false;
              }
            }
            exports3.isArgumentsObject = isArgumentsObject;
            exports3.isGeneratorFunction = isGeneratorFunction;
            exports3.isTypedArray = isTypedArray;
            function isPromise(input) {
              return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
            }
            exports3.isPromise = isPromise;
            function isArrayBufferView(value) {
              if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                return ArrayBuffer.isView(value);
              }
              return isTypedArray(value) || isDataView(value);
            }
            exports3.isArrayBufferView = isArrayBufferView;
            function isUint8Array(value) {
              return whichTypedArray(value) === "Uint8Array";
            }
            exports3.isUint8Array = isUint8Array;
            function isUint8ClampedArray(value) {
              return whichTypedArray(value) === "Uint8ClampedArray";
            }
            exports3.isUint8ClampedArray = isUint8ClampedArray;
            function isUint16Array(value) {
              return whichTypedArray(value) === "Uint16Array";
            }
            exports3.isUint16Array = isUint16Array;
            function isUint32Array(value) {
              return whichTypedArray(value) === "Uint32Array";
            }
            exports3.isUint32Array = isUint32Array;
            function isInt8Array(value) {
              return whichTypedArray(value) === "Int8Array";
            }
            exports3.isInt8Array = isInt8Array;
            function isInt16Array(value) {
              return whichTypedArray(value) === "Int16Array";
            }
            exports3.isInt16Array = isInt16Array;
            function isInt32Array(value) {
              return whichTypedArray(value) === "Int32Array";
            }
            exports3.isInt32Array = isInt32Array;
            function isFloat32Array(value) {
              return whichTypedArray(value) === "Float32Array";
            }
            exports3.isFloat32Array = isFloat32Array;
            function isFloat64Array(value) {
              return whichTypedArray(value) === "Float64Array";
            }
            exports3.isFloat64Array = isFloat64Array;
            function isBigInt64Array(value) {
              return whichTypedArray(value) === "BigInt64Array";
            }
            exports3.isBigInt64Array = isBigInt64Array;
            function isBigUint64Array(value) {
              return whichTypedArray(value) === "BigUint64Array";
            }
            exports3.isBigUint64Array = isBigUint64Array;
            function isMapToString(value) {
              return ObjectToString(value) === "[object Map]";
            }
            isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
            function isMap(value) {
              if (typeof Map === "undefined") {
                return false;
              }
              return isMapToString.working ? isMapToString(value) : value instanceof Map;
            }
            exports3.isMap = isMap;
            function isSetToString(value) {
              return ObjectToString(value) === "[object Set]";
            }
            isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
            function isSet(value) {
              if (typeof Set === "undefined") {
                return false;
              }
              return isSetToString.working ? isSetToString(value) : value instanceof Set;
            }
            exports3.isSet = isSet;
            function isWeakMapToString(value) {
              return ObjectToString(value) === "[object WeakMap]";
            }
            isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
            function isWeakMap(value) {
              if (typeof WeakMap === "undefined") {
                return false;
              }
              return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
            }
            exports3.isWeakMap = isWeakMap;
            function isWeakSetToString(value) {
              return ObjectToString(value) === "[object WeakSet]";
            }
            isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
            function isWeakSet(value) {
              return isWeakSetToString(value);
            }
            exports3.isWeakSet = isWeakSet;
            function isArrayBufferToString(value) {
              return ObjectToString(value) === "[object ArrayBuffer]";
            }
            isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
            function isArrayBuffer(value) {
              if (typeof ArrayBuffer === "undefined") {
                return false;
              }
              return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
            }
            exports3.isArrayBuffer = isArrayBuffer;
            function isDataViewToString(value) {
              return ObjectToString(value) === "[object DataView]";
            }
            isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
            function isDataView(value) {
              if (typeof DataView === "undefined") {
                return false;
              }
              return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
            }
            exports3.isDataView = isDataView;
            var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
            function isSharedArrayBufferToString(value) {
              return ObjectToString(value) === "[object SharedArrayBuffer]";
            }
            function isSharedArrayBuffer(value) {
              if (typeof SharedArrayBufferCopy === "undefined") {
                return false;
              }
              if (typeof isSharedArrayBufferToString.working === "undefined") {
                isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
              }
              return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
            }
            exports3.isSharedArrayBuffer = isSharedArrayBuffer;
            function isAsyncFunction(value) {
              return ObjectToString(value) === "[object AsyncFunction]";
            }
            exports3.isAsyncFunction = isAsyncFunction;
            function isMapIterator(value) {
              return ObjectToString(value) === "[object Map Iterator]";
            }
            exports3.isMapIterator = isMapIterator;
            function isSetIterator(value) {
              return ObjectToString(value) === "[object Set Iterator]";
            }
            exports3.isSetIterator = isSetIterator;
            function isGeneratorObject(value) {
              return ObjectToString(value) === "[object Generator]";
            }
            exports3.isGeneratorObject = isGeneratorObject;
            function isWebAssemblyCompiledModule(value) {
              return ObjectToString(value) === "[object WebAssembly.Module]";
            }
            exports3.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
            function isNumberObject(value) {
              return checkBoxedPrimitive(value, numberValue);
            }
            exports3.isNumberObject = isNumberObject;
            function isStringObject(value) {
              return checkBoxedPrimitive(value, stringValue);
            }
            exports3.isStringObject = isStringObject;
            function isBooleanObject(value) {
              return checkBoxedPrimitive(value, booleanValue);
            }
            exports3.isBooleanObject = isBooleanObject;
            function isBigIntObject(value) {
              return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
            }
            exports3.isBigIntObject = isBigIntObject;
            function isSymbolObject(value) {
              return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
            }
            exports3.isSymbolObject = isSymbolObject;
            function isBoxedPrimitive(value) {
              return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
            }
            exports3.isBoxedPrimitive = isBoxedPrimitive;
            function isAnyArrayBuffer(value) {
              return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
            }
            exports3.isAnyArrayBuffer = isAnyArrayBuffer;
            ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
              Object.defineProperty(exports3, method, {
                enumerable: false,
                value: function() {
                  throw new Error(method + " is not supported in userland");
                }
              });
            });
          },
          3254: (__unused_webpack_module, exports3, __webpack_require__2) => {
            var process2 = __webpack_require__2(2790);
            var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
              var keys = Object.keys(obj);
              var descriptors = {};
              for (var i = 0; i < keys.length; i++) {
                descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
              }
              return descriptors;
            };
            var formatRegExp = /%[sdj%]/g;
            exports3.format = function(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x2) {
                if (x2 === "%%")
                  return "%";
                if (i >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };
            exports3.deprecate = function(fn, msg) {
              if (typeof process2 !== "undefined" && process2.noDeprecation === true) {
                return fn;
              }
              if (typeof process2 === "undefined") {
                return function() {
                  return exports3.deprecate(fn, msg).apply(this, arguments);
                };
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process2.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process2.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnvRegex = /^$/;
            if (process2.env.NODE_DEBUG) {
              var debugEnv = process2.env.NODE_DEBUG;
              debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
              debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
            }
            exports3.debuglog = function(set) {
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (debugEnvRegex.test(set)) {
                  var pid = process2.pid;
                  debugs[set] = function() {
                    var msg = exports3.format.apply(exports3, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {
                  };
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports3._extend(ctx, opts);
              }
              if (isUndefined(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined(ctx.depth))
                ctx.depth = 2;
              if (isUndefined(ctx.colors))
                ctx.colors = false;
              if (isUndefined(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports3.inspect = inspect;
            inspect.colors = {
              "bold": [1, 22],
              "italic": [3, 23],
              "underline": [4, 24],
              "inverse": [7, 27],
              "white": [37, 39],
              "grey": [90, 39],
              "black": [30, 39],
              "blue": [34, 39],
              "cyan": [36, 39],
              "green": [32, 39],
              "magenta": [35, 39],
              "red": [31, 39],
              "yellow": [33, 39]
            };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              array.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports3.inspect && !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array = false, braces = ["{", "}"];
              if (isArray(value)) {
                array = true;
                braces = ["[", "]"];
              }
              if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
              }
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");
              if (isString(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
              };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str.split("\n").map(function(line) {
                        return "  " + line;
                      }).join("\n").substr(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }
              return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0)
                  numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            exports3.types = __webpack_require__2(5702);
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports3.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === "boolean";
            }
            exports3.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports3.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports3.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports3.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === "string";
            }
            exports3.isString = isString;
            function isSymbol(arg) {
              return typeof arg === "symbol";
            }
            exports3.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports3.isUndefined = isUndefined;
            function isRegExp(re) {
              return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports3.isRegExp = isRegExp;
            exports3.types.isRegExp = isRegExp;
            function isObject(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports3.isObject = isObject;
            function isDate(d) {
              return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports3.isDate = isDate;
            exports3.types.isDate = isDate;
            function isError(e) {
              return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports3.isError = isError;
            exports3.types.isNativeError = isError;
            function isFunction(arg) {
              return typeof arg === "function";
            }
            exports3.isFunction = isFunction;
            function isPrimitive2(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
            }
            exports3.isPrimitive = isPrimitive2;
            exports3.isBuffer = __webpack_require__2(3370);
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            function timestamp() {
              var d = new Date();
              var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }
            exports3.log = function() {
              console.log("%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
            };
            exports3.inherits = __webpack_require__2(5153);
            exports3._extend = function(origin, add) {
              if (!add || !isObject(add))
                return origin;
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
            exports3.promisify = function promisify(original) {
              if (typeof original !== "function")
                throw new TypeError('The "original" argument must be of type Function');
              if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                var fn = original[kCustomPromisifiedSymbol];
                if (typeof fn !== "function") {
                  throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                }
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
                return fn;
              }
              function fn() {
                var promiseResolve, promiseReject;
                var promise = new Promise(function(resolve2, reject) {
                  promiseResolve = resolve2;
                  promiseReject = reject;
                });
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                args.push(function(err, value) {
                  if (err) {
                    promiseReject(err);
                  } else {
                    promiseResolve(value);
                  }
                });
                try {
                  original.apply(this, args);
                } catch (err) {
                  promiseReject(err);
                }
                return promise;
              }
              Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
              if (kCustomPromisifiedSymbol)
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
              return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
            };
            exports3.promisify.custom = kCustomPromisifiedSymbol;
            function callbackifyOnRejected(reason, cb) {
              if (!reason) {
                var newReason = new Error("Promise was rejected with a falsy value");
                newReason.reason = reason;
                reason = newReason;
              }
              return cb(reason);
            }
            function callbackify(original) {
              if (typeof original !== "function") {
                throw new TypeError('The "original" argument must be of type Function');
              }
              function callbackified() {
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                var maybeCb = args.pop();
                if (typeof maybeCb !== "function") {
                  throw new TypeError("The last argument must be of type Function");
                }
                var self2 = this;
                var cb = function() {
                  return maybeCb.apply(self2, arguments);
                };
                original.apply(this, args).then(function(ret) {
                  process2.nextTick(cb.bind(null, null, ret));
                }, function(rej) {
                  process2.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                });
              }
              Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
              Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
              return callbackified;
            }
            exports3.callbackify = callbackify;
          },
          7971: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var forEach = __webpack_require__2(4730);
            var availableTypedArrays = __webpack_require__2(9808);
            var callBound = __webpack_require__2(2648);
            var $toString = callBound("Object.prototype.toString");
            var hasToStringTag = __webpack_require__2(6323)();
            var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
            var typedArrays = availableTypedArrays();
            var $slice = callBound("String.prototype.slice");
            var toStrTags = {};
            var gOPD = __webpack_require__2(9980);
            var getPrototypeOf = Object.getPrototypeOf;
            if (hasToStringTag && gOPD && getPrototypeOf) {
              forEach(typedArrays, function(typedArray) {
                if (typeof g[typedArray] === "function") {
                  var arr = new g[typedArray]();
                  if (Symbol.toStringTag in arr) {
                    var proto = getPrototypeOf(arr);
                    var descriptor = gOPD(proto, Symbol.toStringTag);
                    if (!descriptor) {
                      var superProto = getPrototypeOf(proto);
                      descriptor = gOPD(superProto, Symbol.toStringTag);
                    }
                    toStrTags[typedArray] = descriptor.get;
                  }
                }
              });
            }
            var tryTypedArrays = function tryAllTypedArrays(value) {
              var foundName = false;
              forEach(toStrTags, function(getter, typedArray) {
                if (!foundName) {
                  try {
                    var name = getter.call(value);
                    if (name === typedArray) {
                      foundName = name;
                    }
                  } catch (e) {
                  }
                }
              });
              return foundName;
            };
            var isTypedArray = __webpack_require__2(3513);
            module2.exports = function whichTypedArray(value) {
              if (!isTypedArray(value)) {
                return false;
              }
              if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                return $slice($toString(value), 8, -1);
              }
              return tryTypedArrays(value);
            };
          },
          2786: (module2) => {
            module2.exports = extend;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }
          },
          3471: () => {
          },
          2361: () => {
          },
          4616: () => {
          },
          9808: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var possibleNames = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"];
            var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
            module2.exports = function availableTypedArrays() {
              var out = [];
              for (var i = 0; i < possibleNames.length; i++) {
                if (typeof g[possibleNames[i]] === "function") {
                  out[out.length] = possibleNames[i];
                }
              }
              return out;
            };
          },
          9980: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var GetIntrinsic = __webpack_require__2(3584);
            var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
            if ($gOPD) {
              try {
                $gOPD([], "length");
              } catch (e) {
                $gOPD = null;
              }
            }
            module2.exports = $gOPD;
          },
          1272: (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            __webpack_require__2.d(__webpack_exports__2, {
              "CORE_SCHEMA": () => CORE_SCHEMA,
              "DEFAULT_SCHEMA": () => DEFAULT_SCHEMA,
              "FAILSAFE_SCHEMA": () => FAILSAFE_SCHEMA,
              "JSON_SCHEMA": () => JSON_SCHEMA,
              "Schema": () => Schema,
              "Type": () => Type,
              "YAMLException": () => YAMLException,
              "default": () => __WEBPACK_DEFAULT_EXPORT__,
              "dump": () => dump,
              "load": () => load,
              "loadAll": () => loadAll,
              "safeDump": () => safeDump,
              "safeLoad": () => safeLoad,
              "safeLoadAll": () => safeLoadAll,
              "types": () => types2
            });
            function isNothing(subject) {
              return typeof subject === "undefined" || subject === null;
            }
            function isObject(subject) {
              return typeof subject === "object" && subject !== null;
            }
            function toArray(sequence) {
              if (Array.isArray(sequence))
                return sequence;
              else if (isNothing(sequence))
                return [];
              return [sequence];
            }
            function extend(target, source) {
              var index, length, key, sourceKeys;
              if (source) {
                sourceKeys = Object.keys(source);
                for (index = 0, length = sourceKeys.length; index < length; index += 1) {
                  key = sourceKeys[index];
                  target[key] = source[key];
                }
              }
              return target;
            }
            function repeat(string, count) {
              var result = "", cycle;
              for (cycle = 0; cycle < count; cycle += 1) {
                result += string;
              }
              return result;
            }
            function isNegativeZero(number) {
              return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
            }
            var isNothing_1 = isNothing;
            var isObject_1 = isObject;
            var toArray_1 = toArray;
            var repeat_1 = repeat;
            var isNegativeZero_1 = isNegativeZero;
            var extend_1 = extend;
            var common = {
              isNothing: isNothing_1,
              isObject: isObject_1,
              toArray: toArray_1,
              repeat: repeat_1,
              isNegativeZero: isNegativeZero_1,
              extend: extend_1
            };
            function formatError(exception2, compact) {
              var where = "", message = exception2.reason || "(unknown reason)";
              if (!exception2.mark)
                return message;
              if (exception2.mark.name) {
                where += 'in "' + exception2.mark.name + '" ';
              }
              where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
              if (!compact && exception2.mark.snippet) {
                where += "\n\n" + exception2.mark.snippet;
              }
              return message + " " + where;
            }
            function YAMLException$1(reason, mark) {
              Error.call(this);
              this.name = "YAMLException";
              this.reason = reason;
              this.mark = mark;
              this.message = formatError(this, false);
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              } else {
                this.stack = new Error().stack || "";
              }
            }
            YAMLException$1.prototype = Object.create(Error.prototype);
            YAMLException$1.prototype.constructor = YAMLException$1;
            YAMLException$1.prototype.toString = function toString(compact) {
              return this.name + ": " + formatError(this, compact);
            };
            var exception = YAMLException$1;
            function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
              var head = "";
              var tail = "";
              var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
              if (position - lineStart > maxHalfLength) {
                head = " ... ";
                lineStart = position - maxHalfLength + head.length;
              }
              if (lineEnd - position > maxHalfLength) {
                tail = " ...";
                lineEnd = position + maxHalfLength - tail.length;
              }
              return {
                str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
                pos: position - lineStart + head.length
              };
            }
            function padStart(string, max) {
              return common.repeat(" ", max - string.length) + string;
            }
            function makeSnippet(mark, options2) {
              options2 = Object.create(options2 || null);
              if (!mark.buffer)
                return null;
              if (!options2.maxLength)
                options2.maxLength = 79;
              if (typeof options2.indent !== "number")
                options2.indent = 1;
              if (typeof options2.linesBefore !== "number")
                options2.linesBefore = 3;
              if (typeof options2.linesAfter !== "number")
                options2.linesAfter = 2;
              var re = /\r?\n|\r|\0/g;
              var lineStarts = [0];
              var lineEnds = [];
              var match;
              var foundLineNo = -1;
              while (match = re.exec(mark.buffer)) {
                lineEnds.push(match.index);
                lineStarts.push(match.index + match[0].length);
                if (mark.position <= match.index && foundLineNo < 0) {
                  foundLineNo = lineStarts.length - 2;
                }
              }
              if (foundLineNo < 0)
                foundLineNo = lineStarts.length - 1;
              var result = "", i2, line;
              var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
              var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
              for (i2 = 1; i2 <= options2.linesBefore; i2++) {
                if (foundLineNo - i2 < 0)
                  break;
                line = getLine(
                  mark.buffer,
                  lineStarts[foundLineNo - i2],
                  lineEnds[foundLineNo - i2],
                  mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
                  maxLineLength
                );
                result = common.repeat(" ", options2.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
              }
              line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
              result += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
              result += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
              for (i2 = 1; i2 <= options2.linesAfter; i2++) {
                if (foundLineNo + i2 >= lineEnds.length)
                  break;
                line = getLine(
                  mark.buffer,
                  lineStarts[foundLineNo + i2],
                  lineEnds[foundLineNo + i2],
                  mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
                  maxLineLength
                );
                result += common.repeat(" ", options2.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
              }
              return result.replace(/\n$/, "");
            }
            var snippet = makeSnippet;
            var TYPE_CONSTRUCTOR_OPTIONS = [
              "kind",
              "multi",
              "resolve",
              "construct",
              "instanceOf",
              "predicate",
              "represent",
              "representName",
              "defaultStyle",
              "styleAliases"
            ];
            var YAML_NODE_KINDS = [
              "scalar",
              "sequence",
              "mapping"
            ];
            function compileStyleAliases(map2) {
              var result = {};
              if (map2 !== null) {
                Object.keys(map2).forEach(function(style) {
                  map2[style].forEach(function(alias) {
                    result[String(alias)] = style;
                  });
                });
              }
              return result;
            }
            function Type$1(tag, options2) {
              options2 = options2 || {};
              Object.keys(options2).forEach(function(name) {
                if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
                  throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
                }
              });
              this.options = options2;
              this.tag = tag;
              this.kind = options2["kind"] || null;
              this.resolve = options2["resolve"] || function() {
                return true;
              };
              this.construct = options2["construct"] || function(data) {
                return data;
              };
              this.instanceOf = options2["instanceOf"] || null;
              this.predicate = options2["predicate"] || null;
              this.represent = options2["represent"] || null;
              this.representName = options2["representName"] || null;
              this.defaultStyle = options2["defaultStyle"] || null;
              this.multi = options2["multi"] || false;
              this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
              if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
                throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
              }
            }
            var type = Type$1;
            function compileList(schema2, name) {
              var result = [];
              schema2[name].forEach(function(currentType) {
                var newIndex = result.length;
                result.forEach(function(previousType, previousIndex) {
                  if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
                    newIndex = previousIndex;
                  }
                });
                result[newIndex] = currentType;
              });
              return result;
            }
            function compileMap() {
              var result = {
                scalar: {},
                sequence: {},
                mapping: {},
                fallback: {},
                multi: {
                  scalar: [],
                  sequence: [],
                  mapping: [],
                  fallback: []
                }
              }, index, length;
              function collectType(type2) {
                if (type2.multi) {
                  result.multi[type2.kind].push(type2);
                  result.multi["fallback"].push(type2);
                } else {
                  result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
                }
              }
              for (index = 0, length = arguments.length; index < length; index += 1) {
                arguments[index].forEach(collectType);
              }
              return result;
            }
            function Schema$1(definition) {
              return this.extend(definition);
            }
            Schema$1.prototype.extend = function extend2(definition) {
              var implicit = [];
              var explicit = [];
              if (definition instanceof type) {
                explicit.push(definition);
              } else if (Array.isArray(definition)) {
                explicit = explicit.concat(definition);
              } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
                if (definition.implicit)
                  implicit = implicit.concat(definition.implicit);
                if (definition.explicit)
                  explicit = explicit.concat(definition.explicit);
              } else {
                throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
              }
              implicit.forEach(function(type$1) {
                if (!(type$1 instanceof type)) {
                  throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
                }
                if (type$1.loadKind && type$1.loadKind !== "scalar") {
                  throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
                }
                if (type$1.multi) {
                  throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
                }
              });
              explicit.forEach(function(type$1) {
                if (!(type$1 instanceof type)) {
                  throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
                }
              });
              var result = Object.create(Schema$1.prototype);
              result.implicit = (this.implicit || []).concat(implicit);
              result.explicit = (this.explicit || []).concat(explicit);
              result.compiledImplicit = compileList(result, "implicit");
              result.compiledExplicit = compileList(result, "explicit");
              result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
              return result;
            };
            var schema = Schema$1;
            var str = new type("tag:yaml.org,2002:str", {
              kind: "scalar",
              construct: function(data) {
                return data !== null ? data : "";
              }
            });
            var seq = new type("tag:yaml.org,2002:seq", {
              kind: "sequence",
              construct: function(data) {
                return data !== null ? data : [];
              }
            });
            var map = new type("tag:yaml.org,2002:map", {
              kind: "mapping",
              construct: function(data) {
                return data !== null ? data : {};
              }
            });
            var failsafe = new schema({
              explicit: [
                str,
                seq,
                map
              ]
            });
            function resolveYamlNull(data) {
              if (data === null)
                return true;
              var max = data.length;
              return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
            }
            function constructYamlNull() {
              return null;
            }
            function isNull(object) {
              return object === null;
            }
            var _null = new type("tag:yaml.org,2002:null", {
              kind: "scalar",
              resolve: resolveYamlNull,
              construct: constructYamlNull,
              predicate: isNull,
              represent: {
                canonical: function() {
                  return "~";
                },
                lowercase: function() {
                  return "null";
                },
                uppercase: function() {
                  return "NULL";
                },
                camelcase: function() {
                  return "Null";
                },
                empty: function() {
                  return "";
                }
              },
              defaultStyle: "lowercase"
            });
            function resolveYamlBoolean(data) {
              if (data === null)
                return false;
              var max = data.length;
              return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
            }
            function constructYamlBoolean(data) {
              return data === "true" || data === "True" || data === "TRUE";
            }
            function isBoolean(object) {
              return Object.prototype.toString.call(object) === "[object Boolean]";
            }
            var bool = new type("tag:yaml.org,2002:bool", {
              kind: "scalar",
              resolve: resolveYamlBoolean,
              construct: constructYamlBoolean,
              predicate: isBoolean,
              represent: {
                lowercase: function(object) {
                  return object ? "true" : "false";
                },
                uppercase: function(object) {
                  return object ? "TRUE" : "FALSE";
                },
                camelcase: function(object) {
                  return object ? "True" : "False";
                }
              },
              defaultStyle: "lowercase"
            });
            function isHexCode(c) {
              return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
            }
            function isOctCode(c) {
              return 48 <= c && c <= 55;
            }
            function isDecCode(c) {
              return 48 <= c && c <= 57;
            }
            function resolveYamlInteger(data) {
              if (data === null)
                return false;
              var max = data.length, index = 0, hasDigits = false, ch;
              if (!max)
                return false;
              ch = data[index];
              if (ch === "-" || ch === "+") {
                ch = data[++index];
              }
              if (ch === "0") {
                if (index + 1 === max)
                  return true;
                ch = data[++index];
                if (ch === "b") {
                  index++;
                  for (; index < max; index++) {
                    ch = data[index];
                    if (ch === "_")
                      continue;
                    if (ch !== "0" && ch !== "1")
                      return false;
                    hasDigits = true;
                  }
                  return hasDigits && ch !== "_";
                }
                if (ch === "x") {
                  index++;
                  for (; index < max; index++) {
                    ch = data[index];
                    if (ch === "_")
                      continue;
                    if (!isHexCode(data.charCodeAt(index)))
                      return false;
                    hasDigits = true;
                  }
                  return hasDigits && ch !== "_";
                }
                if (ch === "o") {
                  index++;
                  for (; index < max; index++) {
                    ch = data[index];
                    if (ch === "_")
                      continue;
                    if (!isOctCode(data.charCodeAt(index)))
                      return false;
                    hasDigits = true;
                  }
                  return hasDigits && ch !== "_";
                }
              }
              if (ch === "_")
                return false;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_")
                  continue;
                if (!isDecCode(data.charCodeAt(index))) {
                  return false;
                }
                hasDigits = true;
              }
              if (!hasDigits || ch === "_")
                return false;
              return true;
            }
            function constructYamlInteger(data) {
              var value = data, sign = 1, ch;
              if (value.indexOf("_") !== -1) {
                value = value.replace(/_/g, "");
              }
              ch = value[0];
              if (ch === "-" || ch === "+") {
                if (ch === "-")
                  sign = -1;
                value = value.slice(1);
                ch = value[0];
              }
              if (value === "0")
                return 0;
              if (ch === "0") {
                if (value[1] === "b")
                  return sign * parseInt(value.slice(2), 2);
                if (value[1] === "x")
                  return sign * parseInt(value.slice(2), 16);
                if (value[1] === "o")
                  return sign * parseInt(value.slice(2), 8);
              }
              return sign * parseInt(value, 10);
            }
            function isInteger(object) {
              return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
            }
            var int = new type("tag:yaml.org,2002:int", {
              kind: "scalar",
              resolve: resolveYamlInteger,
              construct: constructYamlInteger,
              predicate: isInteger,
              represent: {
                binary: function(obj) {
                  return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
                },
                octal: function(obj) {
                  return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
                },
                decimal: function(obj) {
                  return obj.toString(10);
                },
                hexadecimal: function(obj) {
                  return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
                }
              },
              defaultStyle: "decimal",
              styleAliases: {
                binary: [2, "bin"],
                octal: [8, "oct"],
                decimal: [10, "dec"],
                hexadecimal: [16, "hex"]
              }
            });
            var YAML_FLOAT_PATTERN = new RegExp(
              "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
            );
            function resolveYamlFloat(data) {
              if (data === null)
                return false;
              if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
                return false;
              }
              return true;
            }
            function constructYamlFloat(data) {
              var value, sign;
              value = data.replace(/_/g, "").toLowerCase();
              sign = value[0] === "-" ? -1 : 1;
              if ("+-".indexOf(value[0]) >= 0) {
                value = value.slice(1);
              }
              if (value === ".inf") {
                return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
              } else if (value === ".nan") {
                return NaN;
              }
              return sign * parseFloat(value, 10);
            }
            var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
            function representYamlFloat(object, style) {
              var res;
              if (isNaN(object)) {
                switch (style) {
                  case "lowercase":
                    return ".nan";
                  case "uppercase":
                    return ".NAN";
                  case "camelcase":
                    return ".NaN";
                }
              } else if (Number.POSITIVE_INFINITY === object) {
                switch (style) {
                  case "lowercase":
                    return ".inf";
                  case "uppercase":
                    return ".INF";
                  case "camelcase":
                    return ".Inf";
                }
              } else if (Number.NEGATIVE_INFINITY === object) {
                switch (style) {
                  case "lowercase":
                    return "-.inf";
                  case "uppercase":
                    return "-.INF";
                  case "camelcase":
                    return "-.Inf";
                }
              } else if (common.isNegativeZero(object)) {
                return "-0.0";
              }
              res = object.toString(10);
              return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
            }
            function isFloat(object) {
              return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
            }
            var float = new type("tag:yaml.org,2002:float", {
              kind: "scalar",
              resolve: resolveYamlFloat,
              construct: constructYamlFloat,
              predicate: isFloat,
              represent: representYamlFloat,
              defaultStyle: "lowercase"
            });
            var json = failsafe.extend({
              implicit: [
                _null,
                bool,
                int,
                float
              ]
            });
            var core = json;
            var YAML_DATE_REGEXP = new RegExp(
              "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
            );
            var YAML_TIMESTAMP_REGEXP = new RegExp(
              "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
            );
            function resolveYamlTimestamp(data) {
              if (data === null)
                return false;
              if (YAML_DATE_REGEXP.exec(data) !== null)
                return true;
              if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
                return true;
              return false;
            }
            function constructYamlTimestamp(data) {
              var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
              match = YAML_DATE_REGEXP.exec(data);
              if (match === null)
                match = YAML_TIMESTAMP_REGEXP.exec(data);
              if (match === null)
                throw new Error("Date resolve error");
              year = +match[1];
              month = +match[2] - 1;
              day = +match[3];
              if (!match[4]) {
                return new Date(Date.UTC(year, month, day));
              }
              hour = +match[4];
              minute = +match[5];
              second = +match[6];
              if (match[7]) {
                fraction = match[7].slice(0, 3);
                while (fraction.length < 3) {
                  fraction += "0";
                }
                fraction = +fraction;
              }
              if (match[9]) {
                tz_hour = +match[10];
                tz_minute = +(match[11] || 0);
                delta = (tz_hour * 60 + tz_minute) * 6e4;
                if (match[9] === "-")
                  delta = -delta;
              }
              date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
              if (delta)
                date.setTime(date.getTime() - delta);
              return date;
            }
            function representYamlTimestamp(object) {
              return object.toISOString();
            }
            var timestamp = new type("tag:yaml.org,2002:timestamp", {
              kind: "scalar",
              resolve: resolveYamlTimestamp,
              construct: constructYamlTimestamp,
              instanceOf: Date,
              represent: representYamlTimestamp
            });
            function resolveYamlMerge(data) {
              return data === "<<" || data === null;
            }
            var merge2 = new type("tag:yaml.org,2002:merge", {
              kind: "scalar",
              resolve: resolveYamlMerge
            });
            var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
            function resolveYamlBinary(data) {
              if (data === null)
                return false;
              var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
              for (idx = 0; idx < max; idx++) {
                code = map2.indexOf(data.charAt(idx));
                if (code > 64)
                  continue;
                if (code < 0)
                  return false;
                bitlen += 6;
              }
              return bitlen % 8 === 0;
            }
            function constructYamlBinary(data) {
              var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
              for (idx = 0; idx < max; idx++) {
                if (idx % 4 === 0 && idx) {
                  result.push(bits >> 16 & 255);
                  result.push(bits >> 8 & 255);
                  result.push(bits & 255);
                }
                bits = bits << 6 | map2.indexOf(input.charAt(idx));
              }
              tailbits = max % 4 * 6;
              if (tailbits === 0) {
                result.push(bits >> 16 & 255);
                result.push(bits >> 8 & 255);
                result.push(bits & 255);
              } else if (tailbits === 18) {
                result.push(bits >> 10 & 255);
                result.push(bits >> 2 & 255);
              } else if (tailbits === 12) {
                result.push(bits >> 4 & 255);
              }
              return new Uint8Array(result);
            }
            function representYamlBinary(object) {
              var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
              for (idx = 0; idx < max; idx++) {
                if (idx % 3 === 0 && idx) {
                  result += map2[bits >> 18 & 63];
                  result += map2[bits >> 12 & 63];
                  result += map2[bits >> 6 & 63];
                  result += map2[bits & 63];
                }
                bits = (bits << 8) + object[idx];
              }
              tail = max % 3;
              if (tail === 0) {
                result += map2[bits >> 18 & 63];
                result += map2[bits >> 12 & 63];
                result += map2[bits >> 6 & 63];
                result += map2[bits & 63];
              } else if (tail === 2) {
                result += map2[bits >> 10 & 63];
                result += map2[bits >> 4 & 63];
                result += map2[bits << 2 & 63];
                result += map2[64];
              } else if (tail === 1) {
                result += map2[bits >> 2 & 63];
                result += map2[bits << 4 & 63];
                result += map2[64];
                result += map2[64];
              }
              return result;
            }
            function isBinary(obj) {
              return Object.prototype.toString.call(obj) === "[object Uint8Array]";
            }
            var binary = new type("tag:yaml.org,2002:binary", {
              kind: "scalar",
              resolve: resolveYamlBinary,
              construct: constructYamlBinary,
              predicate: isBinary,
              represent: representYamlBinary
            });
            var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
            var _toString$2 = Object.prototype.toString;
            function resolveYamlOmap(data) {
              if (data === null)
                return true;
              var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
              for (index = 0, length = object.length; index < length; index += 1) {
                pair = object[index];
                pairHasKey = false;
                if (_toString$2.call(pair) !== "[object Object]")
                  return false;
                for (pairKey in pair) {
                  if (_hasOwnProperty$3.call(pair, pairKey)) {
                    if (!pairHasKey)
                      pairHasKey = true;
                    else
                      return false;
                  }
                }
                if (!pairHasKey)
                  return false;
                if (objectKeys.indexOf(pairKey) === -1)
                  objectKeys.push(pairKey);
                else
                  return false;
              }
              return true;
            }
            function constructYamlOmap(data) {
              return data !== null ? data : [];
            }
            var omap = new type("tag:yaml.org,2002:omap", {
              kind: "sequence",
              resolve: resolveYamlOmap,
              construct: constructYamlOmap
            });
            var _toString$1 = Object.prototype.toString;
            function resolveYamlPairs(data) {
              if (data === null)
                return true;
              var index, length, pair, keys, result, object = data;
              result = new Array(object.length);
              for (index = 0, length = object.length; index < length; index += 1) {
                pair = object[index];
                if (_toString$1.call(pair) !== "[object Object]")
                  return false;
                keys = Object.keys(pair);
                if (keys.length !== 1)
                  return false;
                result[index] = [keys[0], pair[keys[0]]];
              }
              return true;
            }
            function constructYamlPairs(data) {
              if (data === null)
                return [];
              var index, length, pair, keys, result, object = data;
              result = new Array(object.length);
              for (index = 0, length = object.length; index < length; index += 1) {
                pair = object[index];
                keys = Object.keys(pair);
                result[index] = [keys[0], pair[keys[0]]];
              }
              return result;
            }
            var pairs = new type("tag:yaml.org,2002:pairs", {
              kind: "sequence",
              resolve: resolveYamlPairs,
              construct: constructYamlPairs
            });
            var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
            function resolveYamlSet(data) {
              if (data === null)
                return true;
              var key, object = data;
              for (key in object) {
                if (_hasOwnProperty$2.call(object, key)) {
                  if (object[key] !== null)
                    return false;
                }
              }
              return true;
            }
            function constructYamlSet(data) {
              return data !== null ? data : {};
            }
            var set = new type("tag:yaml.org,2002:set", {
              kind: "mapping",
              resolve: resolveYamlSet,
              construct: constructYamlSet
            });
            var _default = core.extend({
              implicit: [
                timestamp,
                merge2
              ],
              explicit: [
                binary,
                omap,
                pairs,
                set
              ]
            });
            var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
            var CONTEXT_FLOW_IN = 1;
            var CONTEXT_FLOW_OUT = 2;
            var CONTEXT_BLOCK_IN = 3;
            var CONTEXT_BLOCK_OUT = 4;
            var CHOMPING_CLIP = 1;
            var CHOMPING_STRIP = 2;
            var CHOMPING_KEEP = 3;
            var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
            var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
            var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
            var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
            function _class(obj) {
              return Object.prototype.toString.call(obj);
            }
            function is_EOL(c) {
              return c === 10 || c === 13;
            }
            function is_WHITE_SPACE(c) {
              return c === 9 || c === 32;
            }
            function is_WS_OR_EOL(c) {
              return c === 9 || c === 32 || c === 10 || c === 13;
            }
            function is_FLOW_INDICATOR(c) {
              return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
            }
            function fromHexCode(c) {
              var lc;
              if (48 <= c && c <= 57) {
                return c - 48;
              }
              lc = c | 32;
              if (97 <= lc && lc <= 102) {
                return lc - 97 + 10;
              }
              return -1;
            }
            function escapedHexLen(c) {
              if (c === 120) {
                return 2;
              }
              if (c === 117) {
                return 4;
              }
              if (c === 85) {
                return 8;
              }
              return 0;
            }
            function fromDecimalCode(c) {
              if (48 <= c && c <= 57) {
                return c - 48;
              }
              return -1;
            }
            function simpleEscapeSequence(c) {
              return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
            }
            function charFromCodepoint(c) {
              if (c <= 65535) {
                return String.fromCharCode(c);
              }
              return String.fromCharCode(
                (c - 65536 >> 10) + 55296,
                (c - 65536 & 1023) + 56320
              );
            }
            var simpleEscapeCheck = new Array(256);
            var simpleEscapeMap = new Array(256);
            for (var i = 0; i < 256; i++) {
              simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
              simpleEscapeMap[i] = simpleEscapeSequence(i);
            }
            function State$1(input, options2) {
              this.input = input;
              this.filename = options2["filename"] || null;
              this.schema = options2["schema"] || _default;
              this.onWarning = options2["onWarning"] || null;
              this.legacy = options2["legacy"] || false;
              this.json = options2["json"] || false;
              this.listener = options2["listener"] || null;
              this.implicitTypes = this.schema.compiledImplicit;
              this.typeMap = this.schema.compiledTypeMap;
              this.length = input.length;
              this.position = 0;
              this.line = 0;
              this.lineStart = 0;
              this.lineIndent = 0;
              this.firstTabInLine = -1;
              this.documents = [];
            }
            function generateError(state, message) {
              var mark = {
                name: state.filename,
                buffer: state.input.slice(0, -1),
                position: state.position,
                line: state.line,
                column: state.position - state.lineStart
              };
              mark.snippet = snippet(mark);
              return new exception(message, mark);
            }
            function throwError(state, message) {
              throw generateError(state, message);
            }
            function throwWarning(state, message) {
              if (state.onWarning) {
                state.onWarning.call(null, generateError(state, message));
              }
            }
            var directiveHandlers = {
              YAML: function handleYamlDirective(state, name, args) {
                var match, major, minor;
                if (state.version !== null) {
                  throwError(state, "duplication of %YAML directive");
                }
                if (args.length !== 1) {
                  throwError(state, "YAML directive accepts exactly one argument");
                }
                match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
                if (match === null) {
                  throwError(state, "ill-formed argument of the YAML directive");
                }
                major = parseInt(match[1], 10);
                minor = parseInt(match[2], 10);
                if (major !== 1) {
                  throwError(state, "unacceptable YAML version of the document");
                }
                state.version = args[0];
                state.checkLineBreaks = minor < 2;
                if (minor !== 1 && minor !== 2) {
                  throwWarning(state, "unsupported YAML version of the document");
                }
              },
              TAG: function handleTagDirective(state, name, args) {
                var handle, prefix;
                if (args.length !== 2) {
                  throwError(state, "TAG directive accepts exactly two arguments");
                }
                handle = args[0];
                prefix = args[1];
                if (!PATTERN_TAG_HANDLE.test(handle)) {
                  throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
                }
                if (_hasOwnProperty$1.call(state.tagMap, handle)) {
                  throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
                }
                if (!PATTERN_TAG_URI.test(prefix)) {
                  throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
                }
                try {
                  prefix = decodeURIComponent(prefix);
                } catch (err) {
                  throwError(state, "tag prefix is malformed: " + prefix);
                }
                state.tagMap[handle] = prefix;
              }
            };
            function captureSegment(state, start, end, checkJson) {
              var _position, _length, _character, _result;
              if (start < end) {
                _result = state.input.slice(start, end);
                if (checkJson) {
                  for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                    _character = _result.charCodeAt(_position);
                    if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                      throwError(state, "expected valid JSON character");
                    }
                  }
                } else if (PATTERN_NON_PRINTABLE.test(_result)) {
                  throwError(state, "the stream contains non-printable characters");
                }
                state.result += _result;
              }
            }
            function mergeMappings(state, destination, source, overridableKeys) {
              var sourceKeys, key, index, quantity;
              if (!common.isObject(source)) {
                throwError(state, "cannot merge mappings; the provided source object is unacceptable");
              }
              sourceKeys = Object.keys(source);
              for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
                key = sourceKeys[index];
                if (!_hasOwnProperty$1.call(destination, key)) {
                  destination[key] = source[key];
                  overridableKeys[key] = true;
                }
              }
            }
            function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
              var index, quantity;
              if (Array.isArray(keyNode)) {
                keyNode = Array.prototype.slice.call(keyNode);
                for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
                  if (Array.isArray(keyNode[index])) {
                    throwError(state, "nested arrays are not supported inside keys");
                  }
                  if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                    keyNode[index] = "[object Object]";
                  }
                }
              }
              if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
                keyNode = "[object Object]";
              }
              keyNode = String(keyNode);
              if (_result === null) {
                _result = {};
              }
              if (keyTag === "tag:yaml.org,2002:merge") {
                if (Array.isArray(valueNode)) {
                  for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                    mergeMappings(state, _result, valueNode[index], overridableKeys);
                  }
                } else {
                  mergeMappings(state, _result, valueNode, overridableKeys);
                }
              } else {
                if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
                  state.line = startLine || state.line;
                  state.lineStart = startLineStart || state.lineStart;
                  state.position = startPos || state.position;
                  throwError(state, "duplicated mapping key");
                }
                if (keyNode === "__proto__") {
                  Object.defineProperty(_result, keyNode, {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: valueNode
                  });
                } else {
                  _result[keyNode] = valueNode;
                }
                delete overridableKeys[keyNode];
              }
              return _result;
            }
            function readLineBreak(state) {
              var ch;
              ch = state.input.charCodeAt(state.position);
              if (ch === 10) {
                state.position++;
              } else if (ch === 13) {
                state.position++;
                if (state.input.charCodeAt(state.position) === 10) {
                  state.position++;
                }
              } else {
                throwError(state, "a line break is expected");
              }
              state.line += 1;
              state.lineStart = state.position;
              state.firstTabInLine = -1;
            }
            function skipSeparationSpace(state, allowComments, checkIndent) {
              var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
              while (ch !== 0) {
                while (is_WHITE_SPACE(ch)) {
                  if (ch === 9 && state.firstTabInLine === -1) {
                    state.firstTabInLine = state.position;
                  }
                  ch = state.input.charCodeAt(++state.position);
                }
                if (allowComments && ch === 35) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (ch !== 10 && ch !== 13 && ch !== 0);
                }
                if (is_EOL(ch)) {
                  readLineBreak(state);
                  ch = state.input.charCodeAt(state.position);
                  lineBreaks++;
                  state.lineIndent = 0;
                  while (ch === 32) {
                    state.lineIndent++;
                    ch = state.input.charCodeAt(++state.position);
                  }
                } else {
                  break;
                }
              }
              if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
                throwWarning(state, "deficient indentation");
              }
              return lineBreaks;
            }
            function testDocumentSeparator(state) {
              var _position = state.position, ch;
              ch = state.input.charCodeAt(_position);
              if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
                _position += 3;
                ch = state.input.charCodeAt(_position);
                if (ch === 0 || is_WS_OR_EOL(ch)) {
                  return true;
                }
              }
              return false;
            }
            function writeFoldedLines(state, count) {
              if (count === 1) {
                state.result += " ";
              } else if (count > 1) {
                state.result += common.repeat("\n", count - 1);
              }
            }
            function readPlainScalar(state, nodeIndent, withinFlowCollection) {
              var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
              ch = state.input.charCodeAt(state.position);
              if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
                return false;
              }
              if (ch === 63 || ch === 45) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                  return false;
                }
              }
              state.kind = "scalar";
              state.result = "";
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
              while (ch !== 0) {
                if (ch === 58) {
                  following = state.input.charCodeAt(state.position + 1);
                  if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                    break;
                  }
                } else if (ch === 35) {
                  preceding = state.input.charCodeAt(state.position - 1);
                  if (is_WS_OR_EOL(preceding)) {
                    break;
                  }
                } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
                  break;
                } else if (is_EOL(ch)) {
                  _line = state.line;
                  _lineStart = state.lineStart;
                  _lineIndent = state.lineIndent;
                  skipSeparationSpace(state, false, -1);
                  if (state.lineIndent >= nodeIndent) {
                    hasPendingContent = true;
                    ch = state.input.charCodeAt(state.position);
                    continue;
                  } else {
                    state.position = captureEnd;
                    state.line = _line;
                    state.lineStart = _lineStart;
                    state.lineIndent = _lineIndent;
                    break;
                  }
                }
                if (hasPendingContent) {
                  captureSegment(state, captureStart, captureEnd, false);
                  writeFoldedLines(state, state.line - _line);
                  captureStart = captureEnd = state.position;
                  hasPendingContent = false;
                }
                if (!is_WHITE_SPACE(ch)) {
                  captureEnd = state.position + 1;
                }
                ch = state.input.charCodeAt(++state.position);
              }
              captureSegment(state, captureStart, captureEnd, false);
              if (state.result) {
                return true;
              }
              state.kind = _kind;
              state.result = _result;
              return false;
            }
            function readSingleQuotedScalar(state, nodeIndent) {
              var ch, captureStart, captureEnd;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 39) {
                return false;
              }
              state.kind = "scalar";
              state.result = "";
              state.position++;
              captureStart = captureEnd = state.position;
              while ((ch = state.input.charCodeAt(state.position)) !== 0) {
                if (ch === 39) {
                  captureSegment(state, captureStart, state.position, true);
                  ch = state.input.charCodeAt(++state.position);
                  if (ch === 39) {
                    captureStart = state.position;
                    state.position++;
                    captureEnd = state.position;
                  } else {
                    return true;
                  }
                } else if (is_EOL(ch)) {
                  captureSegment(state, captureStart, captureEnd, true);
                  writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                  captureStart = captureEnd = state.position;
                } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                  throwError(state, "unexpected end of the document within a single quoted scalar");
                } else {
                  state.position++;
                  captureEnd = state.position;
                }
              }
              throwError(state, "unexpected end of the stream within a single quoted scalar");
            }
            function readDoubleQuotedScalar(state, nodeIndent) {
              var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 34) {
                return false;
              }
              state.kind = "scalar";
              state.result = "";
              state.position++;
              captureStart = captureEnd = state.position;
              while ((ch = state.input.charCodeAt(state.position)) !== 0) {
                if (ch === 34) {
                  captureSegment(state, captureStart, state.position, true);
                  state.position++;
                  return true;
                } else if (ch === 92) {
                  captureSegment(state, captureStart, state.position, true);
                  ch = state.input.charCodeAt(++state.position);
                  if (is_EOL(ch)) {
                    skipSeparationSpace(state, false, nodeIndent);
                  } else if (ch < 256 && simpleEscapeCheck[ch]) {
                    state.result += simpleEscapeMap[ch];
                    state.position++;
                  } else if ((tmp = escapedHexLen(ch)) > 0) {
                    hexLength = tmp;
                    hexResult = 0;
                    for (; hexLength > 0; hexLength--) {
                      ch = state.input.charCodeAt(++state.position);
                      if ((tmp = fromHexCode(ch)) >= 0) {
                        hexResult = (hexResult << 4) + tmp;
                      } else {
                        throwError(state, "expected hexadecimal character");
                      }
                    }
                    state.result += charFromCodepoint(hexResult);
                    state.position++;
                  } else {
                    throwError(state, "unknown escape sequence");
                  }
                  captureStart = captureEnd = state.position;
                } else if (is_EOL(ch)) {
                  captureSegment(state, captureStart, captureEnd, true);
                  writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                  captureStart = captureEnd = state.position;
                } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                  throwError(state, "unexpected end of the document within a double quoted scalar");
                } else {
                  state.position++;
                  captureEnd = state.position;
                }
              }
              throwError(state, "unexpected end of the stream within a double quoted scalar");
            }
            function readFlowCollection(state, nodeIndent) {
              var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch === 91) {
                terminator = 93;
                isMapping = false;
                _result = [];
              } else if (ch === 123) {
                terminator = 125;
                isMapping = true;
                _result = {};
              } else {
                return false;
              }
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = _result;
              }
              ch = state.input.charCodeAt(++state.position);
              while (ch !== 0) {
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if (ch === terminator) {
                  state.position++;
                  state.tag = _tag;
                  state.anchor = _anchor;
                  state.kind = isMapping ? "mapping" : "sequence";
                  state.result = _result;
                  return true;
                } else if (!readNext) {
                  throwError(state, "missed comma between flow collection entries");
                } else if (ch === 44) {
                  throwError(state, "expected the node content, but found ','");
                }
                keyTag = keyNode = valueNode = null;
                isPair = isExplicitPair = false;
                if (ch === 63) {
                  following = state.input.charCodeAt(state.position + 1);
                  if (is_WS_OR_EOL(following)) {
                    isPair = isExplicitPair = true;
                    state.position++;
                    skipSeparationSpace(state, true, nodeIndent);
                  }
                }
                _line = state.line;
                _lineStart = state.lineStart;
                _pos = state.position;
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                keyTag = state.tag;
                keyNode = state.result;
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if ((isExplicitPair || state.line === _line) && ch === 58) {
                  isPair = true;
                  ch = state.input.charCodeAt(++state.position);
                  skipSeparationSpace(state, true, nodeIndent);
                  composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                  valueNode = state.result;
                }
                if (isMapping) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
                } else if (isPair) {
                  _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
                } else {
                  _result.push(keyNode);
                }
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if (ch === 44) {
                  readNext = true;
                  ch = state.input.charCodeAt(++state.position);
                } else {
                  readNext = false;
                }
              }
              throwError(state, "unexpected end of the stream within a flow collection");
            }
            function readBlockScalar(state, nodeIndent) {
              var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch === 124) {
                folding = false;
              } else if (ch === 62) {
                folding = true;
              } else {
                return false;
              }
              state.kind = "scalar";
              state.result = "";
              while (ch !== 0) {
                ch = state.input.charCodeAt(++state.position);
                if (ch === 43 || ch === 45) {
                  if (CHOMPING_CLIP === chomping) {
                    chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
                  } else {
                    throwError(state, "repeat of a chomping mode identifier");
                  }
                } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                  if (tmp === 0) {
                    throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
                  } else if (!detectedIndent) {
                    textIndent = nodeIndent + tmp - 1;
                    detectedIndent = true;
                  } else {
                    throwError(state, "repeat of an indentation width identifier");
                  }
                } else {
                  break;
                }
              }
              if (is_WHITE_SPACE(ch)) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (is_WHITE_SPACE(ch));
                if (ch === 35) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (!is_EOL(ch) && ch !== 0);
                }
              }
              while (ch !== 0) {
                readLineBreak(state);
                state.lineIndent = 0;
                ch = state.input.charCodeAt(state.position);
                while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
                  state.lineIndent++;
                  ch = state.input.charCodeAt(++state.position);
                }
                if (!detectedIndent && state.lineIndent > textIndent) {
                  textIndent = state.lineIndent;
                }
                if (is_EOL(ch)) {
                  emptyLines++;
                  continue;
                }
                if (state.lineIndent < textIndent) {
                  if (chomping === CHOMPING_KEEP) {
                    state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                  } else if (chomping === CHOMPING_CLIP) {
                    if (didReadContent) {
                      state.result += "\n";
                    }
                  }
                  break;
                }
                if (folding) {
                  if (is_WHITE_SPACE(ch)) {
                    atMoreIndented = true;
                    state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                  } else if (atMoreIndented) {
                    atMoreIndented = false;
                    state.result += common.repeat("\n", emptyLines + 1);
                  } else if (emptyLines === 0) {
                    if (didReadContent) {
                      state.result += " ";
                    }
                  } else {
                    state.result += common.repeat("\n", emptyLines);
                  }
                } else {
                  state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                }
                didReadContent = true;
                detectedIndent = true;
                emptyLines = 0;
                captureStart = state.position;
                while (!is_EOL(ch) && ch !== 0) {
                  ch = state.input.charCodeAt(++state.position);
                }
                captureSegment(state, captureStart, state.position, false);
              }
              return true;
            }
            function readBlockSequence(state, nodeIndent) {
              var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
              if (state.firstTabInLine !== -1)
                return false;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = _result;
              }
              ch = state.input.charCodeAt(state.position);
              while (ch !== 0) {
                if (state.firstTabInLine !== -1) {
                  state.position = state.firstTabInLine;
                  throwError(state, "tab characters must not be used in indentation");
                }
                if (ch !== 45) {
                  break;
                }
                following = state.input.charCodeAt(state.position + 1);
                if (!is_WS_OR_EOL(following)) {
                  break;
                }
                detected = true;
                state.position++;
                if (skipSeparationSpace(state, true, -1)) {
                  if (state.lineIndent <= nodeIndent) {
                    _result.push(null);
                    ch = state.input.charCodeAt(state.position);
                    continue;
                  }
                }
                _line = state.line;
                composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
                _result.push(state.result);
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
                if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
                  throwError(state, "bad indentation of a sequence entry");
                } else if (state.lineIndent < nodeIndent) {
                  break;
                }
              }
              if (detected) {
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = "sequence";
                state.result = _result;
                return true;
              }
              return false;
            }
            function readBlockMapping(state, nodeIndent, flowIndent) {
              var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
              if (state.firstTabInLine !== -1)
                return false;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = _result;
              }
              ch = state.input.charCodeAt(state.position);
              while (ch !== 0) {
                if (!atExplicitKey && state.firstTabInLine !== -1) {
                  state.position = state.firstTabInLine;
                  throwError(state, "tab characters must not be used in indentation");
                }
                following = state.input.charCodeAt(state.position + 1);
                _line = state.line;
                if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
                  if (ch === 63) {
                    if (atExplicitKey) {
                      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = true;
                    allowCompact = true;
                  } else if (atExplicitKey) {
                    atExplicitKey = false;
                    allowCompact = true;
                  } else {
                    throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
                  }
                  state.position += 1;
                  ch = following;
                } else {
                  _keyLine = state.line;
                  _keyLineStart = state.lineStart;
                  _keyPos = state.position;
                  if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
                    break;
                  }
                  if (state.line === _line) {
                    ch = state.input.charCodeAt(state.position);
                    while (is_WHITE_SPACE(ch)) {
                      ch = state.input.charCodeAt(++state.position);
                    }
                    if (ch === 58) {
                      ch = state.input.charCodeAt(++state.position);
                      if (!is_WS_OR_EOL(ch)) {
                        throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                      }
                      if (atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                        keyTag = keyNode = valueNode = null;
                      }
                      detected = true;
                      atExplicitKey = false;
                      allowCompact = false;
                      keyTag = state.tag;
                      keyNode = state.result;
                    } else if (detected) {
                      throwError(state, "can not read an implicit mapping pair; a colon is missed");
                    } else {
                      state.tag = _tag;
                      state.anchor = _anchor;
                      return true;
                    }
                  } else if (detected) {
                    throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
                  } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true;
                  }
                }
                if (state.line === _line || state.lineIndent > nodeIndent) {
                  if (atExplicitKey) {
                    _keyLine = state.line;
                    _keyLineStart = state.lineStart;
                    _keyPos = state.position;
                  }
                  if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                    if (atExplicitKey) {
                      keyNode = state.result;
                    } else {
                      valueNode = state.result;
                    }
                  }
                  if (!atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
                    keyTag = keyNode = valueNode = null;
                  }
                  skipSeparationSpace(state, true, -1);
                  ch = state.input.charCodeAt(state.position);
                }
                if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
                  throwError(state, "bad indentation of a mapping entry");
                } else if (state.lineIndent < nodeIndent) {
                  break;
                }
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              }
              if (detected) {
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = "mapping";
                state.result = _result;
              }
              return detected;
            }
            function readTagProperty(state) {
              var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 33)
                return false;
              if (state.tag !== null) {
                throwError(state, "duplication of a tag property");
              }
              ch = state.input.charCodeAt(++state.position);
              if (ch === 60) {
                isVerbatim = true;
                ch = state.input.charCodeAt(++state.position);
              } else if (ch === 33) {
                isNamed = true;
                tagHandle = "!!";
                ch = state.input.charCodeAt(++state.position);
              } else {
                tagHandle = "!";
              }
              _position = state.position;
              if (isVerbatim) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && ch !== 62);
                if (state.position < state.length) {
                  tagName = state.input.slice(_position, state.position);
                  ch = state.input.charCodeAt(++state.position);
                } else {
                  throwError(state, "unexpected end of the stream within a verbatim tag");
                }
              } else {
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  if (ch === 33) {
                    if (!isNamed) {
                      tagHandle = state.input.slice(_position - 1, state.position + 1);
                      if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                        throwError(state, "named tag handle cannot contain such characters");
                      }
                      isNamed = true;
                      _position = state.position + 1;
                    } else {
                      throwError(state, "tag suffix cannot contain exclamation marks");
                    }
                  }
                  ch = state.input.charCodeAt(++state.position);
                }
                tagName = state.input.slice(_position, state.position);
                if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                  throwError(state, "tag suffix cannot contain flow indicator characters");
                }
              }
              if (tagName && !PATTERN_TAG_URI.test(tagName)) {
                throwError(state, "tag name cannot contain such characters: " + tagName);
              }
              try {
                tagName = decodeURIComponent(tagName);
              } catch (err) {
                throwError(state, "tag name is malformed: " + tagName);
              }
              if (isVerbatim) {
                state.tag = tagName;
              } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
                state.tag = state.tagMap[tagHandle] + tagName;
              } else if (tagHandle === "!") {
                state.tag = "!" + tagName;
              } else if (tagHandle === "!!") {
                state.tag = "tag:yaml.org,2002:" + tagName;
              } else {
                throwError(state, 'undeclared tag handle "' + tagHandle + '"');
              }
              return true;
            }
            function readAnchorProperty(state) {
              var _position, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 38)
                return false;
              if (state.anchor !== null) {
                throwError(state, "duplication of an anchor property");
              }
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (state.position === _position) {
                throwError(state, "name of an anchor node must contain at least one character");
              }
              state.anchor = state.input.slice(_position, state.position);
              return true;
            }
            function readAlias(state) {
              var _position, alias, ch;
              ch = state.input.charCodeAt(state.position);
              if (ch !== 42)
                return false;
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (state.position === _position) {
                throwError(state, "name of an alias node must contain at least one character");
              }
              alias = state.input.slice(_position, state.position);
              if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
                throwError(state, 'unidentified alias "' + alias + '"');
              }
              state.result = state.anchorMap[alias];
              skipSeparationSpace(state, true, -1);
              return true;
            }
            function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
              var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
              if (state.listener !== null) {
                state.listener("open", state);
              }
              state.tag = null;
              state.anchor = null;
              state.kind = null;
              state.result = null;
              allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
              if (allowToSeek) {
                if (skipSeparationSpace(state, true, -1)) {
                  atNewLine = true;
                  if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                  } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                  } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                  }
                }
              }
              if (indentStatus === 1) {
                while (readTagProperty(state) || readAnchorProperty(state)) {
                  if (skipSeparationSpace(state, true, -1)) {
                    atNewLine = true;
                    allowBlockCollections = allowBlockStyles;
                    if (state.lineIndent > parentIndent) {
                      indentStatus = 1;
                    } else if (state.lineIndent === parentIndent) {
                      indentStatus = 0;
                    } else if (state.lineIndent < parentIndent) {
                      indentStatus = -1;
                    }
                  } else {
                    allowBlockCollections = false;
                  }
                }
              }
              if (allowBlockCollections) {
                allowBlockCollections = atNewLine || allowCompact;
              }
              if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
                if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
                  flowIndent = parentIndent;
                } else {
                  flowIndent = parentIndent + 1;
                }
                blockIndent = state.position - state.lineStart;
                if (indentStatus === 1) {
                  if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                    hasContent = true;
                  } else {
                    if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                      hasContent = true;
                    } else if (readAlias(state)) {
                      hasContent = true;
                      if (state.tag !== null || state.anchor !== null) {
                        throwError(state, "alias node should not have any properties");
                      }
                    } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                      hasContent = true;
                      if (state.tag === null) {
                        state.tag = "?";
                      }
                    }
                    if (state.anchor !== null) {
                      state.anchorMap[state.anchor] = state.result;
                    }
                  }
                } else if (indentStatus === 0) {
                  hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
                }
              }
              if (state.tag === null) {
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              } else if (state.tag === "?") {
                if (state.result !== null && state.kind !== "scalar") {
                  throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
                }
                for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                  type2 = state.implicitTypes[typeIndex];
                  if (type2.resolve(state.result)) {
                    state.result = type2.construct(state.result);
                    state.tag = type2.tag;
                    if (state.anchor !== null) {
                      state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                  }
                }
              } else if (state.tag !== "!") {
                if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
                  type2 = state.typeMap[state.kind || "fallback"][state.tag];
                } else {
                  type2 = null;
                  typeList = state.typeMap.multi[state.kind || "fallback"];
                  for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
                    if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                      type2 = typeList[typeIndex];
                      break;
                    }
                  }
                }
                if (!type2) {
                  throwError(state, "unknown tag !<" + state.tag + ">");
                }
                if (state.result !== null && type2.kind !== state.kind) {
                  throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
                }
                if (!type2.resolve(state.result, state.tag)) {
                  throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
                } else {
                  state.result = type2.construct(state.result, state.tag);
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              }
              if (state.listener !== null) {
                state.listener("close", state);
              }
              return state.tag !== null || state.anchor !== null || hasContent;
            }
            function readDocument(state) {
              var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
              state.version = null;
              state.checkLineBreaks = state.legacy;
              state.tagMap = /* @__PURE__ */ Object.create(null);
              state.anchorMap = /* @__PURE__ */ Object.create(null);
              while ((ch = state.input.charCodeAt(state.position)) !== 0) {
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
                if (state.lineIndent > 0 || ch !== 37) {
                  break;
                }
                hasDirectives = true;
                ch = state.input.charCodeAt(++state.position);
                _position = state.position;
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                directiveName = state.input.slice(_position, state.position);
                directiveArgs = [];
                if (directiveName.length < 1) {
                  throwError(state, "directive name must not be less than one character in length");
                }
                while (ch !== 0) {
                  while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  if (ch === 35) {
                    do {
                      ch = state.input.charCodeAt(++state.position);
                    } while (ch !== 0 && !is_EOL(ch));
                    break;
                  }
                  if (is_EOL(ch))
                    break;
                  _position = state.position;
                  while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  directiveArgs.push(state.input.slice(_position, state.position));
                }
                if (ch !== 0)
                  readLineBreak(state);
                if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
                  directiveHandlers[directiveName](state, directiveName, directiveArgs);
                } else {
                  throwWarning(state, 'unknown document directive "' + directiveName + '"');
                }
              }
              skipSeparationSpace(state, true, -1);
              if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              } else if (hasDirectives) {
                throwError(state, "directives end mark is expected");
              }
              composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
              skipSeparationSpace(state, true, -1);
              if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
                throwWarning(state, "non-ASCII line breaks are interpreted as content");
              }
              state.documents.push(state.result);
              if (state.position === state.lineStart && testDocumentSeparator(state)) {
                if (state.input.charCodeAt(state.position) === 46) {
                  state.position += 3;
                  skipSeparationSpace(state, true, -1);
                }
                return;
              }
              if (state.position < state.length - 1) {
                throwError(state, "end of the stream or a document separator is expected");
              } else {
                return;
              }
            }
            function loadDocuments(input, options2) {
              input = String(input);
              options2 = options2 || {};
              if (input.length !== 0) {
                if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
                  input += "\n";
                }
                if (input.charCodeAt(0) === 65279) {
                  input = input.slice(1);
                }
              }
              var state = new State$1(input, options2);
              var nullpos = input.indexOf("\0");
              if (nullpos !== -1) {
                state.position = nullpos;
                throwError(state, "null byte is not allowed in input");
              }
              state.input += "\0";
              while (state.input.charCodeAt(state.position) === 32) {
                state.lineIndent += 1;
                state.position += 1;
              }
              while (state.position < state.length - 1) {
                readDocument(state);
              }
              return state.documents;
            }
            function loadAll$1(input, iterator, options2) {
              if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
                options2 = iterator;
                iterator = null;
              }
              var documents = loadDocuments(input, options2);
              if (typeof iterator !== "function") {
                return documents;
              }
              for (var index = 0, length = documents.length; index < length; index += 1) {
                iterator(documents[index]);
              }
            }
            function load$1(input, options2) {
              var documents = loadDocuments(input, options2);
              if (documents.length === 0) {
                return void 0;
              } else if (documents.length === 1) {
                return documents[0];
              }
              throw new exception("expected a single document in the stream, but found more");
            }
            var loadAll_1 = loadAll$1;
            var load_1 = load$1;
            var loader = {
              loadAll: loadAll_1,
              load: load_1
            };
            var _toString = Object.prototype.toString;
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var CHAR_BOM = 65279;
            var CHAR_TAB = 9;
            var CHAR_LINE_FEED = 10;
            var CHAR_CARRIAGE_RETURN = 13;
            var CHAR_SPACE = 32;
            var CHAR_EXCLAMATION = 33;
            var CHAR_DOUBLE_QUOTE = 34;
            var CHAR_SHARP = 35;
            var CHAR_PERCENT = 37;
            var CHAR_AMPERSAND = 38;
            var CHAR_SINGLE_QUOTE = 39;
            var CHAR_ASTERISK = 42;
            var CHAR_COMMA = 44;
            var CHAR_MINUS = 45;
            var CHAR_COLON = 58;
            var CHAR_EQUALS = 61;
            var CHAR_GREATER_THAN = 62;
            var CHAR_QUESTION = 63;
            var CHAR_COMMERCIAL_AT = 64;
            var CHAR_LEFT_SQUARE_BRACKET = 91;
            var CHAR_RIGHT_SQUARE_BRACKET = 93;
            var CHAR_GRAVE_ACCENT = 96;
            var CHAR_LEFT_CURLY_BRACKET = 123;
            var CHAR_VERTICAL_LINE = 124;
            var CHAR_RIGHT_CURLY_BRACKET = 125;
            var ESCAPE_SEQUENCES = {};
            ESCAPE_SEQUENCES[0] = "\\0";
            ESCAPE_SEQUENCES[7] = "\\a";
            ESCAPE_SEQUENCES[8] = "\\b";
            ESCAPE_SEQUENCES[9] = "\\t";
            ESCAPE_SEQUENCES[10] = "\\n";
            ESCAPE_SEQUENCES[11] = "\\v";
            ESCAPE_SEQUENCES[12] = "\\f";
            ESCAPE_SEQUENCES[13] = "\\r";
            ESCAPE_SEQUENCES[27] = "\\e";
            ESCAPE_SEQUENCES[34] = '\\"';
            ESCAPE_SEQUENCES[92] = "\\\\";
            ESCAPE_SEQUENCES[133] = "\\N";
            ESCAPE_SEQUENCES[160] = "\\_";
            ESCAPE_SEQUENCES[8232] = "\\L";
            ESCAPE_SEQUENCES[8233] = "\\P";
            var DEPRECATED_BOOLEANS_SYNTAX = [
              "y",
              "Y",
              "yes",
              "Yes",
              "YES",
              "on",
              "On",
              "ON",
              "n",
              "N",
              "no",
              "No",
              "NO",
              "off",
              "Off",
              "OFF"
            ];
            var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
            function compileStyleMap(schema2, map2) {
              var result, keys, index, length, tag, style, type2;
              if (map2 === null)
                return {};
              result = {};
              keys = Object.keys(map2);
              for (index = 0, length = keys.length; index < length; index += 1) {
                tag = keys[index];
                style = String(map2[tag]);
                if (tag.slice(0, 2) === "!!") {
                  tag = "tag:yaml.org,2002:" + tag.slice(2);
                }
                type2 = schema2.compiledTypeMap["fallback"][tag];
                if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
                  style = type2.styleAliases[style];
                }
                result[tag] = style;
              }
              return result;
            }
            function encodeHex(character) {
              var string, handle, length;
              string = character.toString(16).toUpperCase();
              if (character <= 255) {
                handle = "x";
                length = 2;
              } else if (character <= 65535) {
                handle = "u";
                length = 4;
              } else if (character <= 4294967295) {
                handle = "U";
                length = 8;
              } else {
                throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
              }
              return "\\" + handle + common.repeat("0", length - string.length) + string;
            }
            var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
            function State(options2) {
              this.schema = options2["schema"] || _default;
              this.indent = Math.max(1, options2["indent"] || 2);
              this.noArrayIndent = options2["noArrayIndent"] || false;
              this.skipInvalid = options2["skipInvalid"] || false;
              this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
              this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
              this.sortKeys = options2["sortKeys"] || false;
              this.lineWidth = options2["lineWidth"] || 80;
              this.noRefs = options2["noRefs"] || false;
              this.noCompatMode = options2["noCompatMode"] || false;
              this.condenseFlow = options2["condenseFlow"] || false;
              this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
              this.forceQuotes = options2["forceQuotes"] || false;
              this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
              this.implicitTypes = this.schema.compiledImplicit;
              this.explicitTypes = this.schema.compiledExplicit;
              this.tag = null;
              this.result = "";
              this.duplicates = [];
              this.usedDuplicates = null;
            }
            function indentString(string, spaces) {
              var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
              while (position < length) {
                next = string.indexOf("\n", position);
                if (next === -1) {
                  line = string.slice(position);
                  position = length;
                } else {
                  line = string.slice(position, next + 1);
                  position = next + 1;
                }
                if (line.length && line !== "\n")
                  result += ind;
                result += line;
              }
              return result;
            }
            function generateNextLine(state, level) {
              return "\n" + common.repeat(" ", state.indent * level);
            }
            function testImplicitResolving(state, str2) {
              var index, length, type2;
              for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
                type2 = state.implicitTypes[index];
                if (type2.resolve(str2)) {
                  return true;
                }
              }
              return false;
            }
            function isWhitespace(c) {
              return c === CHAR_SPACE || c === CHAR_TAB;
            }
            function isPrintable(c) {
              return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
            }
            function isNsCharOrWhitespace(c) {
              return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
            }
            function isPlainSafe(c, prev, inblock) {
              var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
              var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
              return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
            }
            function isPlainSafeFirst(c) {
              return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
            }
            function isPlainSafeLast(c) {
              return !isWhitespace(c) && c !== CHAR_COLON;
            }
            function codePointAt(string, pos) {
              var first = string.charCodeAt(pos), second;
              if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
                second = string.charCodeAt(pos + 1);
                if (second >= 56320 && second <= 57343) {
                  return (first - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return first;
            }
            function needIndentIndicator(string) {
              var leadingSpaceRe = /^\n* /;
              return leadingSpaceRe.test(string);
            }
            var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
            function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
              var i2;
              var char = 0;
              var prevChar = null;
              var hasLineBreak = false;
              var hasFoldableLine = false;
              var shouldTrackWidth = lineWidth !== -1;
              var previousLineBreak = -1;
              var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
              if (singleLineOnly || forceQuotes) {
                for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
                  char = codePointAt(string, i2);
                  if (!isPrintable(char)) {
                    return STYLE_DOUBLE;
                  }
                  plain = plain && isPlainSafe(char, prevChar, inblock);
                  prevChar = char;
                }
              } else {
                for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
                  char = codePointAt(string, i2);
                  if (char === CHAR_LINE_FEED) {
                    hasLineBreak = true;
                    if (shouldTrackWidth) {
                      hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                      previousLineBreak = i2;
                    }
                  } else if (!isPrintable(char)) {
                    return STYLE_DOUBLE;
                  }
                  plain = plain && isPlainSafe(char, prevChar, inblock);
                  prevChar = char;
                }
                hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
              }
              if (!hasLineBreak && !hasFoldableLine) {
                if (plain && !forceQuotes && !testAmbiguousType(string)) {
                  return STYLE_PLAIN;
                }
                return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
              }
              if (indentPerLevel > 9 && needIndentIndicator(string)) {
                return STYLE_DOUBLE;
              }
              if (!forceQuotes) {
                return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
              }
              return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
            }
            function writeScalar(state, string, level, iskey, inblock) {
              state.dump = function() {
                if (string.length === 0) {
                  return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
                }
                if (!state.noCompatMode) {
                  if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
                    return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
                  }
                }
                var indent = state.indent * Math.max(1, level);
                var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
                var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
                function testAmbiguity(string2) {
                  return testImplicitResolving(state, string2);
                }
                switch (chooseScalarStyle(
                  string,
                  singleLineOnly,
                  state.indent,
                  lineWidth,
                  testAmbiguity,
                  state.quotingType,
                  state.forceQuotes && !iskey,
                  inblock
                )) {
                  case STYLE_PLAIN:
                    return string;
                  case STYLE_SINGLE:
                    return "'" + string.replace(/'/g, "''") + "'";
                  case STYLE_LITERAL:
                    return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
                  case STYLE_FOLDED:
                    return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
                  case STYLE_DOUBLE:
                    return '"' + escapeString(string) + '"';
                  default:
                    throw new exception("impossible error: invalid scalar style");
                }
              }();
            }
            function blockHeader(string, indentPerLevel) {
              var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
              var clip = string[string.length - 1] === "\n";
              var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
              var chomp = keep ? "+" : clip ? "" : "-";
              return indentIndicator + chomp + "\n";
            }
            function dropEndingNewline(string) {
              return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
            }
            function foldString(string, width) {
              var lineRe = /(\n+)([^\n]*)/g;
              var result = function() {
                var nextLF = string.indexOf("\n");
                nextLF = nextLF !== -1 ? nextLF : string.length;
                lineRe.lastIndex = nextLF;
                return foldLine(string.slice(0, nextLF), width);
              }();
              var prevMoreIndented = string[0] === "\n" || string[0] === " ";
              var moreIndented;
              var match;
              while (match = lineRe.exec(string)) {
                var prefix = match[1], line = match[2];
                moreIndented = line[0] === " ";
                result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
                prevMoreIndented = moreIndented;
              }
              return result;
            }
            function foldLine(line, width) {
              if (line === "" || line[0] === " ")
                return line;
              var breakRe = / [^ ]/g;
              var match;
              var start = 0, end, curr = 0, next = 0;
              var result = "";
              while (match = breakRe.exec(line)) {
                next = match.index;
                if (next - start > width) {
                  end = curr > start ? curr : next;
                  result += "\n" + line.slice(start, end);
                  start = end + 1;
                }
                curr = next;
              }
              result += "\n";
              if (line.length - start > width && curr > start) {
                result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
              } else {
                result += line.slice(start);
              }
              return result.slice(1);
            }
            function escapeString(string) {
              var result = "";
              var char = 0;
              var escapeSeq;
              for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
                char = codePointAt(string, i2);
                escapeSeq = ESCAPE_SEQUENCES[char];
                if (!escapeSeq && isPrintable(char)) {
                  result += string[i2];
                  if (char >= 65536)
                    result += string[i2 + 1];
                } else {
                  result += escapeSeq || encodeHex(char);
                }
              }
              return result;
            }
            function writeFlowSequence(state, level, object) {
              var _result = "", _tag = state.tag, index, length, value;
              for (index = 0, length = object.length; index < length; index += 1) {
                value = object[index];
                if (state.replacer) {
                  value = state.replacer.call(object, String(index), value);
                }
                if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
                  if (_result !== "")
                    _result += "," + (!state.condenseFlow ? " " : "");
                  _result += state.dump;
                }
              }
              state.tag = _tag;
              state.dump = "[" + _result + "]";
            }
            function writeBlockSequence(state, level, object, compact) {
              var _result = "", _tag = state.tag, index, length, value;
              for (index = 0, length = object.length; index < length; index += 1) {
                value = object[index];
                if (state.replacer) {
                  value = state.replacer.call(object, String(index), value);
                }
                if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
                  if (!compact || _result !== "") {
                    _result += generateNextLine(state, level);
                  }
                  if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                    _result += "-";
                  } else {
                    _result += "- ";
                  }
                  _result += state.dump;
                }
              }
              state.tag = _tag;
              state.dump = _result || "[]";
            }
            function writeFlowMapping(state, level, object) {
              var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                pairBuffer = "";
                if (_result !== "")
                  pairBuffer += ", ";
                if (state.condenseFlow)
                  pairBuffer += '"';
                objectKey = objectKeyList[index];
                objectValue = object[objectKey];
                if (state.replacer) {
                  objectValue = state.replacer.call(object, objectKey, objectValue);
                }
                if (!writeNode(state, level, objectKey, false, false)) {
                  continue;
                }
                if (state.dump.length > 1024)
                  pairBuffer += "? ";
                pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
                if (!writeNode(state, level, objectValue, false, false)) {
                  continue;
                }
                pairBuffer += state.dump;
                _result += pairBuffer;
              }
              state.tag = _tag;
              state.dump = "{" + _result + "}";
            }
            function writeBlockMapping(state, level, object, compact) {
              var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
              if (state.sortKeys === true) {
                objectKeyList.sort();
              } else if (typeof state.sortKeys === "function") {
                objectKeyList.sort(state.sortKeys);
              } else if (state.sortKeys) {
                throw new exception("sortKeys must be a boolean or a function");
              }
              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                pairBuffer = "";
                if (!compact || _result !== "") {
                  pairBuffer += generateNextLine(state, level);
                }
                objectKey = objectKeyList[index];
                objectValue = object[objectKey];
                if (state.replacer) {
                  objectValue = state.replacer.call(object, objectKey, objectValue);
                }
                if (!writeNode(state, level + 1, objectKey, true, true, true)) {
                  continue;
                }
                explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
                if (explicitPair) {
                  if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                    pairBuffer += "?";
                  } else {
                    pairBuffer += "? ";
                  }
                }
                pairBuffer += state.dump;
                if (explicitPair) {
                  pairBuffer += generateNextLine(state, level);
                }
                if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                  continue;
                }
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  pairBuffer += ":";
                } else {
                  pairBuffer += ": ";
                }
                pairBuffer += state.dump;
                _result += pairBuffer;
              }
              state.tag = _tag;
              state.dump = _result || "{}";
            }
            function detectType(state, object, explicit) {
              var _result, typeList, index, length, type2, style;
              typeList = explicit ? state.explicitTypes : state.implicitTypes;
              for (index = 0, length = typeList.length; index < length; index += 1) {
                type2 = typeList[index];
                if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
                  if (explicit) {
                    if (type2.multi && type2.representName) {
                      state.tag = type2.representName(object);
                    } else {
                      state.tag = type2.tag;
                    }
                  } else {
                    state.tag = "?";
                  }
                  if (type2.represent) {
                    style = state.styleMap[type2.tag] || type2.defaultStyle;
                    if (_toString.call(type2.represent) === "[object Function]") {
                      _result = type2.represent(object, style);
                    } else if (_hasOwnProperty.call(type2.represent, style)) {
                      _result = type2.represent[style](object, style);
                    } else {
                      throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
                    }
                    state.dump = _result;
                  }
                  return true;
                }
              }
              return false;
            }
            function writeNode(state, level, object, block2, compact, iskey, isblockseq) {
              state.tag = null;
              state.dump = object;
              if (!detectType(state, object, false)) {
                detectType(state, object, true);
              }
              var type2 = _toString.call(state.dump);
              var inblock = block2;
              var tagStr;
              if (block2) {
                block2 = state.flowLevel < 0 || state.flowLevel > level;
              }
              var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
              if (objectOrArray) {
                duplicateIndex = state.duplicates.indexOf(object);
                duplicate = duplicateIndex !== -1;
              }
              if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
                compact = false;
              }
              if (duplicate && state.usedDuplicates[duplicateIndex]) {
                state.dump = "*ref_" + duplicateIndex;
              } else {
                if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
                  state.usedDuplicates[duplicateIndex] = true;
                }
                if (type2 === "[object Object]") {
                  if (block2 && Object.keys(state.dump).length !== 0) {
                    writeBlockMapping(state, level, state.dump, compact);
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + state.dump;
                    }
                  } else {
                    writeFlowMapping(state, level, state.dump);
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                    }
                  }
                } else if (type2 === "[object Array]") {
                  if (block2 && state.dump.length !== 0) {
                    if (state.noArrayIndent && !isblockseq && level > 0) {
                      writeBlockSequence(state, level - 1, state.dump, compact);
                    } else {
                      writeBlockSequence(state, level, state.dump, compact);
                    }
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + state.dump;
                    }
                  } else {
                    writeFlowSequence(state, level, state.dump);
                    if (duplicate) {
                      state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                    }
                  }
                } else if (type2 === "[object String]") {
                  if (state.tag !== "?") {
                    writeScalar(state, state.dump, level, iskey, inblock);
                  }
                } else if (type2 === "[object Undefined]") {
                  return false;
                } else {
                  if (state.skipInvalid)
                    return false;
                  throw new exception("unacceptable kind of an object to dump " + type2);
                }
                if (state.tag !== null && state.tag !== "?") {
                  tagStr = encodeURI(
                    state.tag[0] === "!" ? state.tag.slice(1) : state.tag
                  ).replace(/!/g, "%21");
                  if (state.tag[0] === "!") {
                    tagStr = "!" + tagStr;
                  } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
                    tagStr = "!!" + tagStr.slice(18);
                  } else {
                    tagStr = "!<" + tagStr + ">";
                  }
                  state.dump = tagStr + " " + state.dump;
                }
              }
              return true;
            }
            function getDuplicateReferences(object, state) {
              var objects = [], duplicatesIndexes = [], index, length;
              inspectNode(object, objects, duplicatesIndexes);
              for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
                state.duplicates.push(objects[duplicatesIndexes[index]]);
              }
              state.usedDuplicates = new Array(length);
            }
            function inspectNode(object, objects, duplicatesIndexes) {
              var objectKeyList, index, length;
              if (object !== null && typeof object === "object") {
                index = objects.indexOf(object);
                if (index !== -1) {
                  if (duplicatesIndexes.indexOf(index) === -1) {
                    duplicatesIndexes.push(index);
                  }
                } else {
                  objects.push(object);
                  if (Array.isArray(object)) {
                    for (index = 0, length = object.length; index < length; index += 1) {
                      inspectNode(object[index], objects, duplicatesIndexes);
                    }
                  } else {
                    objectKeyList = Object.keys(object);
                    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                      inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                    }
                  }
                }
              }
            }
            function dump$1(input, options2) {
              options2 = options2 || {};
              var state = new State(options2);
              if (!state.noRefs)
                getDuplicateReferences(input, state);
              var value = input;
              if (state.replacer) {
                value = state.replacer.call({ "": value }, "", value);
              }
              if (writeNode(state, 0, value, true, true))
                return state.dump + "\n";
              return "";
            }
            var dump_1 = dump$1;
            var dumper = {
              dump: dump_1
            };
            function renamed(from, to) {
              return function() {
                throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
              };
            }
            var Type = type;
            var Schema = schema;
            var FAILSAFE_SCHEMA = failsafe;
            var JSON_SCHEMA = json;
            var CORE_SCHEMA = core;
            var DEFAULT_SCHEMA = _default;
            var load = loader.load;
            var loadAll = loader.loadAll;
            var dump = dumper.dump;
            var YAMLException = exception;
            var types2 = {
              binary,
              float,
              map,
              null: _null,
              pairs,
              set,
              timestamp,
              bool,
              int,
              merge: merge2,
              omap,
              seq,
              str
            };
            var safeLoad = renamed("safeLoad", "load");
            var safeLoadAll = renamed("safeLoadAll", "loadAll");
            var safeDump = renamed("safeDump", "dump");
            var jsYaml = {
              Type,
              Schema,
              FAILSAFE_SCHEMA,
              JSON_SCHEMA,
              CORE_SCHEMA,
              DEFAULT_SCHEMA,
              load,
              loadAll,
              dump,
              YAMLException,
              types: types2,
              safeLoad,
              safeLoadAll,
              safeDump
            };
            const __WEBPACK_DEFAULT_EXPORT__ = jsYaml;
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            loaded: false,
            exports: {}
          };
          __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.loaded = true;
          return module2.exports;
        }
        (() => {
          __webpack_require__.n = (module2) => {
            var getter = module2 && module2.__esModule ? () => module2["default"] : () => module2;
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        })();
        (() => {
          __webpack_require__.d = (exports3, definition) => {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports3, key)) {
                Object.defineProperty(exports3, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        })();
        (() => {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                return window;
            }
          }();
        })();
        (() => {
          __webpack_require__.hmd = (module2) => {
            module2 = Object.create(module2);
            if (!module2.children)
              module2.children = [];
            Object.defineProperty(module2, "exports", {
              enumerable: true,
              set: () => {
                throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + module2.id);
              }
            });
            return module2;
          };
        })();
        (() => {
          __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
        })();
        (() => {
          __webpack_require__.r = (exports3) => {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports3, "__esModule", { value: true });
          };
        })();
        (() => {
          __webpack_require__.nmd = (module2) => {
            module2.paths = [];
            if (!module2.children)
              module2.children = [];
            return module2;
          };
        })();
        var __webpack_exports__ = {};
        (() => {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, {
            "default": () => __WEBPACK_DEFAULT_EXPORT__
          });
          var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2076);
          var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__);
          var _apidevtools_json_schema_ref_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7455);
          var _apidevtools_json_schema_ref_parser__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_apidevtools_json_schema_ref_parser__WEBPACK_IMPORTED_MODULE_1__);
          var js_yaml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1272);
          var lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5448);
          var lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3__);
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              enumerableOnly && (symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })), keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = null != arguments[i] ? arguments[i] : {};
              i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          async function resolver(specUrlOrObject) {
            const result = await dereference(specUrlOrObject);
            const refStack = [];
            const keyPath = [];
            function handleCircularReferences(objectWithRef, key) {
              if (typeof objectWithRef !== "object") {
                return void 0;
              }
              if (!Object.hasOwnProperty.call(objectWithRef, "$ref")) {
                if (Array.isArray(objectWithRef)) {
                  return void 0;
                }
                const newObject = {};
                Object.keys(objectWithRef).forEach((objectKey) => {
                  keyPath.push(objectKey);
                  newObject[objectKey] = lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3___default()(objectWithRef[objectKey], handleCircularReferences);
                  keyPath.pop();
                });
                return newObject;
              }
              const clonedObject = lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3___default()(objectWithRef);
              const ref = clonedObject.$ref;
              delete clonedObject.$ref;
              const keyPathMatch = ref.split("/").slice(1).every((part, partIndex) => keyPath[partIndex] === part);
              if (refStack.includes(ref) || keyPathMatch) {
                return Object.assign(clonedObject, {
                  circularReference: {
                    $ref: ref,
                    name: ref.split("/").slice(-1)[0]
                  }
                });
              }
              refStack.push(ref);
              keyPath.push(key);
              const newValue = result.$refs.get(ref);
              const mergedResult = _objectSpread(_objectSpread({}, newValue), clonedObject);
              const finalResult = lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3___default()(mergedResult, handleCircularReferences);
              refStack.pop();
              keyPath.pop();
              return finalResult;
            }
            const specWithReferences = lodash_clonedeepwith__WEBPACK_IMPORTED_MODULE_3___default()(result.schema, handleCircularReferences);
            return specWithReferences;
          }
          async function dereference(specUrlOrObject) {
            const parser2 = new (_apidevtools_json_schema_ref_parser__WEBPACK_IMPORTED_MODULE_1___default())();
            const options2 = {
              dereference: {
                circular: "ignore"
              }
            };
            if (typeof specUrlOrObject === "object") {
              if (typeof specUrlOrObject.href === "string") {
                await dereference(specUrlOrObject.toString(), options2);
                return parser2;
              }
              await parser2.dereference(specUrlOrObject, options2);
              return parser2;
            }
            try {
              await parser2.dereference(JSON.parse(specUrlOrObject), options2);
              return parser2;
            } catch (error) {
            }
            const loadedYamlDoc = await js_yaml__WEBPACK_IMPORTED_MODULE_2__["default"].load(specUrlOrObject);
            await parser2.dereference(loadedYamlDoc, options2);
            return parser2;
          }
          resolver.resolve = resolver;
          const __WEBPACK_DEFAULT_EXPORT__ = resolver;
        })();
        __webpack_exports__ = __webpack_exports__["default"];
        return __webpack_exports__;
      })();
    });
  }
});

// node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/base64url/dist/pad-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
        buffer.write("=", position++);
      }
      return buffer.toString();
    }
    exports2.default = padString;
  }
});

// node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/base64url/dist/base64url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode(base64url3, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url3), "base64").toString(encoding);
    }
    function toBase64(base64url3) {
      base64url3 = base64url3.toString();
      return pad_string_1.default(base64url3).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url3) {
      return Buffer.from(toBase64(base64url3), "base64");
    }
    var base64url2 = encode;
    base64url2.encode = encode;
    base64url2.decode = decode;
    base64url2.toBase64 = toBase64;
    base64url2.fromBase64 = fromBase64;
    base64url2.toBuffer = toBuffer;
    exports2.default = base64url2;
  }
});

// node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/base64url/index.js"(exports2, module) {
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module) {
    module.exports = require_db();
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports2, module) {
    "use strict";
    var res = "";
    var cache;
    module.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/xml-but-prettier/dist/index.js
var require_dist = __commonJS({
  "node_modules/xml-but-prettier/dist/index.js"(exports2, module) {
    "use strict";
    var repeat = require_repeat_string();
    var splitOnTags = function splitOnTags2(str) {
      return str.split(/(<\/?[^>]+>)/g).filter(function(line) {
        return line.trim() !== "";
      });
    };
    var isTag = function isTag2(str) {
      return /<[^>!]+>/.test(str);
    };
    var isClosingTag = function isClosingTag2(str) {
      return /<\/+[^>]+>/.test(str);
    };
    var isSelfClosingTag = function isSelfClosingTag2(str) {
      return /<[^>]+\/>/.test(str);
    };
    var isOpeningTag = function isOpeningTag2(str) {
      return isTag(str) && !isClosingTag(str) && !isSelfClosingTag(str);
    };
    module.exports = function(xml2) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var indentor = config.indentor, textNodesOnSameLine = config.textNodesOnSameLine;
      var depth = 0;
      var indicesToRemove = [];
      indentor = indentor || "    ";
      var rawResult = lexer2(xml2).map(function(element, i, arr) {
        var value = element.value, type = element.type;
        if (type === "ClosingTag") {
          depth--;
        }
        var indentation = repeat(indentor, depth);
        var line = indentation + value;
        if (type === "OpeningTag") {
          depth++;
        }
        if (textNodesOnSameLine) {
          var oneBefore = arr[i - 1];
          var twoBefore = arr[i - 2];
          if (type === "ClosingTag" && oneBefore.type === "Text" && twoBefore.type === "OpeningTag") {
            line = "" + indentation + twoBefore.value + oneBefore.value + value;
            indicesToRemove.push(i - 2, i - 1);
          }
        }
        return line;
      });
      indicesToRemove.forEach(function(idx) {
        return rawResult[idx] = null;
      });
      return rawResult.filter(function(val) {
        return !!val;
      }).join("\n");
    };
    function lexer2(xmlStr) {
      var values = splitOnTags(xmlStr);
      return values.map(function(value) {
        return {
          value,
          type: getType(value)
        };
      });
    }
    function getType(str) {
      if (isClosingTag(str)) {
        return "ClosingTag";
      }
      if (isOpeningTag(str)) {
        return "OpeningTag";
      }
      if (isSelfClosingTag(str)) {
        return "SelfClosingTag";
      }
      return "Text";
    }
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports2, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js
var require_compat_dotall_s_transform = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      _hasUFlag: false,
      shouldRun: function shouldRun(ast) {
        var shouldRun2 = ast.flags.includes("s");
        if (!shouldRun2) {
          return false;
        }
        ast.flags = ast.flags.replace("s", "");
        this._hasUFlag = ast.flags.includes("u");
        return true;
      },
      Char: function Char(path) {
        var node = path.node;
        if (node.kind !== "meta" || node.value !== ".") {
          return;
        }
        var toValue = "\\uFFFF";
        var toSymbol = "\uFFFF";
        if (this._hasUFlag) {
          toValue = "\\u{10FFFF}";
          toSymbol = "\u{10FFFF}";
        }
        path.replace({
          type: "CharacterClass",
          expressions: [{
            type: "ClassRange",
            from: {
              type: "Char",
              value: "\\0",
              kind: "decimal",
              symbol: "\0"
            },
            to: {
              type: "Char",
              value: toValue,
              kind: "unicode",
              symbol: toSymbol
            }
          }]
        });
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js
var require_compat_named_capturing_groups_transform = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      _groupNames: {},
      init: function init() {
        this._groupNames = {};
      },
      getExtra: function getExtra() {
        return this._groupNames;
      },
      Group: function Group(path) {
        var node = path.node;
        if (!node.name) {
          return;
        }
        this._groupNames[node.name] = node.number;
        delete node.name;
        delete node.nameRaw;
      },
      Backreference: function Backreference(path) {
        var node = path.node;
        if (node.kind !== "name") {
          return;
        }
        node.kind = "number";
        node.reference = node.number;
        delete node.referenceRaw;
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js
var require_compat_x_flag_transform = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      RegExp: function RegExp2(_ref) {
        var node = _ref.node;
        if (node.flags.includes("x")) {
          node.flags = node.flags.replace("x", "");
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js
var require_transforms = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js"(exports2, module) {
    "use strict";
    module.exports = {
      dotAll: require_compat_dotall_s_transform(),
      namedCapturingGroups: require_compat_named_capturing_groups_transform(),
      xFlag: require_compat_x_flag_transform()
    };
  }
});

// node_modules/regexp-tree/dist/generator/index.js
var require_generator = __commonJS({
  "node_modules/regexp-tree/dist/generator/index.js"(exports2, module) {
    "use strict";
    function gen(node) {
      return node ? generator[node.type](node) : "";
    }
    var generator = {
      RegExp: function RegExp2(node) {
        return "/" + gen(node.body) + "/" + node.flags;
      },
      Alternative: function Alternative(node) {
        return (node.expressions || []).map(gen).join("");
      },
      Disjunction: function Disjunction(node) {
        return gen(node.left) + "|" + gen(node.right);
      },
      Group: function Group(node) {
        var expression = gen(node.expression);
        if (node.capturing) {
          if (node.name) {
            return "(?<" + (node.nameRaw || node.name) + ">" + expression + ")";
          }
          return "(" + expression + ")";
        }
        return "(?:" + expression + ")";
      },
      Backreference: function Backreference(node) {
        switch (node.kind) {
          case "number":
            return "\\" + node.reference;
          case "name":
            return "\\k<" + (node.referenceRaw || node.reference) + ">";
          default:
            throw new TypeError("Unknown Backreference kind: " + node.kind);
        }
      },
      Assertion: function Assertion(node) {
        switch (node.kind) {
          case "^":
          case "$":
          case "\\b":
          case "\\B":
            return node.kind;
          case "Lookahead": {
            var assertion = gen(node.assertion);
            if (node.negative) {
              return "(?!" + assertion + ")";
            }
            return "(?=" + assertion + ")";
          }
          case "Lookbehind": {
            var _assertion = gen(node.assertion);
            if (node.negative) {
              return "(?<!" + _assertion + ")";
            }
            return "(?<=" + _assertion + ")";
          }
          default:
            throw new TypeError("Unknown Assertion kind: " + node.kind);
        }
      },
      CharacterClass: function CharacterClass(node) {
        var expressions = node.expressions.map(gen).join("");
        if (node.negative) {
          return "[^" + expressions + "]";
        }
        return "[" + expressions + "]";
      },
      ClassRange: function ClassRange(node) {
        return gen(node.from) + "-" + gen(node.to);
      },
      Repetition: function Repetition(node) {
        return "" + gen(node.expression) + gen(node.quantifier);
      },
      Quantifier: function Quantifier(node) {
        var quantifier = void 0;
        var greedy = node.greedy ? "" : "?";
        switch (node.kind) {
          case "+":
          case "?":
          case "*":
            quantifier = node.kind;
            break;
          case "Range":
            if (node.from === node.to) {
              quantifier = "{" + node.from + "}";
            } else if (!node.to) {
              quantifier = "{" + node.from + ",}";
            } else {
              quantifier = "{" + node.from + "," + node.to + "}";
            }
            break;
          default:
            throw new TypeError("Unknown Quantifier kind: " + node.kind);
        }
        return "" + quantifier + greedy;
      },
      Char: function Char(node) {
        var value = node.value;
        switch (node.kind) {
          case "simple": {
            if (node.escaped) {
              return "\\" + value;
            }
            return value;
          }
          case "hex":
          case "unicode":
          case "oct":
          case "decimal":
          case "control":
          case "meta":
            return value;
          default:
            throw new TypeError("Unknown Char kind: " + node.kind);
        }
      },
      UnicodeProperty: function UnicodeProperty(node) {
        var escapeChar = node.negative ? "P" : "p";
        var namePart = void 0;
        if (!node.shorthand && !node.binary) {
          namePart = node.name + "=";
        } else {
          namePart = "";
        }
        return "\\" + escapeChar + "{" + namePart + node.value + "}";
      }
    };
    module.exports = {
      generate: gen
    };
  }
});

// node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js
var require_parser_unicode_properties = __commonJS({
  "node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js"(exports2, module) {
    "use strict";
    var NON_BINARY_PROP_NAMES_TO_ALIASES = {
      General_Category: "gc",
      Script: "sc",
      Script_Extensions: "scx"
    };
    var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);
    var BINARY_PROP_NAMES_TO_ALIASES = {
      ASCII: "ASCII",
      ASCII_Hex_Digit: "AHex",
      Alphabetic: "Alpha",
      Any: "Any",
      Assigned: "Assigned",
      Bidi_Control: "Bidi_C",
      Bidi_Mirrored: "Bidi_M",
      Case_Ignorable: "CI",
      Cased: "Cased",
      Changes_When_Casefolded: "CWCF",
      Changes_When_Casemapped: "CWCM",
      Changes_When_Lowercased: "CWL",
      Changes_When_NFKC_Casefolded: "CWKCF",
      Changes_When_Titlecased: "CWT",
      Changes_When_Uppercased: "CWU",
      Dash: "Dash",
      Default_Ignorable_Code_Point: "DI",
      Deprecated: "Dep",
      Diacritic: "Dia",
      Emoji: "Emoji",
      Emoji_Component: "Emoji_Component",
      Emoji_Modifier: "Emoji_Modifier",
      Emoji_Modifier_Base: "Emoji_Modifier_Base",
      Emoji_Presentation: "Emoji_Presentation",
      Extended_Pictographic: "Extended_Pictographic",
      Extender: "Ext",
      Grapheme_Base: "Gr_Base",
      Grapheme_Extend: "Gr_Ext",
      Hex_Digit: "Hex",
      IDS_Binary_Operator: "IDSB",
      IDS_Trinary_Operator: "IDST",
      ID_Continue: "IDC",
      ID_Start: "IDS",
      Ideographic: "Ideo",
      Join_Control: "Join_C",
      Logical_Order_Exception: "LOE",
      Lowercase: "Lower",
      Math: "Math",
      Noncharacter_Code_Point: "NChar",
      Pattern_Syntax: "Pat_Syn",
      Pattern_White_Space: "Pat_WS",
      Quotation_Mark: "QMark",
      Radical: "Radical",
      Regional_Indicator: "RI",
      Sentence_Terminal: "STerm",
      Soft_Dotted: "SD",
      Terminal_Punctuation: "Term",
      Unified_Ideograph: "UIdeo",
      Uppercase: "Upper",
      Variation_Selector: "VS",
      White_Space: "space",
      XID_Continue: "XIDC",
      XID_Start: "XIDS"
    };
    var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);
    var GENERAL_CATEGORY_VALUE_TO_ALIASES = {
      Cased_Letter: "LC",
      Close_Punctuation: "Pe",
      Connector_Punctuation: "Pc",
      Control: ["Cc", "cntrl"],
      Currency_Symbol: "Sc",
      Dash_Punctuation: "Pd",
      Decimal_Number: ["Nd", "digit"],
      Enclosing_Mark: "Me",
      Final_Punctuation: "Pf",
      Format: "Cf",
      Initial_Punctuation: "Pi",
      Letter: "L",
      Letter_Number: "Nl",
      Line_Separator: "Zl",
      Lowercase_Letter: "Ll",
      Mark: ["M", "Combining_Mark"],
      Math_Symbol: "Sm",
      Modifier_Letter: "Lm",
      Modifier_Symbol: "Sk",
      Nonspacing_Mark: "Mn",
      Number: "N",
      Open_Punctuation: "Ps",
      Other: "C",
      Other_Letter: "Lo",
      Other_Number: "No",
      Other_Punctuation: "Po",
      Other_Symbol: "So",
      Paragraph_Separator: "Zp",
      Private_Use: "Co",
      Punctuation: ["P", "punct"],
      Separator: "Z",
      Space_Separator: "Zs",
      Spacing_Mark: "Mc",
      Surrogate: "Cs",
      Symbol: "S",
      Titlecase_Letter: "Lt",
      Unassigned: "Cn",
      Uppercase_Letter: "Lu"
    };
    var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);
    var SCRIPT_VALUE_TO_ALIASES = {
      Adlam: "Adlm",
      Ahom: "Ahom",
      Anatolian_Hieroglyphs: "Hluw",
      Arabic: "Arab",
      Armenian: "Armn",
      Avestan: "Avst",
      Balinese: "Bali",
      Bamum: "Bamu",
      Bassa_Vah: "Bass",
      Batak: "Batk",
      Bengali: "Beng",
      Bhaiksuki: "Bhks",
      Bopomofo: "Bopo",
      Brahmi: "Brah",
      Braille: "Brai",
      Buginese: "Bugi",
      Buhid: "Buhd",
      Canadian_Aboriginal: "Cans",
      Carian: "Cari",
      Caucasian_Albanian: "Aghb",
      Chakma: "Cakm",
      Cham: "Cham",
      Cherokee: "Cher",
      Common: "Zyyy",
      Coptic: ["Copt", "Qaac"],
      Cuneiform: "Xsux",
      Cypriot: "Cprt",
      Cyrillic: "Cyrl",
      Deseret: "Dsrt",
      Devanagari: "Deva",
      Dogra: "Dogr",
      Duployan: "Dupl",
      Egyptian_Hieroglyphs: "Egyp",
      Elbasan: "Elba",
      Ethiopic: "Ethi",
      Georgian: "Geor",
      Glagolitic: "Glag",
      Gothic: "Goth",
      Grantha: "Gran",
      Greek: "Grek",
      Gujarati: "Gujr",
      Gunjala_Gondi: "Gong",
      Gurmukhi: "Guru",
      Han: "Hani",
      Hangul: "Hang",
      Hanifi_Rohingya: "Rohg",
      Hanunoo: "Hano",
      Hatran: "Hatr",
      Hebrew: "Hebr",
      Hiragana: "Hira",
      Imperial_Aramaic: "Armi",
      Inherited: ["Zinh", "Qaai"],
      Inscriptional_Pahlavi: "Phli",
      Inscriptional_Parthian: "Prti",
      Javanese: "Java",
      Kaithi: "Kthi",
      Kannada: "Knda",
      Katakana: "Kana",
      Kayah_Li: "Kali",
      Kharoshthi: "Khar",
      Khmer: "Khmr",
      Khojki: "Khoj",
      Khudawadi: "Sind",
      Lao: "Laoo",
      Latin: "Latn",
      Lepcha: "Lepc",
      Limbu: "Limb",
      Linear_A: "Lina",
      Linear_B: "Linb",
      Lisu: "Lisu",
      Lycian: "Lyci",
      Lydian: "Lydi",
      Mahajani: "Mahj",
      Makasar: "Maka",
      Malayalam: "Mlym",
      Mandaic: "Mand",
      Manichaean: "Mani",
      Marchen: "Marc",
      Medefaidrin: "Medf",
      Masaram_Gondi: "Gonm",
      Meetei_Mayek: "Mtei",
      Mende_Kikakui: "Mend",
      Meroitic_Cursive: "Merc",
      Meroitic_Hieroglyphs: "Mero",
      Miao: "Plrd",
      Modi: "Modi",
      Mongolian: "Mong",
      Mro: "Mroo",
      Multani: "Mult",
      Myanmar: "Mymr",
      Nabataean: "Nbat",
      New_Tai_Lue: "Talu",
      Newa: "Newa",
      Nko: "Nkoo",
      Nushu: "Nshu",
      Ogham: "Ogam",
      Ol_Chiki: "Olck",
      Old_Hungarian: "Hung",
      Old_Italic: "Ital",
      Old_North_Arabian: "Narb",
      Old_Permic: "Perm",
      Old_Persian: "Xpeo",
      Old_Sogdian: "Sogo",
      Old_South_Arabian: "Sarb",
      Old_Turkic: "Orkh",
      Oriya: "Orya",
      Osage: "Osge",
      Osmanya: "Osma",
      Pahawh_Hmong: "Hmng",
      Palmyrene: "Palm",
      Pau_Cin_Hau: "Pauc",
      Phags_Pa: "Phag",
      Phoenician: "Phnx",
      Psalter_Pahlavi: "Phlp",
      Rejang: "Rjng",
      Runic: "Runr",
      Samaritan: "Samr",
      Saurashtra: "Saur",
      Sharada: "Shrd",
      Shavian: "Shaw",
      Siddham: "Sidd",
      SignWriting: "Sgnw",
      Sinhala: "Sinh",
      Sogdian: "Sogd",
      Sora_Sompeng: "Sora",
      Soyombo: "Soyo",
      Sundanese: "Sund",
      Syloti_Nagri: "Sylo",
      Syriac: "Syrc",
      Tagalog: "Tglg",
      Tagbanwa: "Tagb",
      Tai_Le: "Tale",
      Tai_Tham: "Lana",
      Tai_Viet: "Tavt",
      Takri: "Takr",
      Tamil: "Taml",
      Tangut: "Tang",
      Telugu: "Telu",
      Thaana: "Thaa",
      Thai: "Thai",
      Tibetan: "Tibt",
      Tifinagh: "Tfng",
      Tirhuta: "Tirh",
      Ugaritic: "Ugar",
      Vai: "Vaii",
      Warang_Citi: "Wara",
      Yi: "Yiii",
      Zanabazar_Square: "Zanb"
    };
    var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);
    function inverseMap(data) {
      var inverse = {};
      for (var name in data) {
        if (!data.hasOwnProperty(name)) {
          continue;
        }
        var value = data[name];
        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            inverse[value[i]] = name;
          }
        } else {
          inverse[value] = name;
        }
      }
      return inverse;
    }
    function isValidName(name) {
      return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
    }
    function isValidValue(name, value) {
      if (isGeneralCategoryName(name)) {
        return isGeneralCategoryValue(value);
      }
      if (isScriptCategoryName(name)) {
        return isScriptCategoryValue(value);
      }
      return false;
    }
    function isAlias(name) {
      return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
    }
    function isGeneralCategoryName(name) {
      return name === "General_Category" || name == "gc";
    }
    function isScriptCategoryName(name) {
      return name === "Script" || name === "Script_Extensions" || name === "sc" || name === "scx";
    }
    function isGeneralCategoryValue(value) {
      return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);
    }
    function isScriptCategoryValue(value) {
      return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);
    }
    function isBinaryPropertyName(name) {
      return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
    }
    function getCanonicalName(name) {
      if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
        return NON_BINARY_ALIASES_TO_PROP_NAMES[name];
      }
      if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
        return BINARY_ALIASES_TO_PROP_NAMES[name];
      }
      return null;
    }
    function getCanonicalValue(value) {
      if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {
        return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];
      }
      if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {
        return SCRIPT_VALUE_ALIASES_TO_VALUE[value];
      }
      if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {
        return BINARY_ALIASES_TO_PROP_NAMES[value];
      }
      return null;
    }
    module.exports = {
      isAlias,
      isValidName,
      isValidValue,
      isGeneralCategoryValue,
      isScriptCategoryValue,
      isBinaryPropertyName,
      getCanonicalName,
      getCanonicalValue,
      NON_BINARY_PROP_NAMES_TO_ALIASES,
      NON_BINARY_ALIASES_TO_PROP_NAMES,
      BINARY_PROP_NAMES_TO_ALIASES,
      BINARY_ALIASES_TO_PROP_NAMES,
      GENERAL_CATEGORY_VALUE_TO_ALIASES,
      GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,
      SCRIPT_VALUE_TO_ALIASES,
      SCRIPT_VALUE_ALIASES_TO_VALUE
    };
  }
});

// node_modules/regexp-tree/dist/parser/generated/regexp-tree.js
var require_regexp_tree = __commonJS({
  "node_modules/regexp-tree/dist/parser/generated/regexp-tree.js"(exports2, module) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var yytext = void 0;
    var yyleng = void 0;
    var yy = {};
    var __ = void 0;
    var __loc = void 0;
    function yyloc(start, end) {
      if (!yy.options.captureLocations) {
        return null;
      }
      if (!start || !end) {
        return start || end;
      }
      return {
        startOffset: start.startOffset,
        endOffset: end.endOffset,
        startLine: start.startLine,
        endLine: end.endLine,
        startColumn: start.startColumn,
        endColumn: end.endColumn
      };
    }
    var EOF = "$";
    var productions = [[-1, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [0, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
      __loc = yyloc(_1loc, _4loc);
      __ = Node2({
        type: "RegExp",
        body: _2,
        flags: checkFlags(_4)
      }, loc(_1loc, _4loc || _3loc));
    }], [1, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [1, 0, function() {
      __loc = null;
      __ = "";
    }], [2, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [2, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = _1 + _2;
    }], [3, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [4, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [4, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      var _loc = null;
      if (_2loc) {
        _loc = loc(_1loc || _2loc, _3loc || _2loc);
      }
      ;
      __ = Node2({
        type: "Disjunction",
        left: _1,
        right: _3
      }, _loc);
    }], [5, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      if (_1.length === 0) {
        __ = null;
        return;
      }
      if (_1.length === 1) {
        __ = Node2(_1[0], __loc);
      } else {
        __ = Node2({
          type: "Alternative",
          expressions: _1
        }, __loc);
      }
    }], [6, 0, function() {
      __loc = null;
      __ = [];
    }], [6, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = _1.concat(_2);
    }], [7, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node2(Object.assign({ type: "Assertion" }, _1), __loc);
    }], [7, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = _1;
      if (_2) {
        __ = Node2({
          type: "Repetition",
          expression: _1,
          quantifier: _2
        }, __loc);
      }
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "^" };
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "$" };
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "\\b" };
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "\\B" };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookahead",
        assertion: _2
      };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookahead",
        negative: true,
        assertion: _2
      };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookbehind",
        assertion: _2
      };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookbehind",
        negative: true,
        assertion: _2
      };
    }], [9, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [9, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [9, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "simple", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1.slice(1), "simple", __loc);
      __.escaped = true;
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "unicode", __loc);
      __.isSurrogatePair = true;
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "unicode", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = UnicodeProperty(_1, __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "control", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "hex", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "oct", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = GroupRefOrDecChar(_1, __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "meta", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "meta", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = NamedGroupRefOrChars(_1, _1loc);
    }], [11, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [11, 0], [12, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [12, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      _1.greedy = false;
      __ = _1;
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node2({
        type: "Quantifier",
        kind: _1,
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node2({
        type: "Quantifier",
        kind: _1,
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node2({
        type: "Quantifier",
        kind: _1,
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      var range = getRange(_1);
      __ = Node2({
        type: "Quantifier",
        kind: "Range",
        from: range[0],
        to: range[0],
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node2({
        type: "Quantifier",
        kind: "Range",
        from: getRange(_1)[0],
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      var range = getRange(_1);
      __ = Node2({
        type: "Quantifier",
        kind: "Range",
        from: range[0],
        to: range[1],
        greedy: true
      }, __loc);
    }], [14, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [14, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      var nameRaw = String(_1);
      var name = decodeUnicodeGroupName(nameRaw);
      if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {
        throw new SyntaxError('Duplicate of the named group "' + name + '".');
      }
      namedGroups[name] = _1.groupNumber;
      __ = Node2({
        type: "Group",
        capturing: true,
        name,
        nameRaw,
        number: _1.groupNumber,
        expression: _2
      }, __loc);
    }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node2({
        type: "Group",
        capturing: true,
        number: _1.groupNumber,
        expression: _2
      }, __loc);
    }], [16, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node2({
        type: "Group",
        capturing: false,
        expression: _2
      }, __loc);
    }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node2({
        type: "CharacterClass",
        negative: true,
        expressions: _2
      }, __loc);
    }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node2({
        type: "CharacterClass",
        expressions: _2
      }, __loc);
    }], [18, 0, function() {
      __loc = null;
      __ = [];
    }], [18, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [19, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = [_1];
    }], [19, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = [_1].concat(_2);
    }], [19, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
      __loc = yyloc(_1loc, _4loc);
      checkClassRange(_1, _3);
      __ = [Node2({
        type: "ClassRange",
        from: _1,
        to: _3
      }, loc(_1loc, _3loc))];
      if (_4) {
        __ = __.concat(_4);
      }
    }], [20, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [20, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = [_1].concat(_2);
    }], [20, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
      __loc = yyloc(_1loc, _4loc);
      checkClassRange(_1, _3);
      __ = [Node2({
        type: "ClassRange",
        from: _1,
        to: _3
      }, loc(_1loc, _3loc))];
      if (_4) {
        __ = __.concat(_4);
      }
    }], [21, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "simple", __loc);
    }], [21, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [22, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [22, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "meta", __loc);
    }]];
    var tokens = { "SLASH": "23", "CHAR": "24", "BAR": "25", "BOS": "26", "EOS": "27", "ESC_b": "28", "ESC_B": "29", "POS_LA_ASSERT": "30", "R_PAREN": "31", "NEG_LA_ASSERT": "32", "POS_LB_ASSERT": "33", "NEG_LB_ASSERT": "34", "ESC_CHAR": "35", "U_CODE_SURROGATE": "36", "U_CODE": "37", "U_PROP_VALUE_EXP": "38", "CTRL_CH": "39", "HEX_CODE": "40", "OCT_CODE": "41", "DEC_CODE": "42", "META_CHAR": "43", "ANY": "44", "NAMED_GROUP_REF": "45", "Q_MARK": "46", "STAR": "47", "PLUS": "48", "RANGE_EXACT": "49", "RANGE_OPEN": "50", "RANGE_CLOSED": "51", "NAMED_CAPTURE_GROUP": "52", "L_PAREN": "53", "NON_CAPTURE_GROUP": "54", "NEG_CLASS": "55", "R_BRACKET": "56", "L_BRACKET": "57", "DASH": "58", "$": "59" };
    var table = [{ "0": 1, "23": "s2" }, { "59": "acc" }, { "3": 3, "4": 4, "5": 5, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "s7" }, { "23": "r6", "25": "s12" }, { "23": "r7", "25": "r7", "31": "r7" }, { "7": 14, "8": 15, "9": 16, "10": 25, "14": 27, "15": 42, "16": 43, "17": 26, "23": "r9", "24": "s28", "25": "r9", "26": "s17", "27": "s18", "28": "s19", "29": "s20", "30": "s21", "31": "r9", "32": "s22", "33": "s23", "34": "s24", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "52": "s44", "53": "s45", "54": "s46", "55": "s40", "57": "s41" }, { "1": 8, "2": 9, "24": "s10", "59": "r3" }, { "59": "r1" }, { "24": "s11", "59": "r2" }, { "24": "r4", "59": "r4" }, { "24": "r5", "59": "r5" }, { "5": 13, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r8", "25": "r8", "31": "r8" }, { "23": "r11", "24": "r11", "25": "r11", "26": "r11", "27": "r11", "28": "r11", "29": "r11", "30": "r11", "31": "r11", "32": "r11", "33": "r11", "34": "r11", "35": "r11", "36": "r11", "37": "r11", "38": "r11", "39": "r11", "40": "r11", "41": "r11", "42": "r11", "43": "r11", "44": "r11", "45": "r11", "52": "r11", "53": "r11", "54": "r11", "55": "r11", "57": "r11" }, { "23": "r12", "24": "r12", "25": "r12", "26": "r12", "27": "r12", "28": "r12", "29": "r12", "30": "r12", "31": "r12", "32": "r12", "33": "r12", "34": "r12", "35": "r12", "36": "r12", "37": "r12", "38": "r12", "39": "r12", "40": "r12", "41": "r12", "42": "r12", "43": "r12", "44": "r12", "45": "r12", "52": "r12", "53": "r12", "54": "r12", "55": "r12", "57": "r12" }, { "11": 47, "12": 48, "13": 49, "23": "r38", "24": "r38", "25": "r38", "26": "r38", "27": "r38", "28": "r38", "29": "r38", "30": "r38", "31": "r38", "32": "r38", "33": "r38", "34": "r38", "35": "r38", "36": "r38", "37": "r38", "38": "r38", "39": "r38", "40": "r38", "41": "r38", "42": "r38", "43": "r38", "44": "r38", "45": "r38", "46": "s52", "47": "s50", "48": "s51", "49": "s53", "50": "s54", "51": "s55", "52": "r38", "53": "r38", "54": "r38", "55": "r38", "57": "r38" }, { "23": "r14", "24": "r14", "25": "r14", "26": "r14", "27": "r14", "28": "r14", "29": "r14", "30": "r14", "31": "r14", "32": "r14", "33": "r14", "34": "r14", "35": "r14", "36": "r14", "37": "r14", "38": "r14", "39": "r14", "40": "r14", "41": "r14", "42": "r14", "43": "r14", "44": "r14", "45": "r14", "52": "r14", "53": "r14", "54": "r14", "55": "r14", "57": "r14" }, { "23": "r15", "24": "r15", "25": "r15", "26": "r15", "27": "r15", "28": "r15", "29": "r15", "30": "r15", "31": "r15", "32": "r15", "33": "r15", "34": "r15", "35": "r15", "36": "r15", "37": "r15", "38": "r15", "39": "r15", "40": "r15", "41": "r15", "42": "r15", "43": "r15", "44": "r15", "45": "r15", "52": "r15", "53": "r15", "54": "r15", "55": "r15", "57": "r15" }, { "23": "r16", "24": "r16", "25": "r16", "26": "r16", "27": "r16", "28": "r16", "29": "r16", "30": "r16", "31": "r16", "32": "r16", "33": "r16", "34": "r16", "35": "r16", "36": "r16", "37": "r16", "38": "r16", "39": "r16", "40": "r16", "41": "r16", "42": "r16", "43": "r16", "44": "r16", "45": "r16", "52": "r16", "53": "r16", "54": "r16", "55": "r16", "57": "r16" }, { "23": "r17", "24": "r17", "25": "r17", "26": "r17", "27": "r17", "28": "r17", "29": "r17", "30": "r17", "31": "r17", "32": "r17", "33": "r17", "34": "r17", "35": "r17", "36": "r17", "37": "r17", "38": "r17", "39": "r17", "40": "r17", "41": "r17", "42": "r17", "43": "r17", "44": "r17", "45": "r17", "52": "r17", "53": "r17", "54": "r17", "55": "r17", "57": "r17" }, { "4": 57, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 59, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 61, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 63, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r22", "24": "r22", "25": "r22", "26": "r22", "27": "r22", "28": "r22", "29": "r22", "30": "r22", "31": "r22", "32": "r22", "33": "r22", "34": "r22", "35": "r22", "36": "r22", "37": "r22", "38": "r22", "39": "r22", "40": "r22", "41": "r22", "42": "r22", "43": "r22", "44": "r22", "45": "r22", "46": "r22", "47": "r22", "48": "r22", "49": "r22", "50": "r22", "51": "r22", "52": "r22", "53": "r22", "54": "r22", "55": "r22", "57": "r22" }, { "23": "r23", "24": "r23", "25": "r23", "26": "r23", "27": "r23", "28": "r23", "29": "r23", "30": "r23", "31": "r23", "32": "r23", "33": "r23", "34": "r23", "35": "r23", "36": "r23", "37": "r23", "38": "r23", "39": "r23", "40": "r23", "41": "r23", "42": "r23", "43": "r23", "44": "r23", "45": "r23", "46": "r23", "47": "r23", "48": "r23", "49": "r23", "50": "r23", "51": "r23", "52": "r23", "53": "r23", "54": "r23", "55": "r23", "57": "r23" }, { "23": "r24", "24": "r24", "25": "r24", "26": "r24", "27": "r24", "28": "r24", "29": "r24", "30": "r24", "31": "r24", "32": "r24", "33": "r24", "34": "r24", "35": "r24", "36": "r24", "37": "r24", "38": "r24", "39": "r24", "40": "r24", "41": "r24", "42": "r24", "43": "r24", "44": "r24", "45": "r24", "46": "r24", "47": "r24", "48": "r24", "49": "r24", "50": "r24", "51": "r24", "52": "r24", "53": "r24", "54": "r24", "55": "r24", "57": "r24" }, { "23": "r25", "24": "r25", "25": "r25", "26": "r25", "27": "r25", "28": "r25", "29": "r25", "30": "r25", "31": "r25", "32": "r25", "33": "r25", "34": "r25", "35": "r25", "36": "r25", "37": "r25", "38": "r25", "39": "r25", "40": "r25", "41": "r25", "42": "r25", "43": "r25", "44": "r25", "45": "r25", "46": "r25", "47": "r25", "48": "r25", "49": "r25", "50": "r25", "51": "r25", "52": "r25", "53": "r25", "54": "r25", "55": "r25", "56": "r25", "57": "r25", "58": "r25" }, { "23": "r26", "24": "r26", "25": "r26", "26": "r26", "27": "r26", "28": "r26", "29": "r26", "30": "r26", "31": "r26", "32": "r26", "33": "r26", "34": "r26", "35": "r26", "36": "r26", "37": "r26", "38": "r26", "39": "r26", "40": "r26", "41": "r26", "42": "r26", "43": "r26", "44": "r26", "45": "r26", "46": "r26", "47": "r26", "48": "r26", "49": "r26", "50": "r26", "51": "r26", "52": "r26", "53": "r26", "54": "r26", "55": "r26", "56": "r26", "57": "r26", "58": "r26" }, { "23": "r27", "24": "r27", "25": "r27", "26": "r27", "27": "r27", "28": "r27", "29": "r27", "30": "r27", "31": "r27", "32": "r27", "33": "r27", "34": "r27", "35": "r27", "36": "r27", "37": "r27", "38": "r27", "39": "r27", "40": "r27", "41": "r27", "42": "r27", "43": "r27", "44": "r27", "45": "r27", "46": "r27", "47": "r27", "48": "r27", "49": "r27", "50": "r27", "51": "r27", "52": "r27", "53": "r27", "54": "r27", "55": "r27", "56": "r27", "57": "r27", "58": "r27" }, { "23": "r28", "24": "r28", "25": "r28", "26": "r28", "27": "r28", "28": "r28", "29": "r28", "30": "r28", "31": "r28", "32": "r28", "33": "r28", "34": "r28", "35": "r28", "36": "r28", "37": "r28", "38": "r28", "39": "r28", "40": "r28", "41": "r28", "42": "r28", "43": "r28", "44": "r28", "45": "r28", "46": "r28", "47": "r28", "48": "r28", "49": "r28", "50": "r28", "51": "r28", "52": "r28", "53": "r28", "54": "r28", "55": "r28", "56": "r28", "57": "r28", "58": "r28" }, { "23": "r29", "24": "r29", "25": "r29", "26": "r29", "27": "r29", "28": "r29", "29": "r29", "30": "r29", "31": "r29", "32": "r29", "33": "r29", "34": "r29", "35": "r29", "36": "r29", "37": "r29", "38": "r29", "39": "r29", "40": "r29", "41": "r29", "42": "r29", "43": "r29", "44": "r29", "45": "r29", "46": "r29", "47": "r29", "48": "r29", "49": "r29", "50": "r29", "51": "r29", "52": "r29", "53": "r29", "54": "r29", "55": "r29", "56": "r29", "57": "r29", "58": "r29" }, { "23": "r30", "24": "r30", "25": "r30", "26": "r30", "27": "r30", "28": "r30", "29": "r30", "30": "r30", "31": "r30", "32": "r30", "33": "r30", "34": "r30", "35": "r30", "36": "r30", "37": "r30", "38": "r30", "39": "r30", "40": "r30", "41": "r30", "42": "r30", "43": "r30", "44": "r30", "45": "r30", "46": "r30", "47": "r30", "48": "r30", "49": "r30", "50": "r30", "51": "r30", "52": "r30", "53": "r30", "54": "r30", "55": "r30", "56": "r30", "57": "r30", "58": "r30" }, { "23": "r31", "24": "r31", "25": "r31", "26": "r31", "27": "r31", "28": "r31", "29": "r31", "30": "r31", "31": "r31", "32": "r31", "33": "r31", "34": "r31", "35": "r31", "36": "r31", "37": "r31", "38": "r31", "39": "r31", "40": "r31", "41": "r31", "42": "r31", "43": "r31", "44": "r31", "45": "r31", "46": "r31", "47": "r31", "48": "r31", "49": "r31", "50": "r31", "51": "r31", "52": "r31", "53": "r31", "54": "r31", "55": "r31", "56": "r31", "57": "r31", "58": "r31" }, { "23": "r32", "24": "r32", "25": "r32", "26": "r32", "27": "r32", "28": "r32", "29": "r32", "30": "r32", "31": "r32", "32": "r32", "33": "r32", "34": "r32", "35": "r32", "36": "r32", "37": "r32", "38": "r32", "39": "r32", "40": "r32", "41": "r32", "42": "r32", "43": "r32", "44": "r32", "45": "r32", "46": "r32", "47": "r32", "48": "r32", "49": "r32", "50": "r32", "51": "r32", "52": "r32", "53": "r32", "54": "r32", "55": "r32", "56": "r32", "57": "r32", "58": "r32" }, { "23": "r33", "24": "r33", "25": "r33", "26": "r33", "27": "r33", "28": "r33", "29": "r33", "30": "r33", "31": "r33", "32": "r33", "33": "r33", "34": "r33", "35": "r33", "36": "r33", "37": "r33", "38": "r33", "39": "r33", "40": "r33", "41": "r33", "42": "r33", "43": "r33", "44": "r33", "45": "r33", "46": "r33", "47": "r33", "48": "r33", "49": "r33", "50": "r33", "51": "r33", "52": "r33", "53": "r33", "54": "r33", "55": "r33", "56": "r33", "57": "r33", "58": "r33" }, { "23": "r34", "24": "r34", "25": "r34", "26": "r34", "27": "r34", "28": "r34", "29": "r34", "30": "r34", "31": "r34", "32": "r34", "33": "r34", "34": "r34", "35": "r34", "36": "r34", "37": "r34", "38": "r34", "39": "r34", "40": "r34", "41": "r34", "42": "r34", "43": "r34", "44": "r34", "45": "r34", "46": "r34", "47": "r34", "48": "r34", "49": "r34", "50": "r34", "51": "r34", "52": "r34", "53": "r34", "54": "r34", "55": "r34", "56": "r34", "57": "r34", "58": "r34" }, { "23": "r35", "24": "r35", "25": "r35", "26": "r35", "27": "r35", "28": "r35", "29": "r35", "30": "r35", "31": "r35", "32": "r35", "33": "r35", "34": "r35", "35": "r35", "36": "r35", "37": "r35", "38": "r35", "39": "r35", "40": "r35", "41": "r35", "42": "r35", "43": "r35", "44": "r35", "45": "r35", "46": "r35", "47": "r35", "48": "r35", "49": "r35", "50": "r35", "51": "r35", "52": "r35", "53": "r35", "54": "r35", "55": "r35", "56": "r35", "57": "r35", "58": "r35" }, { "23": "r36", "24": "r36", "25": "r36", "26": "r36", "27": "r36", "28": "r36", "29": "r36", "30": "r36", "31": "r36", "32": "r36", "33": "r36", "34": "r36", "35": "r36", "36": "r36", "37": "r36", "38": "r36", "39": "r36", "40": "r36", "41": "r36", "42": "r36", "43": "r36", "44": "r36", "45": "r36", "46": "r36", "47": "r36", "48": "r36", "49": "r36", "50": "r36", "51": "r36", "52": "r36", "53": "r36", "54": "r36", "55": "r36", "56": "r36", "57": "r36", "58": "r36" }, { "10": 70, "18": 65, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "10": 70, "18": 83, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "23": "r47", "24": "r47", "25": "r47", "26": "r47", "27": "r47", "28": "r47", "29": "r47", "30": "r47", "31": "r47", "32": "r47", "33": "r47", "34": "r47", "35": "r47", "36": "r47", "37": "r47", "38": "r47", "39": "r47", "40": "r47", "41": "r47", "42": "r47", "43": "r47", "44": "r47", "45": "r47", "46": "r47", "47": "r47", "48": "r47", "49": "r47", "50": "r47", "51": "r47", "52": "r47", "53": "r47", "54": "r47", "55": "r47", "57": "r47" }, { "23": "r48", "24": "r48", "25": "r48", "26": "r48", "27": "r48", "28": "r48", "29": "r48", "30": "r48", "31": "r48", "32": "r48", "33": "r48", "34": "r48", "35": "r48", "36": "r48", "37": "r48", "38": "r48", "39": "r48", "40": "r48", "41": "r48", "42": "r48", "43": "r48", "44": "r48", "45": "r48", "46": "r48", "47": "r48", "48": "r48", "49": "r48", "50": "r48", "51": "r48", "52": "r48", "53": "r48", "54": "r48", "55": "r48", "57": "r48" }, { "4": 85, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 87, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 89, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r13", "24": "r13", "25": "r13", "26": "r13", "27": "r13", "28": "r13", "29": "r13", "30": "r13", "31": "r13", "32": "r13", "33": "r13", "34": "r13", "35": "r13", "36": "r13", "37": "r13", "38": "r13", "39": "r13", "40": "r13", "41": "r13", "42": "r13", "43": "r13", "44": "r13", "45": "r13", "52": "r13", "53": "r13", "54": "r13", "55": "r13", "57": "r13" }, { "23": "r37", "24": "r37", "25": "r37", "26": "r37", "27": "r37", "28": "r37", "29": "r37", "30": "r37", "31": "r37", "32": "r37", "33": "r37", "34": "r37", "35": "r37", "36": "r37", "37": "r37", "38": "r37", "39": "r37", "40": "r37", "41": "r37", "42": "r37", "43": "r37", "44": "r37", "45": "r37", "52": "r37", "53": "r37", "54": "r37", "55": "r37", "57": "r37" }, { "23": "r39", "24": "r39", "25": "r39", "26": "r39", "27": "r39", "28": "r39", "29": "r39", "30": "r39", "31": "r39", "32": "r39", "33": "r39", "34": "r39", "35": "r39", "36": "r39", "37": "r39", "38": "r39", "39": "r39", "40": "r39", "41": "r39", "42": "r39", "43": "r39", "44": "r39", "45": "r39", "46": "s56", "52": "r39", "53": "r39", "54": "r39", "55": "r39", "57": "r39" }, { "23": "r41", "24": "r41", "25": "r41", "26": "r41", "27": "r41", "28": "r41", "29": "r41", "30": "r41", "31": "r41", "32": "r41", "33": "r41", "34": "r41", "35": "r41", "36": "r41", "37": "r41", "38": "r41", "39": "r41", "40": "r41", "41": "r41", "42": "r41", "43": "r41", "44": "r41", "45": "r41", "46": "r41", "52": "r41", "53": "r41", "54": "r41", "55": "r41", "57": "r41" }, { "23": "r42", "24": "r42", "25": "r42", "26": "r42", "27": "r42", "28": "r42", "29": "r42", "30": "r42", "31": "r42", "32": "r42", "33": "r42", "34": "r42", "35": "r42", "36": "r42", "37": "r42", "38": "r42", "39": "r42", "40": "r42", "41": "r42", "42": "r42", "43": "r42", "44": "r42", "45": "r42", "46": "r42", "52": "r42", "53": "r42", "54": "r42", "55": "r42", "57": "r42" }, { "23": "r43", "24": "r43", "25": "r43", "26": "r43", "27": "r43", "28": "r43", "29": "r43", "30": "r43", "31": "r43", "32": "r43", "33": "r43", "34": "r43", "35": "r43", "36": "r43", "37": "r43", "38": "r43", "39": "r43", "40": "r43", "41": "r43", "42": "r43", "43": "r43", "44": "r43", "45": "r43", "46": "r43", "52": "r43", "53": "r43", "54": "r43", "55": "r43", "57": "r43" }, { "23": "r44", "24": "r44", "25": "r44", "26": "r44", "27": "r44", "28": "r44", "29": "r44", "30": "r44", "31": "r44", "32": "r44", "33": "r44", "34": "r44", "35": "r44", "36": "r44", "37": "r44", "38": "r44", "39": "r44", "40": "r44", "41": "r44", "42": "r44", "43": "r44", "44": "r44", "45": "r44", "46": "r44", "52": "r44", "53": "r44", "54": "r44", "55": "r44", "57": "r44" }, { "23": "r45", "24": "r45", "25": "r45", "26": "r45", "27": "r45", "28": "r45", "29": "r45", "30": "r45", "31": "r45", "32": "r45", "33": "r45", "34": "r45", "35": "r45", "36": "r45", "37": "r45", "38": "r45", "39": "r45", "40": "r45", "41": "r45", "42": "r45", "43": "r45", "44": "r45", "45": "r45", "46": "r45", "52": "r45", "53": "r45", "54": "r45", "55": "r45", "57": "r45" }, { "23": "r46", "24": "r46", "25": "r46", "26": "r46", "27": "r46", "28": "r46", "29": "r46", "30": "r46", "31": "r46", "32": "r46", "33": "r46", "34": "r46", "35": "r46", "36": "r46", "37": "r46", "38": "r46", "39": "r46", "40": "r46", "41": "r46", "42": "r46", "43": "r46", "44": "r46", "45": "r46", "46": "r46", "52": "r46", "53": "r46", "54": "r46", "55": "r46", "57": "r46" }, { "23": "r40", "24": "r40", "25": "r40", "26": "r40", "27": "r40", "28": "r40", "29": "r40", "30": "r40", "31": "r40", "32": "r40", "33": "r40", "34": "r40", "35": "r40", "36": "r40", "37": "r40", "38": "r40", "39": "r40", "40": "r40", "41": "r40", "42": "r40", "43": "r40", "44": "r40", "45": "r40", "52": "r40", "53": "r40", "54": "r40", "55": "r40", "57": "r40" }, { "25": "s12", "31": "s58" }, { "23": "r18", "24": "r18", "25": "r18", "26": "r18", "27": "r18", "28": "r18", "29": "r18", "30": "r18", "31": "r18", "32": "r18", "33": "r18", "34": "r18", "35": "r18", "36": "r18", "37": "r18", "38": "r18", "39": "r18", "40": "r18", "41": "r18", "42": "r18", "43": "r18", "44": "r18", "45": "r18", "52": "r18", "53": "r18", "54": "r18", "55": "r18", "57": "r18" }, { "25": "s12", "31": "s60" }, { "23": "r19", "24": "r19", "25": "r19", "26": "r19", "27": "r19", "28": "r19", "29": "r19", "30": "r19", "31": "r19", "32": "r19", "33": "r19", "34": "r19", "35": "r19", "36": "r19", "37": "r19", "38": "r19", "39": "r19", "40": "r19", "41": "r19", "42": "r19", "43": "r19", "44": "r19", "45": "r19", "52": "r19", "53": "r19", "54": "r19", "55": "r19", "57": "r19" }, { "25": "s12", "31": "s62" }, { "23": "r20", "24": "r20", "25": "r20", "26": "r20", "27": "r20", "28": "r20", "29": "r20", "30": "r20", "31": "r20", "32": "r20", "33": "r20", "34": "r20", "35": "r20", "36": "r20", "37": "r20", "38": "r20", "39": "r20", "40": "r20", "41": "r20", "42": "r20", "43": "r20", "44": "r20", "45": "r20", "52": "r20", "53": "r20", "54": "r20", "55": "r20", "57": "r20" }, { "25": "s12", "31": "s64" }, { "23": "r21", "24": "r21", "25": "r21", "26": "r21", "27": "r21", "28": "r21", "29": "r21", "30": "r21", "31": "r21", "32": "r21", "33": "r21", "34": "r21", "35": "r21", "36": "r21", "37": "r21", "38": "r21", "39": "r21", "40": "r21", "41": "r21", "42": "r21", "43": "r21", "44": "r21", "45": "r21", "52": "r21", "53": "r21", "54": "r21", "55": "r21", "57": "r21" }, { "56": "s72" }, { "56": "r55" }, { "10": 70, "20": 73, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r56", "58": "s74" }, { "24": "r62", "28": "r62", "35": "r62", "36": "r62", "37": "r62", "38": "r62", "39": "r62", "40": "r62", "41": "r62", "42": "r62", "43": "r62", "44": "r62", "45": "r62", "56": "r62", "58": "r62" }, { "24": "r63", "28": "r63", "35": "r63", "36": "r63", "37": "r63", "38": "r63", "39": "r63", "40": "r63", "41": "r63", "42": "r63", "43": "r63", "44": "r63", "45": "r63", "56": "r63", "58": "r63" }, { "24": "r64", "28": "r64", "35": "r64", "36": "r64", "37": "r64", "38": "r64", "39": "r64", "40": "r64", "41": "r64", "42": "r64", "43": "r64", "44": "r64", "45": "r64", "56": "r64", "58": "r64" }, { "24": "r65", "28": "r65", "35": "r65", "36": "r65", "37": "r65", "38": "r65", "39": "r65", "40": "r65", "41": "r65", "42": "r65", "43": "r65", "44": "r65", "45": "r65", "56": "r65", "58": "r65" }, { "23": "r52", "24": "r52", "25": "r52", "26": "r52", "27": "r52", "28": "r52", "29": "r52", "30": "r52", "31": "r52", "32": "r52", "33": "r52", "34": "r52", "35": "r52", "36": "r52", "37": "r52", "38": "r52", "39": "r52", "40": "r52", "41": "r52", "42": "r52", "43": "r52", "44": "r52", "45": "r52", "46": "r52", "47": "r52", "48": "r52", "49": "r52", "50": "r52", "51": "r52", "52": "r52", "53": "r52", "54": "r52", "55": "r52", "57": "r52" }, { "56": "r57" }, { "10": 70, "21": 77, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "56": "r59" }, { "10": 70, "20": 79, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r63", "58": "s80" }, { "10": 70, "18": 78, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r58" }, { "56": "r60" }, { "10": 70, "21": 81, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "10": 70, "18": 82, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r61" }, { "56": "s84" }, { "23": "r53", "24": "r53", "25": "r53", "26": "r53", "27": "r53", "28": "r53", "29": "r53", "30": "r53", "31": "r53", "32": "r53", "33": "r53", "34": "r53", "35": "r53", "36": "r53", "37": "r53", "38": "r53", "39": "r53", "40": "r53", "41": "r53", "42": "r53", "43": "r53", "44": "r53", "45": "r53", "46": "r53", "47": "r53", "48": "r53", "49": "r53", "50": "r53", "51": "r53", "52": "r53", "53": "r53", "54": "r53", "55": "r53", "57": "r53" }, { "25": "s12", "31": "s86" }, { "23": "r49", "24": "r49", "25": "r49", "26": "r49", "27": "r49", "28": "r49", "29": "r49", "30": "r49", "31": "r49", "32": "r49", "33": "r49", "34": "r49", "35": "r49", "36": "r49", "37": "r49", "38": "r49", "39": "r49", "40": "r49", "41": "r49", "42": "r49", "43": "r49", "44": "r49", "45": "r49", "46": "r49", "47": "r49", "48": "r49", "49": "r49", "50": "r49", "51": "r49", "52": "r49", "53": "r49", "54": "r49", "55": "r49", "57": "r49" }, { "25": "s12", "31": "s88" }, { "23": "r50", "24": "r50", "25": "r50", "26": "r50", "27": "r50", "28": "r50", "29": "r50", "30": "r50", "31": "r50", "32": "r50", "33": "r50", "34": "r50", "35": "r50", "36": "r50", "37": "r50", "38": "r50", "39": "r50", "40": "r50", "41": "r50", "42": "r50", "43": "r50", "44": "r50", "45": "r50", "46": "r50", "47": "r50", "48": "r50", "49": "r50", "50": "r50", "51": "r50", "52": "r50", "53": "r50", "54": "r50", "55": "r50", "57": "r50" }, { "25": "s12", "31": "s90" }, { "23": "r51", "24": "r51", "25": "r51", "26": "r51", "27": "r51", "28": "r51", "29": "r51", "30": "r51", "31": "r51", "32": "r51", "33": "r51", "34": "r51", "35": "r51", "36": "r51", "37": "r51", "38": "r51", "39": "r51", "40": "r51", "41": "r51", "42": "r51", "43": "r51", "44": "r51", "45": "r51", "46": "r51", "47": "r51", "48": "r51", "49": "r51", "50": "r51", "51": "r51", "52": "r51", "53": "r51", "54": "r51", "55": "r51", "57": "r51" }];
    var stack = [];
    var tokenizer = void 0;
    var lexRules = [[/^#[^\n]+/, function() {
    }], [/^\s+/, function() {
    }], [/^-/, function() {
      return "DASH";
    }], [/^\//, function() {
      return "CHAR";
    }], [/^#/, function() {
      return "CHAR";
    }], [/^\|/, function() {
      return "CHAR";
    }], [/^\./, function() {
      return "CHAR";
    }], [/^\{/, function() {
      return "CHAR";
    }], [/^\{\d+\}/, function() {
      return "RANGE_EXACT";
    }], [/^\{\d+,\}/, function() {
      return "RANGE_OPEN";
    }], [/^\{\d+,\d+\}/, function() {
      return "RANGE_CLOSED";
    }], [/^\\k<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
      var groupName = yytext.slice(3, -1);
      validateUnicodeGroupName(groupName, this.getCurrentState());
      return "NAMED_GROUP_REF";
    }], [/^\\b/, function() {
      return "ESC_b";
    }], [/^\\B/, function() {
      return "ESC_B";
    }], [/^\\c[a-zA-Z]/, function() {
      return "CTRL_CH";
    }], [/^\\0\d{1,2}/, function() {
      return "OCT_CODE";
    }], [/^\\0/, function() {
      return "DEC_CODE";
    }], [/^\\\d{1,3}/, function() {
      return "DEC_CODE";
    }], [/^\\u[dD][89abAB][0-9a-fA-F]{2}\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function() {
      return "U_CODE_SURROGATE";
    }], [/^\\u\{[0-9a-fA-F]{1,}\}/, function() {
      return "U_CODE";
    }], [/^\\u[0-9a-fA-F]{4}/, function() {
      return "U_CODE";
    }], [/^\\[pP]\{\w+(?:=\w+)?\}/, function() {
      return "U_PROP_VALUE_EXP";
    }], [/^\\x[0-9a-fA-F]{2}/, function() {
      return "HEX_CODE";
    }], [/^\\[tnrdDsSwWvf]/, function() {
      return "META_CHAR";
    }], [/^\\\//, function() {
      return "ESC_CHAR";
    }], [/^\\[ #]/, function() {
      return "ESC_CHAR";
    }], [/^\\[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/, function() {
      return "ESC_CHAR";
    }], [/^\\[^*?+\[()\\|]/, function() {
      var s = this.getCurrentState();
      if (s === "u_class" && yytext === "\\-") {
        return "ESC_CHAR";
      } else if (s === "u" || s === "xu" || s === "u_class") {
        throw new SyntaxError("invalid Unicode escape " + yytext);
      }
      return "ESC_CHAR";
    }], [/^\(/, function() {
      return "CHAR";
    }], [/^\)/, function() {
      return "CHAR";
    }], [/^\(\?=/, function() {
      return "POS_LA_ASSERT";
    }], [/^\(\?!/, function() {
      return "NEG_LA_ASSERT";
    }], [/^\(\?<=/, function() {
      return "POS_LB_ASSERT";
    }], [/^\(\?<!/, function() {
      return "NEG_LB_ASSERT";
    }], [/^\(\?:/, function() {
      return "NON_CAPTURE_GROUP";
    }], [/^\(\?<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
      yytext = yytext.slice(3, -1);
      validateUnicodeGroupName(yytext, this.getCurrentState());
      return "NAMED_CAPTURE_GROUP";
    }], [/^\(/, function() {
      return "L_PAREN";
    }], [/^\)/, function() {
      return "R_PAREN";
    }], [/^[*?+[^$]/, function() {
      return "CHAR";
    }], [/^\\\]/, function() {
      return "ESC_CHAR";
    }], [/^\]/, function() {
      this.popState();
      return "R_BRACKET";
    }], [/^\^/, function() {
      return "BOS";
    }], [/^\$/, function() {
      return "EOS";
    }], [/^\*/, function() {
      return "STAR";
    }], [/^\?/, function() {
      return "Q_MARK";
    }], [/^\+/, function() {
      return "PLUS";
    }], [/^\|/, function() {
      return "BAR";
    }], [/^\./, function() {
      return "ANY";
    }], [/^\//, function() {
      return "SLASH";
    }], [/^[^*?+\[()\\|]/, function() {
      return "CHAR";
    }], [/^\[\^/, function() {
      var s = this.getCurrentState();
      this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
      return "NEG_CLASS";
    }], [/^\[/, function() {
      var s = this.getCurrentState();
      this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
      return "L_BRACKET";
    }]];
    var lexRulesByConditions = { "INITIAL": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "xu": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "x": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u_class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };
    var EOF_TOKEN = {
      type: EOF,
      value: ""
    };
    tokenizer = {
      initString: function initString(string) {
        this._string = string;
        this._cursor = 0;
        this._states = ["INITIAL"];
        this._tokensQueue = [];
        this._currentLine = 1;
        this._currentColumn = 0;
        this._currentLineBeginOffset = 0;
        this._tokenStartOffset = 0;
        this._tokenEndOffset = 0;
        this._tokenStartLine = 1;
        this._tokenEndLine = 1;
        this._tokenStartColumn = 0;
        this._tokenEndColumn = 0;
        return this;
      },
      getStates: function getStates() {
        return this._states;
      },
      getCurrentState: function getCurrentState() {
        return this._states[this._states.length - 1];
      },
      pushState: function pushState(state) {
        this._states.push(state);
      },
      begin: function begin(state) {
        this.pushState(state);
      },
      popState: function popState() {
        if (this._states.length > 1) {
          return this._states.pop();
        }
        return this._states[0];
      },
      getNextToken: function getNextToken() {
        if (this._tokensQueue.length > 0) {
          return this.onToken(this._toToken(this._tokensQueue.shift()));
        }
        if (!this.hasMoreTokens()) {
          return this.onToken(EOF_TOKEN);
        }
        var string = this._string.slice(this._cursor);
        var lexRulesForState = lexRulesByConditions[this.getCurrentState()];
        for (var i = 0; i < lexRulesForState.length; i++) {
          var lexRuleIndex = lexRulesForState[i];
          var lexRule = lexRules[lexRuleIndex];
          var matched = this._match(string, lexRule[0]);
          if (string === "" && matched === "") {
            this._cursor++;
          }
          if (matched !== null) {
            yytext = matched;
            yyleng = yytext.length;
            var token = lexRule[1].call(this);
            if (!token) {
              return this.getNextToken();
            }
            if (Array.isArray(token)) {
              var tokensToQueue = token.slice(1);
              token = token[0];
              if (tokensToQueue.length > 0) {
                var _tokensQueue;
                (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray(tokensToQueue));
              }
            }
            return this.onToken(this._toToken(token, yytext));
          }
        }
        if (this.isEOF()) {
          this._cursor++;
          return EOF_TOKEN;
        }
        this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);
      },
      throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {
        var lineSource = this._string.split("\n")[line - 1];
        var lineData = "";
        if (lineSource) {
          var pad = " ".repeat(column);
          lineData = "\n\n" + lineSource + "\n" + pad + "^\n";
        }
        throw new SyntaxError(lineData + 'Unexpected token: "' + symbol + '" ' + ("at " + line + ":" + column + "."));
      },
      getCursor: function getCursor() {
        return this._cursor;
      },
      getCurrentLine: function getCurrentLine() {
        return this._currentLine;
      },
      getCurrentColumn: function getCurrentColumn() {
        return this._currentColumn;
      },
      _captureLocation: function _captureLocation(matched) {
        var nlRe = /\n/g;
        this._tokenStartOffset = this._cursor;
        this._tokenStartLine = this._currentLine;
        this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;
        var nlMatch = void 0;
        while ((nlMatch = nlRe.exec(matched)) !== null) {
          this._currentLine++;
          this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
        }
        this._tokenEndOffset = this._cursor + matched.length;
        this._tokenEndLine = this._currentLine;
        this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;
      },
      _toToken: function _toToken(tokenType) {
        var yytext2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        return {
          type: tokenType,
          value: yytext2,
          startOffset: this._tokenStartOffset,
          endOffset: this._tokenEndOffset,
          startLine: this._tokenStartLine,
          endLine: this._tokenEndLine,
          startColumn: this._tokenStartColumn,
          endColumn: this._tokenEndColumn
        };
      },
      isEOF: function isEOF() {
        return this._cursor === this._string.length;
      },
      hasMoreTokens: function hasMoreTokens() {
        return this._cursor <= this._string.length;
      },
      _match: function _match(string, regexp) {
        var matched = string.match(regexp);
        if (matched) {
          this._captureLocation(matched[0]);
          this._cursor += matched[0].length;
          return matched[0];
        }
        return null;
      },
      onToken: function onToken(token) {
        return token;
      }
    };
    yy.lexer = tokenizer;
    yy.tokenizer = tokenizer;
    yy.options = {
      captureLocations: true
    };
    var yyparse = {
      setOptions: function setOptions2(options2) {
        yy.options = options2;
        return this;
      },
      getOptions: function getOptions2() {
        return yy.options;
      },
      parse: function parse(string, parseOptions) {
        if (!tokenizer) {
          throw new Error("Tokenizer instance wasn't specified.");
        }
        tokenizer.initString(string);
        var globalOptions = yy.options;
        if (parseOptions) {
          yy.options = Object.assign({}, yy.options, parseOptions);
        }
        yyparse.onParseBegin(string, tokenizer, yy.options);
        stack.length = 0;
        stack.push(0);
        var token = tokenizer.getNextToken();
        var shiftedToken = null;
        do {
          if (!token) {
            yy.options = globalOptions;
            unexpectedEndOfInput();
          }
          var state = stack[stack.length - 1];
          var column = tokens[token.type];
          if (!table[state].hasOwnProperty(column)) {
            yy.options = globalOptions;
            unexpectedToken(token);
          }
          var entry = table[state][column];
          if (entry[0] === "s") {
            var _loc2 = null;
            if (yy.options.captureLocations) {
              _loc2 = {
                startOffset: token.startOffset,
                endOffset: token.endOffset,
                startLine: token.startLine,
                endLine: token.endLine,
                startColumn: token.startColumn,
                endColumn: token.endColumn
              };
            }
            shiftedToken = this.onShift(token);
            stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));
            token = tokenizer.getNextToken();
          } else if (entry[0] === "r") {
            var productionNumber = entry.slice(1);
            var production = productions[productionNumber];
            var hasSemanticAction = typeof production[2] === "function";
            var semanticValueArgs = hasSemanticAction ? [] : null;
            var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;
            if (production[1] !== 0) {
              var rhsLength = production[1];
              while (rhsLength-- > 0) {
                stack.pop();
                var stackEntry = stack.pop();
                if (hasSemanticAction) {
                  semanticValueArgs.unshift(stackEntry.semanticValue);
                  if (locationArgs) {
                    locationArgs.unshift(stackEntry.loc);
                  }
                }
              }
            }
            var reduceStackEntry = { symbol: production[0] };
            if (hasSemanticAction) {
              yytext = shiftedToken ? shiftedToken.value : null;
              yyleng = shiftedToken ? shiftedToken.value.length : null;
              var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;
              production[2].apply(production, _toConsumableArray(semanticActionArgs));
              reduceStackEntry.semanticValue = __;
              if (locationArgs) {
                reduceStackEntry.loc = __loc;
              }
            }
            var nextState = stack[stack.length - 1];
            var symbolToReduceWith = production[0];
            stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
          } else if (entry === "acc") {
            stack.pop();
            var parsed = stack.pop();
            if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
              yy.options = globalOptions;
              unexpectedToken(token);
            }
            if (parsed.hasOwnProperty("semanticValue")) {
              yy.options = globalOptions;
              yyparse.onParseEnd(parsed.semanticValue);
              return parsed.semanticValue;
            }
            yyparse.onParseEnd();
            yy.options = globalOptions;
            return true;
          }
        } while (tokenizer.hasMoreTokens() || stack.length > 1);
      },
      setTokenizer: function setTokenizer(customTokenizer) {
        tokenizer = customTokenizer;
        return yyparse;
      },
      getTokenizer: function getTokenizer() {
        return tokenizer;
      },
      onParseBegin: function onParseBegin(string, tokenizer2, options2) {
      },
      onParseEnd: function onParseEnd(parsed) {
      },
      onShift: function onShift(token) {
        return token;
      }
    };
    var capturingGroupsCount = 0;
    var namedGroups = {};
    var parsingString = "";
    yyparse.onParseBegin = function(string, lexer2) {
      parsingString = string;
      capturingGroupsCount = 0;
      namedGroups = {};
      var lastSlash = string.lastIndexOf("/");
      var flags = string.slice(lastSlash);
      if (flags.includes("x") && flags.includes("u")) {
        lexer2.pushState("xu");
      } else {
        if (flags.includes("x")) {
          lexer2.pushState("x");
        }
        if (flags.includes("u")) {
          lexer2.pushState("u");
        }
      }
    };
    yyparse.onShift = function(token) {
      if (token.type === "L_PAREN" || token.type === "NAMED_CAPTURE_GROUP") {
        token.value = new String(token.value);
        token.value.groupNumber = ++capturingGroupsCount;
      }
      return token;
    };
    function getRange(text) {
      var range = text.match(/\d+/g).map(Number);
      if (Number.isFinite(range[1]) && range[1] < range[0]) {
        throw new SyntaxError("Numbers out of order in " + text + " quantifier");
      }
      return range;
    }
    function checkClassRange(from, to) {
      if (from.kind === "control" || to.kind === "control" || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {
        throw new SyntaxError("Range " + from.value + "-" + to.value + " out of order in character class");
      }
    }
    var unicodeProperties = require_parser_unicode_properties();
    function UnicodeProperty(matched, loc2) {
      var negative = matched[1] === "P";
      var separatorIdx = matched.indexOf("=");
      var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);
      var value = void 0;
      var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);
      var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);
      if (isShorthand) {
        value = name;
        name = "General_Category";
      } else if (isBinaryProperty) {
        value = name;
      } else {
        if (!unicodeProperties.isValidName(name)) {
          throw new SyntaxError("Invalid unicode property name: " + name + ".");
        }
        value = matched.slice(separatorIdx + 1, -1);
        if (!unicodeProperties.isValidValue(name, value)) {
          throw new SyntaxError("Invalid " + name + " unicode property value: " + value + ".");
        }
      }
      return Node2({
        type: "UnicodeProperty",
        name,
        value,
        negative,
        shorthand: isShorthand,
        binary: isBinaryProperty,
        canonicalName: unicodeProperties.getCanonicalName(name) || name,
        canonicalValue: unicodeProperties.getCanonicalValue(value) || value
      }, loc2);
    }
    function Char(value, kind, loc2) {
      var symbol = void 0;
      var codePoint = void 0;
      switch (kind) {
        case "decimal": {
          codePoint = Number(value.slice(1));
          symbol = String.fromCodePoint(codePoint);
          break;
        }
        case "oct": {
          codePoint = parseInt(value.slice(1), 8);
          symbol = String.fromCodePoint(codePoint);
          break;
        }
        case "hex":
        case "unicode": {
          if (value.lastIndexOf("\\u") > 0) {
            var _value$split$slice = value.split("\\u").slice(1), _value$split$slice2 = _slicedToArray(_value$split$slice, 2), lead = _value$split$slice2[0], trail = _value$split$slice2[1];
            lead = parseInt(lead, 16);
            trail = parseInt(trail, 16);
            codePoint = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            symbol = String.fromCodePoint(codePoint);
          } else {
            var hex = value.slice(2).replace("{", "");
            codePoint = parseInt(hex, 16);
            if (codePoint > 1114111) {
              throw new SyntaxError("Bad character escape sequence: " + value);
            }
            symbol = String.fromCodePoint(codePoint);
          }
          break;
        }
        case "meta": {
          switch (value) {
            case "\\t":
              symbol = "	";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\n":
              symbol = "\n";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\r":
              symbol = "\r";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\v":
              symbol = "\v";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\f":
              symbol = "\f";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\b":
              symbol = "\b";
              codePoint = symbol.codePointAt(0);
            case "\\0":
              symbol = "\0";
              codePoint = 0;
            case ".":
              symbol = ".";
              codePoint = NaN;
              break;
            default:
              codePoint = NaN;
          }
          break;
        }
        case "simple": {
          symbol = value;
          codePoint = symbol.codePointAt(0);
          break;
        }
      }
      return Node2({
        type: "Char",
        value,
        kind,
        symbol,
        codePoint
      }, loc2);
    }
    var validFlags = "gimsuxy";
    function checkFlags(flags) {
      var seen = /* @__PURE__ */ new Set();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = flags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var flag = _step.value;
          if (seen.has(flag) || !validFlags.includes(flag)) {
            throw new SyntaxError("Invalid flags: " + flags);
          }
          seen.add(flag);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return flags.split("").sort().join("");
    }
    function GroupRefOrDecChar(text, textLoc) {
      var reference = Number(text.slice(1));
      if (reference > 0 && reference <= capturingGroupsCount) {
        return Node2({
          type: "Backreference",
          kind: "number",
          number: reference,
          reference
        }, textLoc);
      }
      return Char(text, "decimal", textLoc);
    }
    var uReStart = /^\\u[0-9a-fA-F]{4}/;
    var ucpReStart = /^\\u\{[0-9a-fA-F]{1,}\}/;
    var ucpReAnywhere = /\\u\{[0-9a-fA-F]{1,}\}/;
    function validateUnicodeGroupName(name, state) {
      var isUnicodeName = ucpReAnywhere.test(name);
      var isUnicodeState = state === "u" || state === "xu" || state === "u_class";
      if (isUnicodeName && !isUnicodeState) {
        throw new SyntaxError('invalid group Unicode name "' + name + '", use `u` flag.');
      }
      return name;
    }
    var uidRe = /\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\})/;
    function decodeUnicodeGroupName(name) {
      return name.replace(new RegExp(uidRe, "g"), function(_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {
        if (leadSurrogate) {
          return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));
        }
        if (leadSurrogateOnly) {
          return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));
        }
        if (trailSurrogateOnly) {
          return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));
        }
        if (nonSurrogate) {
          return String.fromCodePoint(parseInt(nonSurrogate, 16));
        }
        if (codePoint) {
          return String.fromCodePoint(parseInt(codePoint, 16));
        }
        return _;
      });
    }
    function NamedGroupRefOrChars(text, textLoc) {
      var referenceRaw = text.slice(3, -1);
      var reference = decodeUnicodeGroupName(referenceRaw);
      if (namedGroups.hasOwnProperty(reference)) {
        return Node2({
          type: "Backreference",
          kind: "name",
          number: namedGroups[reference],
          reference,
          referenceRaw
        }, textLoc);
      }
      var startOffset = null;
      var startLine = null;
      var endLine = null;
      var startColumn = null;
      if (textLoc) {
        startOffset = textLoc.startOffset;
        startLine = textLoc.startLine;
        endLine = textLoc.endLine;
        startColumn = textLoc.startColumn;
      }
      var charRe = /^[\w$<>]/;
      var loc2 = void 0;
      var chars = [
        Char(text.slice(1, 2), "simple", startOffset ? {
          startLine,
          endLine,
          startColumn,
          startOffset,
          endOffset: startOffset += 2,
          endColumn: startColumn += 2
        } : null)
      ];
      chars[0].escaped = true;
      text = text.slice(2);
      while (text.length > 0) {
        var matched = null;
        if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {
          if (startOffset) {
            loc2 = {
              startLine,
              endLine,
              startColumn,
              startOffset,
              endOffset: startOffset += matched[0].length,
              endColumn: startColumn += matched[0].length
            };
          }
          chars.push(Char(matched[0], "unicode", loc2));
          text = text.slice(matched[0].length);
        } else if (matched = text.match(charRe)) {
          if (startOffset) {
            loc2 = {
              startLine,
              endLine,
              startColumn,
              startOffset,
              endOffset: ++startOffset,
              endColumn: ++startColumn
            };
          }
          chars.push(Char(matched[0], "simple", loc2));
          text = text.slice(1);
        }
      }
      return chars;
    }
    function Node2(node, loc2) {
      if (yy.options.captureLocations) {
        node.loc = {
          source: parsingString.slice(loc2.startOffset, loc2.endOffset),
          start: {
            line: loc2.startLine,
            column: loc2.startColumn,
            offset: loc2.startOffset
          },
          end: {
            line: loc2.endLine,
            column: loc2.endColumn,
            offset: loc2.endOffset
          }
        };
      }
      return node;
    }
    function loc(start, end) {
      if (!yy.options.captureLocations) {
        return null;
      }
      return {
        startOffset: start.startOffset,
        endOffset: end.endOffset,
        startLine: start.startLine,
        endLine: end.endLine,
        startColumn: start.startColumn,
        endColumn: end.endColumn
      };
    }
    function unexpectedToken(token) {
      if (token.type === EOF) {
        unexpectedEndOfInput();
      }
      tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);
    }
    function unexpectedEndOfInput() {
      parseError("Unexpected end of input.");
    }
    function parseError(message) {
      throw new SyntaxError(message);
    }
    module.exports = yyparse;
  }
});

// node_modules/regexp-tree/dist/parser/index.js
var require_parser = __commonJS({
  "node_modules/regexp-tree/dist/parser/index.js"(exports2, module) {
    "use strict";
    var regexpTreeParser = require_regexp_tree();
    var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);
    regexpTreeParser.parse = function(regexp, options2) {
      return generatedParseFn("" + regexp, options2);
    };
    regexpTreeParser.setOptions({ captureLocations: false });
    module.exports = regexpTreeParser;
  }
});

// node_modules/regexp-tree/dist/traverse/node-path.js
var require_node_path = __commonJS({
  "node_modules/regexp-tree/dist/traverse/node-path.js"(exports2, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var DEFAULT_COLLECTION_PROP = "expressions";
    var DEFAULT_SINGLE_PROP = "expression";
    var NodePath = function() {
      function NodePath2(node) {
        var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        _classCallCheck(this, NodePath2);
        this.node = node;
        this.parentPath = parentPath;
        this.parent = parentPath ? parentPath.node : null;
        this.property = property;
        this.index = index;
      }
      _createClass(NodePath2, [{
        key: "_enforceProp",
        value: function _enforceProp(property) {
          if (!this.node.hasOwnProperty(property)) {
            throw new Error("Node of type " + this.node.type + ` doesn't have "` + property + '" collection.');
          }
        }
      }, {
        key: "setChild",
        value: function setChild(node) {
          var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var childPath = void 0;
          if (index != null) {
            if (!property) {
              property = DEFAULT_COLLECTION_PROP;
            }
            this._enforceProp(property);
            this.node[property][index] = node;
            childPath = NodePath2.getForNode(node, this, property, index);
          } else {
            if (!property) {
              property = DEFAULT_SINGLE_PROP;
            }
            this._enforceProp(property);
            this.node[property] = node;
            childPath = NodePath2.getForNode(node, this, property, null);
          }
          return childPath;
        }
      }, {
        key: "appendChild",
        value: function appendChild(node) {
          var property = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          if (!property) {
            property = DEFAULT_COLLECTION_PROP;
          }
          this._enforceProp(property);
          var end = this.node[property].length;
          return this.setChild(node, end, property);
        }
      }, {
        key: "insertChildAt",
        value: function insertChildAt(node, index) {
          var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_COLLECTION_PROP;
          this._enforceProp(property);
          this.node[property].splice(index, 0, node);
          if (index <= NodePath2.getTraversingIndex()) {
            NodePath2.updateTraversingIndex(1);
          }
          this._rebuildIndex(this.node, property);
        }
      }, {
        key: "remove",
        value: function remove() {
          if (this.isRemoved()) {
            return;
          }
          NodePath2.registry.delete(this.node);
          this.node = null;
          if (!this.parent) {
            return;
          }
          if (this.index !== null) {
            this.parent[this.property].splice(this.index, 1);
            if (this.index <= NodePath2.getTraversingIndex()) {
              NodePath2.updateTraversingIndex(-1);
            }
            this._rebuildIndex(this.parent, this.property);
            this.index = null;
            this.property = null;
            return;
          }
          delete this.parent[this.property];
          this.property = null;
        }
      }, {
        key: "_rebuildIndex",
        value: function _rebuildIndex(parent, property) {
          var parentPath = NodePath2.getForNode(parent);
          for (var i = 0; i < parent[property].length; i++) {
            var path = NodePath2.getForNode(parent[property][i], parentPath, property, i);
            path.index = i;
          }
        }
      }, {
        key: "isRemoved",
        value: function isRemoved() {
          return this.node === null;
        }
      }, {
        key: "replace",
        value: function replace(newNode) {
          NodePath2.registry.delete(this.node);
          this.node = newNode;
          if (!this.parent) {
            return null;
          }
          if (this.index !== null) {
            this.parent[this.property][this.index] = newNode;
          } else {
            this.parent[this.property] = newNode;
          }
          return NodePath2.getForNode(newNode, this.parentPath, this.property, this.index);
        }
      }, {
        key: "update",
        value: function update(nodeProps) {
          Object.assign(this.node, nodeProps);
        }
      }, {
        key: "getParent",
        value: function getParent() {
          return this.parentPath;
        }
      }, {
        key: "getChild",
        value: function getChild() {
          var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this.node.expressions) {
            return NodePath2.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);
          } else if (this.node.expression && n == 0) {
            return NodePath2.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);
          }
          return null;
        }
      }, {
        key: "hasEqualSource",
        value: function hasEqualSource(path) {
          return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);
        }
      }, {
        key: "jsonEncode",
        value: function jsonEncode() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, format2 = _ref.format, useLoc = _ref.useLoc;
          return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format2);
        }
      }, {
        key: "getPreviousSibling",
        value: function getPreviousSibling() {
          if (!this.parent || this.index == null) {
            return null;
          }
          return NodePath2.getForNode(this.parent[this.property][this.index - 1], NodePath2.getForNode(this.parent), this.property, this.index - 1);
        }
      }, {
        key: "getNextSibling",
        value: function getNextSibling() {
          if (!this.parent || this.index == null) {
            return null;
          }
          return NodePath2.getForNode(this.parent[this.property][this.index + 1], NodePath2.getForNode(this.parent), this.property, this.index + 1);
        }
      }], [{
        key: "getForNode",
        value: function getForNode(node) {
          var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
          if (!node) {
            return null;
          }
          if (!NodePath2.registry.has(node)) {
            NodePath2.registry.set(node, new NodePath2(node, parentPath, prop, index == -1 ? null : index));
          }
          var path = NodePath2.registry.get(node);
          if (parentPath !== null) {
            path.parentPath = parentPath;
            path.parent = path.parentPath.node;
          }
          if (prop !== null) {
            path.property = prop;
          }
          if (index >= 0) {
            path.index = index;
          }
          return path;
        }
      }, {
        key: "initRegistry",
        value: function initRegistry() {
          if (!NodePath2.registry) {
            NodePath2.registry = /* @__PURE__ */ new Map();
          }
          NodePath2.registry.clear();
        }
      }, {
        key: "updateTraversingIndex",
        value: function updateTraversingIndex(dx) {
          return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1] += dx;
        }
      }, {
        key: "getTraversingIndex",
        value: function getTraversingIndex() {
          return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1];
        }
      }]);
      return NodePath2;
    }();
    NodePath.initRegistry();
    NodePath.traversingIndexStack = [];
    function jsonSkipLoc(prop, value) {
      if (prop === "loc") {
        return void 0;
      }
      return value;
    }
    module.exports = NodePath;
  }
});

// node_modules/regexp-tree/dist/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/regexp-tree/dist/traverse/index.js"(exports2, module) {
    "use strict";
    var NodePath = require_node_path();
    function astTraverse(root) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var pre = options2.pre;
      var post = options2.post;
      var skipProperty = options2.skipProperty;
      function visit(node, parent, prop, idx) {
        if (!node || typeof node.type !== "string") {
          return;
        }
        var res = void 0;
        if (pre) {
          res = pre(node, parent, prop, idx);
        }
        if (res !== false) {
          if (parent && parent[prop]) {
            if (!isNaN(idx)) {
              node = parent[prop][idx];
            } else {
              node = parent[prop];
            }
          }
          for (var _prop in node) {
            if (node.hasOwnProperty(_prop)) {
              if (skipProperty ? skipProperty(_prop, node) : _prop[0] === "$") {
                continue;
              }
              var child = node[_prop];
              if (Array.isArray(child)) {
                var index = 0;
                NodePath.traversingIndexStack.push(index);
                while (index < child.length) {
                  visit(child[index], node, _prop, index);
                  index = NodePath.updateTraversingIndex(1);
                }
                NodePath.traversingIndexStack.pop();
              } else {
                visit(child, node, _prop);
              }
            }
          }
        }
        if (post) {
          post(node, parent, prop, idx);
        }
      }
      visit(root, null);
    }
    module.exports = {
      traverse: function traverse(ast, handlers) {
        var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { asNodes: false };
        if (!Array.isArray(handlers)) {
          handlers = [handlers];
        }
        handlers = handlers.filter(function(handler) {
          if (typeof handler.shouldRun !== "function") {
            return true;
          }
          return handler.shouldRun(ast);
        });
        NodePath.initRegistry();
        handlers.forEach(function(handler) {
          if (typeof handler.init === "function") {
            handler.init(ast);
          }
        });
        function getPathFor(node, parent, prop, index) {
          var parentPath = NodePath.getForNode(parent);
          var nodePath = NodePath.getForNode(node, parentPath, prop, index);
          return nodePath;
        }
        astTraverse(ast, {
          pre: function pre(node, parent, prop, index) {
            var nodePath = void 0;
            if (!options2.asNodes) {
              nodePath = getPathFor(node, parent, prop, index);
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var handler = _step.value;
                if (typeof handler["*"] === "function") {
                  if (nodePath) {
                    if (!nodePath.isRemoved()) {
                      var handlerResult = handler["*"](nodePath);
                      if (handlerResult === false) {
                        return false;
                      }
                    }
                  } else {
                    handler["*"](node, parent, prop, index);
                  }
                }
                var handlerFuncPre = void 0;
                if (typeof handler[node.type] === "function") {
                  handlerFuncPre = handler[node.type];
                } else if (typeof handler[node.type] === "object" && typeof handler[node.type].pre === "function") {
                  handlerFuncPre = handler[node.type].pre;
                }
                if (handlerFuncPre) {
                  if (nodePath) {
                    if (!nodePath.isRemoved()) {
                      var _handlerResult = handlerFuncPre.call(handler, nodePath);
                      if (_handlerResult === false) {
                        return false;
                      }
                    }
                  } else {
                    handlerFuncPre.call(handler, node, parent, prop, index);
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          },
          post: function post(node, parent, prop, index) {
            if (!node) {
              return;
            }
            var nodePath = void 0;
            if (!options2.asNodes) {
              nodePath = getPathFor(node, parent, prop, index);
            }
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var handler = _step2.value;
                var handlerFuncPost = void 0;
                if (typeof handler[node.type] === "object" && typeof handler[node.type].post === "function") {
                  handlerFuncPost = handler[node.type].post;
                }
                if (handlerFuncPost) {
                  if (nodePath) {
                    if (!nodePath.isRemoved()) {
                      var handlerResult = handlerFuncPost.call(handler, nodePath);
                      if (handlerResult === false) {
                        return false;
                      }
                    }
                  } else {
                    handlerFuncPost.call(handler, node, parent, prop, index);
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          },
          skipProperty: function skipProperty(prop) {
            return prop === "loc";
          }
        });
      }
    };
  }
});

// node_modules/regexp-tree/dist/transform/index.js
var require_transform = __commonJS({
  "node_modules/regexp-tree/dist/transform/index.js"(exports2, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var generator = require_generator();
    var parser2 = require_parser();
    var traverse = require_traverse();
    var TransformResult = function() {
      function TransformResult2(ast) {
        var extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, TransformResult2);
        this._ast = ast;
        this._source = null;
        this._string = null;
        this._regexp = null;
        this._extra = extra;
      }
      _createClass(TransformResult2, [{
        key: "getAST",
        value: function getAST() {
          return this._ast;
        }
      }, {
        key: "setExtra",
        value: function setExtra(extra) {
          this._extra = extra;
        }
      }, {
        key: "getExtra",
        value: function getExtra() {
          return this._extra;
        }
      }, {
        key: "toRegExp",
        value: function toRegExp() {
          if (!this._regexp) {
            this._regexp = new RegExp(this.getSource(), this._ast.flags);
          }
          return this._regexp;
        }
      }, {
        key: "getSource",
        value: function getSource() {
          if (!this._source) {
            this._source = generator.generate(this._ast.body);
          }
          return this._source;
        }
      }, {
        key: "getFlags",
        value: function getFlags() {
          return this._ast.flags;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (!this._string) {
            this._string = generator.generate(this._ast);
          }
          return this._string;
        }
      }]);
      return TransformResult2;
    }();
    module.exports = {
      TransformResult,
      transform: function transform(regexp, handlers) {
        var ast = regexp;
        if (regexp instanceof RegExp) {
          regexp = "" + regexp;
        }
        if (typeof regexp === "string") {
          ast = parser2.parse(regexp, {
            captureLocations: true
          });
        }
        traverse.traverse(ast, handlers);
        return new TransformResult(ast);
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/index.js
var require_compat_transpiler = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/index.js"(exports2, module) {
    "use strict";
    var compatTransforms = require_transforms();
    var _transform = require_transform();
    module.exports = {
      transform: function transform(regexp) {
        var transformsWhitelist = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var transformToApply = transformsWhitelist.length > 0 ? transformsWhitelist : Object.keys(compatTransforms);
        var result = void 0;
        var extra = {};
        transformToApply.forEach(function(transformName) {
          if (!compatTransforms.hasOwnProperty(transformName)) {
            throw new Error("Unknown compat-transform: " + transformName + ". Available transforms are: " + Object.keys(compatTransforms).join(", "));
          }
          var handler = compatTransforms[transformName];
          result = _transform.transform(regexp, handler);
          regexp = result.getAST();
          if (typeof handler.getExtra === "function") {
            extra[transformName] = handler.getExtra();
          }
        });
        result.setExtra(extra);
        return result;
      }
    };
  }
});

// node_modules/regexp-tree/dist/utils/clone.js
var require_clone = __commonJS({
  "node_modules/regexp-tree/dist/utils/clone.js"(exports2, module) {
    "use strict";
    module.exports = function clone(obj) {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      var res = void 0;
      if (Array.isArray(obj)) {
        res = [];
      } else {
        res = {};
      }
      for (var i in obj) {
        res[i] = clone(obj[i]);
      }
      return res;
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js
var require_char_surrogate_pair_to_single_unicode_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      shouldRun: function shouldRun(ast) {
        return ast.flags.includes("u");
      },
      Char: function Char(path) {
        var node = path.node;
        if (node.kind !== "unicode" || !node.isSurrogatePair || isNaN(node.codePoint)) {
          return;
        }
        node.value = "\\u{" + node.codePoint.toString(16) + "}";
        delete node.isSurrogatePair;
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js
var require_char_code_to_simple_char_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js"(exports2, module) {
    "use strict";
    var UPPER_A_CP = "A".codePointAt(0);
    var UPPER_Z_CP = "Z".codePointAt(0);
    var LOWER_A_CP = "a".codePointAt(0);
    var LOWER_Z_CP = "z".codePointAt(0);
    var DIGIT_0_CP = "0".codePointAt(0);
    var DIGIT_9_CP = "9".codePointAt(0);
    module.exports = {
      Char: function Char(path) {
        var node = path.node, parent = path.parent;
        if (isNaN(node.codePoint) || node.kind === "simple") {
          return;
        }
        if (parent.type === "ClassRange") {
          if (!isSimpleRange(parent)) {
            return;
          }
        }
        if (!isPrintableASCIIChar(node.codePoint)) {
          return;
        }
        var symbol = String.fromCodePoint(node.codePoint);
        var newChar = {
          type: "Char",
          kind: "simple",
          value: symbol,
          symbol,
          codePoint: node.codePoint
        };
        if (needsEscape(symbol, parent.type)) {
          newChar.escaped = true;
        }
        path.replace(newChar);
      }
    };
    function isSimpleRange(classRange) {
      var from = classRange.from, to = classRange.to;
      return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;
    }
    function isPrintableASCIIChar(codePoint) {
      return codePoint >= 32 && codePoint <= 126;
    }
    function needsEscape(symbol, parentType) {
      if (parentType === "ClassRange" || parentType === "CharacterClass") {
        return /[\]\\^-]/.test(symbol);
      }
      return /[*[()+?^$./\\|{}]/.test(symbol);
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js
var require_char_case_insensitive_lowercase_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js"(exports2, module) {
    "use strict";
    var UPPER_A_CP = "A".codePointAt(0);
    var UPPER_Z_CP = "Z".codePointAt(0);
    module.exports = {
      _AZClassRanges: null,
      _hasUFlag: false,
      init: function init(ast) {
        this._AZClassRanges = /* @__PURE__ */ new Set();
        this._hasUFlag = ast.flags.includes("u");
      },
      shouldRun: function shouldRun(ast) {
        return ast.flags.includes("i");
      },
      Char: function Char(path) {
        var node = path.node, parent = path.parent;
        if (isNaN(node.codePoint)) {
          return;
        }
        if (!this._hasUFlag && node.codePoint >= 4096) {
          return;
        }
        if (parent.type === "ClassRange") {
          if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {
            return;
          }
          this._AZClassRanges.add(parent);
        }
        var lower = node.symbol.toLowerCase();
        if (lower !== node.symbol) {
          node.value = displaySymbolAsValue(lower, node);
          node.symbol = lower;
          node.codePoint = lower.codePointAt(0);
        }
      }
    };
    function isAZClassRange(classRange) {
      var from = classRange.from, to = classRange.to;
      return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;
    }
    function displaySymbolAsValue(symbol, node) {
      var codePoint = symbol.codePointAt(0);
      if (node.kind === "decimal") {
        return "\\" + codePoint;
      }
      if (node.kind === "oct") {
        return "\\0" + codePoint.toString(8);
      }
      if (node.kind === "hex") {
        return "\\x" + codePoint.toString(16);
      }
      if (node.kind === "unicode") {
        if (node.isSurrogatePair) {
          var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint), lead = _getSurrogatePairFrom.lead, trail = _getSurrogatePairFrom.trail;
          return "\\u" + "0".repeat(4 - lead.length) + lead + "\\u" + "0".repeat(4 - trail.length) + trail;
        } else if (node.value.includes("{")) {
          return "\\u{" + codePoint.toString(16) + "}";
        } else {
          var code = codePoint.toString(16);
          return "\\u" + "0".repeat(4 - code.length) + code;
        }
      }
      return symbol;
    }
    function getSurrogatePairFromCodePoint(codePoint) {
      var lead = Math.floor((codePoint - 65536) / 1024) + 55296;
      var trail = (codePoint - 65536) % 1024 + 56320;
      return {
        lead: lead.toString(16),
        trail: trail.toString(16)
      };
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js
var require_char_class_remove_duplicates_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      CharacterClass: function CharacterClass(path) {
        var node = path.node;
        var sources = {};
        for (var i = 0; i < node.expressions.length; i++) {
          var childPath = path.getChild(i);
          var source = childPath.jsonEncode();
          if (sources.hasOwnProperty(source)) {
            childPath.remove();
            i--;
          }
          sources[source] = true;
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/transform/utils.js
var require_utils = __commonJS({
  "node_modules/regexp-tree/dist/transform/utils.js"(exports2, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function disjunctionToList(node) {
      if (node.type !== "Disjunction") {
        throw new TypeError('Expected "Disjunction" node, got "' + node.type + '"');
      }
      var list = [];
      if (node.left && node.left.type === "Disjunction") {
        list.push.apply(list, _toConsumableArray(disjunctionToList(node.left)).concat([node.right]));
      } else {
        list.push(node.left, node.right);
      }
      return list;
    }
    function listToDisjunction(list) {
      return list.reduce(function(left, right) {
        return {
          type: "Disjunction",
          left,
          right
        };
      });
    }
    function increaseQuantifierByOne(quantifier) {
      if (quantifier.kind === "*") {
        quantifier.kind = "+";
      } else if (quantifier.kind === "+") {
        quantifier.kind = "Range";
        quantifier.from = 2;
        delete quantifier.to;
      } else if (quantifier.kind === "?") {
        quantifier.kind = "Range";
        quantifier.from = 1;
        quantifier.to = 2;
      } else if (quantifier.kind === "Range") {
        quantifier.from += 1;
        if (quantifier.to) {
          quantifier.to += 1;
        }
      }
    }
    module.exports = {
      disjunctionToList,
      listToDisjunction,
      increaseQuantifierByOne
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js
var require_quantifiers_merge_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js"(exports2, module) {
    "use strict";
    var _require = require_utils();
    var increaseQuantifierByOne = _require.increaseQuantifierByOne;
    module.exports = {
      Repetition: function Repetition(path) {
        var node = path.node, parent = path.parent;
        if (parent.type !== "Alternative" || !path.index) {
          return;
        }
        var previousSibling = path.getPreviousSibling();
        if (!previousSibling) {
          return;
        }
        if (previousSibling.node.type === "Repetition") {
          if (!previousSibling.getChild().hasEqualSource(path.getChild())) {
            return;
          }
          var _extractFromTo = extractFromTo(previousSibling.node.quantifier), previousSiblingFrom = _extractFromTo.from, previousSiblingTo = _extractFromTo.to;
          var _extractFromTo2 = extractFromTo(node.quantifier), nodeFrom = _extractFromTo2.from, nodeTo = _extractFromTo2.to;
          if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {
            return;
          }
          node.quantifier.kind = "Range";
          node.quantifier.from = previousSiblingFrom + nodeFrom;
          if (previousSiblingTo && nodeTo) {
            node.quantifier.to = previousSiblingTo + nodeTo;
          } else {
            delete node.quantifier.to;
          }
          if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {
            node.quantifier.greedy = true;
          }
          previousSibling.remove();
        } else {
          if (!previousSibling.hasEqualSource(path.getChild())) {
            return;
          }
          increaseQuantifierByOne(node.quantifier);
          previousSibling.remove();
        }
      }
    };
    function isGreedyOpenRange(quantifier) {
      return quantifier.greedy && (quantifier.kind === "+" || quantifier.kind === "*" || quantifier.kind === "Range" && !quantifier.to);
    }
    function extractFromTo(quantifier) {
      var from = void 0, to = void 0;
      if (quantifier.kind === "*") {
        from = 0;
      } else if (quantifier.kind === "+") {
        from = 1;
      } else if (quantifier.kind === "?") {
        from = 0;
        to = 1;
      } else {
        from = quantifier.from;
        if (quantifier.to) {
          to = quantifier.to;
        }
      }
      return { from, to };
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js
var require_quantifier_range_to_symbol_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      Quantifier: function Quantifier(path) {
        var node = path.node;
        if (node.kind !== "Range") {
          return;
        }
        rewriteOpenZero(path);
        rewriteOpenOne(path);
        rewriteExactOne(path);
      }
    };
    function rewriteOpenZero(path) {
      var node = path.node;
      if (node.from !== 0 || node.to) {
        return;
      }
      node.kind = "*";
      delete node.from;
    }
    function rewriteOpenOne(path) {
      var node = path.node;
      if (node.from !== 1 || node.to) {
        return;
      }
      node.kind = "+";
      delete node.from;
    }
    function rewriteExactOne(path) {
      var node = path.node;
      if (node.from !== 1 || node.to !== 1) {
        return;
      }
      path.parentPath.replace(path.parentPath.node.expression);
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js
var require_char_class_classranges_to_chars_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      ClassRange: function ClassRange(path) {
        var node = path.node;
        if (node.from.codePoint === node.to.codePoint) {
          path.replace(node.from);
        } else if (node.from.codePoint === node.to.codePoint - 1) {
          path.getParent().insertChildAt(node.to, path.index + 1);
          path.replace(node.from);
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js
var require_char_class_to_meta_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js"(exports2, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module.exports = {
      _hasIFlag: false,
      _hasUFlag: false,
      init: function init(ast) {
        this._hasIFlag = ast.flags.includes("i");
        this._hasUFlag = ast.flags.includes("u");
      },
      CharacterClass: function CharacterClass(path) {
        rewriteNumberRanges(path);
        rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);
        rewriteWhitespaceRanges(path);
      }
    };
    function rewriteNumberRanges(path) {
      var node = path.node;
      node.expressions.forEach(function(expression, i) {
        if (isFullNumberRange(expression)) {
          path.getChild(i).replace({
            type: "Char",
            value: "\\d",
            kind: "meta"
          });
        }
      });
    }
    function rewriteWordRanges(path, hasIFlag, hasUFlag) {
      var node = path.node;
      var numberPath = null;
      var lowerCasePath = null;
      var upperCasePath = null;
      var underscorePath = null;
      var u017fPath = null;
      var u212aPath = null;
      node.expressions.forEach(function(expression, i) {
        if (isMetaChar(expression, "\\d")) {
          numberPath = path.getChild(i);
        } else if (isLowerCaseRange(expression)) {
          lowerCasePath = path.getChild(i);
        } else if (isUpperCaseRange(expression)) {
          upperCasePath = path.getChild(i);
        } else if (isUnderscore(expression)) {
          underscorePath = path.getChild(i);
        } else if (hasIFlag && hasUFlag && isCodePoint(expression, 383)) {
          u017fPath = path.getChild(i);
        } else if (hasIFlag && hasUFlag && isCodePoint(expression, 8490)) {
          u212aPath = path.getChild(i);
        }
      });
      if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {
        numberPath.replace({
          type: "Char",
          value: "\\w",
          kind: "meta"
        });
        if (lowerCasePath) {
          lowerCasePath.remove();
        }
        if (upperCasePath) {
          upperCasePath.remove();
        }
        underscorePath.remove();
        if (u017fPath) {
          u017fPath.remove();
        }
        if (u212aPath) {
          u212aPath.remove();
        }
      }
    }
    var whitespaceRangeTests = [function(node) {
      return isChar(node, " ");
    }].concat(_toConsumableArray(["\\f", "\\n", "\\r", "\\t", "\\v"].map(function(char) {
      return function(node) {
        return isMetaChar(node, char);
      };
    })), _toConsumableArray([160, 5760, 8232, 8233, 8239, 8287, 12288, 65279].map(function(codePoint) {
      return function(node) {
        return isCodePoint(node, codePoint);
      };
    })), [function(node) {
      return node.type === "ClassRange" && isCodePoint(node.from, 8192) && isCodePoint(node.to, 8202);
    }]);
    function rewriteWhitespaceRanges(path) {
      var node = path.node;
      if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function(test) {
        return node.expressions.some(function(expression) {
          return test(expression);
        });
      })) {
        return;
      }
      var nNode = node.expressions.find(function(expression) {
        return isMetaChar(expression, "\\n");
      });
      nNode.value = "\\s";
      nNode.symbol = void 0;
      nNode.codePoint = NaN;
      node.expressions.map(function(expression, i) {
        return whitespaceRangeTests.some(function(test) {
          return test(expression);
        }) ? path.getChild(i) : void 0;
      }).filter(Boolean).forEach(function(path2) {
        return path2.remove();
      });
    }
    function isFullNumberRange(node) {
      return node.type === "ClassRange" && node.from.value === "0" && node.to.value === "9";
    }
    function isChar(node, value) {
      var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "simple";
      return node.type === "Char" && node.value === value && node.kind === kind;
    }
    function isMetaChar(node, value) {
      return isChar(node, value, "meta");
    }
    function isLowerCaseRange(node) {
      return node.type === "ClassRange" && node.from.value === "a" && node.to.value === "z";
    }
    function isUpperCaseRange(node) {
      return node.type === "ClassRange" && node.from.value === "A" && node.to.value === "Z";
    }
    function isUnderscore(node) {
      return node.type === "Char" && node.value === "_" && node.kind === "simple";
    }
    function isCodePoint(node, codePoint) {
      return node.type === "Char" && node.kind === "unicode" && node.codePoint === codePoint;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js
var require_char_class_to_single_char_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      CharacterClass: function CharacterClass(path) {
        var node = path.node;
        if (node.expressions.length !== 1 || !hasAppropriateSiblings(path) || !isAppropriateChar(node.expressions[0])) {
          return;
        }
        var _node$expressions$ = node.expressions[0], value = _node$expressions$.value, kind = _node$expressions$.kind, escaped = _node$expressions$.escaped;
        if (node.negative) {
          if (!isMeta(value)) {
            return;
          }
          value = getInverseMeta(value);
        }
        path.replace({
          type: "Char",
          value,
          kind,
          escaped: escaped || shouldEscape(value)
        });
      }
    };
    function isAppropriateChar(node) {
      return node.type === "Char" && node.value !== "\\b";
    }
    function isMeta(value) {
      return /^\\[dwsDWS]$/.test(value);
    }
    function getInverseMeta(value) {
      return /[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase();
    }
    function hasAppropriateSiblings(path) {
      var parent = path.parent, index = path.index;
      if (parent.type !== "Alternative") {
        return true;
      }
      var previousNode = parent.expressions[index - 1];
      if (previousNode == null) {
        return true;
      }
      if (previousNode.type === "Backreference" && previousNode.kind === "number") {
        return false;
      }
      if (previousNode.type === "Char" && previousNode.kind === "decimal") {
        return false;
      }
      return true;
    }
    function shouldEscape(value) {
      return /[*[()+?$./{}|]/.test(value);
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js
var require_char_escape_unescape_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      _hasXFlag: false,
      init: function init(ast) {
        this._hasXFlag = ast.flags.includes("x");
      },
      Char: function Char(path) {
        var node = path.node;
        if (!node.escaped) {
          return;
        }
        if (shouldUnescape(path, this._hasXFlag)) {
          delete node.escaped;
        }
      }
    };
    function shouldUnescape(path, hasXFlag) {
      var value = path.node.value, index = path.index, parent = path.parent;
      if (parent.type !== "CharacterClass" && parent.type !== "ClassRange") {
        return !preservesEscape(value, index, parent, hasXFlag);
      }
      return !preservesInCharClass(value, index, parent);
    }
    function preservesInCharClass(value, index, parent) {
      if (value === "^") {
        return index === 0 && !parent.negative;
      }
      if (value === "-") {
        return true;
      }
      return /[\]\\]/.test(value);
    }
    function preservesEscape(value, index, parent, hasXFlag) {
      if (value === "{") {
        return preservesOpeningCurlyBraceEscape(index, parent);
      }
      if (value === "}") {
        return preservesClosingCurlyBraceEscape(index, parent);
      }
      if (hasXFlag && /[ #]/.test(value)) {
        return true;
      }
      return /[*[()+?^$./\\|]/.test(value);
    }
    function consumeNumbers(startIndex, parent, rtl) {
      var i = startIndex;
      var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
      while (siblingNode && siblingNode.type === "Char" && siblingNode.kind === "simple" && !siblingNode.escaped && /\d/.test(siblingNode.value)) {
        rtl ? i-- : i++;
        siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
      }
      return Math.abs(startIndex - i);
    }
    function isSimpleChar(node, value) {
      return node && node.type === "Char" && node.kind === "simple" && !node.escaped && node.value === value;
    }
    function preservesOpeningCurlyBraceEscape(index, parent) {
      if (index == null) {
        return false;
      }
      var nbFollowingNumbers = consumeNumbers(index + 1, parent);
      var i = index + nbFollowingNumbers + 1;
      var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
      if (nbFollowingNumbers) {
        if (isSimpleChar(nextSiblingNode, "}")) {
          return true;
        }
        if (isSimpleChar(nextSiblingNode, ",")) {
          nbFollowingNumbers = consumeNumbers(i + 1, parent);
          i = i + nbFollowingNumbers + 1;
          nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
          return isSimpleChar(nextSiblingNode, "}");
        }
      }
      return false;
    }
    function preservesClosingCurlyBraceEscape(index, parent) {
      if (index == null) {
        return false;
      }
      var nbPrecedingNumbers = consumeNumbers(index - 1, parent, true);
      var i = index - nbPrecedingNumbers - 1;
      var previousSiblingNode = i >= 0 && parent.expressions[i];
      if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{")) {
        return true;
      }
      if (isSimpleChar(previousSiblingNode, ",")) {
        nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);
        i = i - nbPrecedingNumbers - 1;
        previousSiblingNode = i < parent.expressions.length && parent.expressions[i];
        return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{");
      }
      return false;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js
var require_char_class_classranges_merge_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      _hasIUFlags: false,
      init: function init(ast) {
        this._hasIUFlags = ast.flags.includes("i") && ast.flags.includes("u");
      },
      CharacterClass: function CharacterClass(path) {
        var node = path.node;
        var expressions = node.expressions;
        var metas = [];
        expressions.forEach(function(expression2) {
          if (isMeta(expression2)) {
            metas.push(expression2.value);
          }
        });
        expressions.sort(sortCharClass);
        for (var i = 0; i < expressions.length; i++) {
          var expression = expressions[i];
          if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {
            expressions.splice(i, 1);
            i--;
          } else {
            var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);
            expressions.splice(i - nbMergedChars + 1, nbMergedChars);
            i -= nbMergedChars;
          }
        }
      }
    };
    function sortCharClass(a, b) {
      var aValue = getSortValue(a);
      var bValue = getSortValue(b);
      if (aValue === bValue) {
        if (a.type === "ClassRange" && b.type !== "ClassRange") {
          return -1;
        }
        if (b.type === "ClassRange" && a.type !== "ClassRange") {
          return 1;
        }
        if (a.type === "ClassRange" && b.type === "ClassRange") {
          return getSortValue(a.to) - getSortValue(b.to);
        }
        if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {
          return a.value < b.value ? -1 : 1;
        }
      }
      return aValue - bValue;
    }
    function getSortValue(expression) {
      if (expression.type === "Char") {
        if (expression.value === "-") {
          return Infinity;
        }
        if (expression.kind === "control") {
          return Infinity;
        }
        if (expression.kind === "meta" && isNaN(expression.codePoint)) {
          return -1;
        }
        return expression.codePoint;
      }
      return expression.from.codePoint;
    }
    function isMeta(expression) {
      var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return expression.type === "Char" && expression.kind === "meta" && (value ? expression.value === value : /^\\[dws]$/i.test(expression.value));
    }
    function isControl(expression) {
      return expression.type === "Char" && expression.kind === "control";
    }
    function fitsInMetas(expression, metas, hasIUFlags) {
      for (var i = 0; i < metas.length; i++) {
        if (fitsInMeta(expression, metas[i], hasIUFlags)) {
          return true;
        }
      }
      return false;
    }
    function fitsInMeta(expression, meta, hasIUFlags) {
      if (expression.type === "ClassRange") {
        return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);
      }
      if (meta === "\\S" && (isMeta(expression, "\\w") || isMeta(expression, "\\d"))) {
        return true;
      }
      if (meta === "\\D" && (isMeta(expression, "\\W") || isMeta(expression, "\\s"))) {
        return true;
      }
      if (meta === "\\w" && isMeta(expression, "\\d")) {
        return true;
      }
      if (meta === "\\W" && isMeta(expression, "\\s")) {
        return true;
      }
      if (expression.type !== "Char" || isNaN(expression.codePoint)) {
        return false;
      }
      if (meta === "\\s") {
        return fitsInMetaS(expression);
      }
      if (meta === "\\S") {
        return !fitsInMetaS(expression);
      }
      if (meta === "\\d") {
        return fitsInMetaD(expression);
      }
      if (meta === "\\D") {
        return !fitsInMetaD(expression);
      }
      if (meta === "\\w") {
        return fitsInMetaW(expression, hasIUFlags);
      }
      if (meta === "\\W") {
        return !fitsInMetaW(expression, hasIUFlags);
      }
      return false;
    }
    function fitsInMetaS(expression) {
      return expression.codePoint === 9 || expression.codePoint === 10 || expression.codePoint === 11 || expression.codePoint === 12 || expression.codePoint === 13 || expression.codePoint === 32 || expression.codePoint === 160 || expression.codePoint === 5760 || expression.codePoint >= 8192 && expression.codePoint <= 8202 || expression.codePoint === 8232 || expression.codePoint === 8233 || expression.codePoint === 8239 || expression.codePoint === 8287 || expression.codePoint === 12288 || expression.codePoint === 65279;
    }
    function fitsInMetaD(expression) {
      return expression.codePoint >= 48 && expression.codePoint <= 57;
    }
    function fitsInMetaW(expression, hasIUFlags) {
      return fitsInMetaD(expression) || expression.codePoint >= 65 && expression.codePoint <= 90 || expression.codePoint >= 97 && expression.codePoint <= 122 || expression.value === "_" || hasIUFlags && (expression.codePoint === 383 || expression.codePoint === 8490);
    }
    function combinesWithPrecedingClassRange(expression, classRange) {
      if (classRange && classRange.type === "ClassRange") {
        if (fitsInClassRange(expression, classRange)) {
          return true;
        } else if (isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1) {
          classRange.to = expression;
          return true;
        } else if (expression.type === "ClassRange" && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {
          if (expression.from.codePoint < classRange.from.codePoint) {
            classRange.from = expression.from;
          }
          if (expression.to.codePoint > classRange.to.codePoint) {
            classRange.to = expression.to;
          }
          return true;
        }
      }
      return false;
    }
    function combinesWithFollowingClassRange(expression, classRange) {
      if (classRange && classRange.type === "ClassRange") {
        if (isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1) {
          classRange.from = expression;
          return true;
        }
      }
      return false;
    }
    function fitsInClassRange(expression, classRange) {
      if (expression.type === "Char" && isNaN(expression.codePoint)) {
        return false;
      }
      if (expression.type === "ClassRange") {
        return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);
      }
      return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;
    }
    function charCombinesWithPrecedingChars(expression, index, expressions) {
      if (!isMetaWCharOrCode(expression)) {
        return 0;
      }
      var nbMergedChars = 0;
      while (index > 0) {
        var currentExpression = expressions[index];
        var precedingExpresion = expressions[index - 1];
        if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {
          nbMergedChars++;
          index--;
        } else {
          break;
        }
      }
      if (nbMergedChars > 1) {
        expressions[index] = {
          type: "ClassRange",
          from: expressions[index],
          to: expression
        };
        return nbMergedChars;
      }
      return 0;
    }
    function isMetaWCharOrCode(expression) {
      return expression && expression.type === "Char" && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === "unicode" || expression.kind === "hex" || expression.kind === "oct" || expression.kind === "decimal");
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js
var require_disjunction_remove_duplicates_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js"(exports2, module) {
    "use strict";
    var NodePath = require_node_path();
    var _require = require_utils();
    var disjunctionToList = _require.disjunctionToList;
    var listToDisjunction = _require.listToDisjunction;
    module.exports = {
      Disjunction: function Disjunction(path) {
        var node = path.node;
        var uniqueNodesMap = {};
        var parts2 = disjunctionToList(node).filter(function(part) {
          var encoded = part ? NodePath.getForNode(part).jsonEncode() : "null";
          if (uniqueNodesMap.hasOwnProperty(encoded)) {
            return false;
          }
          uniqueNodesMap[encoded] = part;
          return true;
        });
        path.replace(listToDisjunction(parts2));
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js
var require_group_single_chars_to_char_class = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js"(exports2, module) {
    "use strict";
    module.exports = {
      Disjunction: function Disjunction(path) {
        var node = path.node, parent = path.parent;
        if (!handlers[parent.type]) {
          return;
        }
        var charset = /* @__PURE__ */ new Map();
        if (!shouldProcess(node, charset) || !charset.size) {
          return;
        }
        var characterClass = {
          type: "CharacterClass",
          expressions: Array.from(charset.keys()).sort().map(function(key) {
            return charset.get(key);
          })
        };
        handlers[parent.type](path.getParent(), characterClass);
      }
    };
    var handlers = {
      RegExp: function RegExp2(path, characterClass) {
        var node = path.node;
        node.body = characterClass;
      },
      Group: function Group(path, characterClass) {
        var node = path.node;
        if (node.capturing) {
          node.expression = characterClass;
        } else {
          path.replace(characterClass);
        }
      }
    };
    function shouldProcess(expression, charset) {
      if (!expression) {
        return false;
      }
      var type = expression.type;
      if (type === "Disjunction") {
        var left = expression.left, right = expression.right;
        return shouldProcess(left, charset) && shouldProcess(right, charset);
      } else if (type === "Char") {
        var value = expression.value;
        charset.set(value, expression);
        return true;
      } else if (type === "CharacterClass" && !expression.negative) {
        return expression.expressions.every(function(expression2) {
          return shouldProcess(expression2, charset);
        });
      }
      return false;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js
var require_remove_empty_group_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js"(exports2, module) {
    "use strict";
    module.exports = {
      Group: function Group(path) {
        var node = path.node, parent = path.parent;
        var childPath = path.getChild();
        if (node.capturing || childPath) {
          return;
        }
        if (parent.type === "Repetition") {
          path.getParent().replace(node);
        } else if (parent.type !== "RegExp") {
          path.remove();
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js
var require_ungroup_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js"(exports2, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module.exports = {
      Group: function Group(path) {
        var node = path.node, parent = path.parent;
        var childPath = path.getChild();
        if (node.capturing || !childPath) {
          return;
        }
        if (!hasAppropriateSiblings(path)) {
          return;
        }
        if (childPath.node.type === "Disjunction" && parent.type !== "RegExp") {
          return;
        }
        if (parent.type === "Repetition" && childPath.node.type !== "Char" && childPath.node.type !== "CharacterClass") {
          return;
        }
        if (childPath.node.type === "Alternative") {
          var parentPath = path.getParent();
          if (parentPath.node.type === "Alternative") {
            parentPath.replace({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(parent.expressions.slice(0, path.index)), _toConsumableArray(childPath.node.expressions), _toConsumableArray(parent.expressions.slice(path.index + 1)))
            });
          }
        } else {
          path.replace(childPath.node);
        }
      }
    };
    function hasAppropriateSiblings(path) {
      var parent = path.parent, index = path.index;
      if (parent.type !== "Alternative") {
        return true;
      }
      var previousNode = parent.expressions[index - 1];
      if (previousNode == null) {
        return true;
      }
      if (previousNode.type === "Backreference" && previousNode.kind === "number") {
        return false;
      }
      if (previousNode.type === "Char" && previousNode.kind === "decimal") {
        return false;
      }
      return true;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js
var require_combine_repeating_patterns_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js"(exports2, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var NodePath = require_node_path();
    var _require = require_utils();
    var increaseQuantifierByOne = _require.increaseQuantifierByOne;
    module.exports = {
      Alternative: function Alternative(path) {
        var node = path.node;
        var index = 1;
        while (index < node.expressions.length) {
          var child = path.getChild(index);
          index = Math.max(1, combineRepeatingPatternLeft(path, child, index));
          if (index >= node.expressions.length) {
            break;
          }
          child = path.getChild(index);
          index = Math.max(1, combineWithPreviousRepetition(path, child, index));
          if (index >= node.expressions.length) {
            break;
          }
          child = path.getChild(index);
          index = Math.max(1, combineRepetitionWithPrevious(path, child, index));
          index++;
        }
      }
    };
    function combineRepeatingPatternLeft(alternative, child, index) {
      var node = alternative.node;
      var nbPossibleLengths = Math.ceil(index / 2);
      var i = 0;
      while (i < nbPossibleLengths) {
        var startIndex = index - 2 * i - 1;
        var right = void 0, left = void 0;
        if (i === 0) {
          right = child;
          left = alternative.getChild(startIndex);
        } else {
          right = NodePath.getForNode({
            type: "Alternative",
            expressions: [].concat(_toConsumableArray(node.expressions.slice(index - i, index)), [child.node])
          });
          left = NodePath.getForNode({
            type: "Alternative",
            expressions: [].concat(_toConsumableArray(node.expressions.slice(startIndex, index - i)))
          });
        }
        if (right.hasEqualSource(left)) {
          for (var j = 0; j < 2 * i + 1; j++) {
            alternative.getChild(startIndex).remove();
          }
          child.replace({
            type: "Repetition",
            expression: i === 0 && right.node.type !== "Repetition" ? right.node : {
              type: "Group",
              capturing: false,
              expression: right.node
            },
            quantifier: {
              type: "Quantifier",
              kind: "Range",
              from: 2,
              to: 2,
              greedy: true
            }
          });
          return startIndex;
        }
        i++;
      }
      return index;
    }
    function combineWithPreviousRepetition(alternative, child, index) {
      var node = alternative.node;
      var i = 0;
      while (i < index) {
        var previousChild = alternative.getChild(i);
        if (previousChild.node.type === "Repetition" && previousChild.node.quantifier.greedy) {
          var left = previousChild.getChild();
          var right = void 0;
          if (left.node.type === "Group" && !left.node.capturing) {
            left = left.getChild();
          }
          if (i + 1 === index) {
            right = child;
            if (right.node.type === "Group" && !right.node.capturing) {
              right = right.getChild();
            }
          } else {
            right = NodePath.getForNode({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(node.expressions.slice(i + 1, index + 1)))
            });
          }
          if (left.hasEqualSource(right)) {
            for (var j = i; j < index; j++) {
              alternative.getChild(i + 1).remove();
            }
            increaseQuantifierByOne(previousChild.node.quantifier);
            return i;
          }
        }
        i++;
      }
      return index;
    }
    function combineRepetitionWithPrevious(alternative, child, index) {
      var node = alternative.node;
      if (child.node.type === "Repetition" && child.node.quantifier.greedy) {
        var right = child.getChild();
        var left = void 0;
        if (right.node.type === "Group" && !right.node.capturing) {
          right = right.getChild();
        }
        var rightLength = void 0;
        if (right.node.type === "Alternative") {
          rightLength = right.node.expressions.length;
          left = NodePath.getForNode({
            type: "Alternative",
            expressions: [].concat(_toConsumableArray(node.expressions.slice(index - rightLength, index)))
          });
        } else {
          rightLength = 1;
          left = alternative.getChild(index - 1);
          if (left.node.type === "Group" && !left.node.capturing) {
            left = left.getChild();
          }
        }
        if (left.hasEqualSource(right)) {
          for (var j = index - rightLength; j < index; j++) {
            alternative.getChild(index - rightLength).remove();
          }
          increaseQuantifierByOne(child.node.quantifier);
          return index - rightLength;
        }
      }
      return index;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/index.js
var require_transforms2 = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/index.js"(exports2, module) {
    "use strict";
    module.exports = /* @__PURE__ */ new Map([
      ["charSurrogatePairToSingleUnicode", require_char_surrogate_pair_to_single_unicode_transform()],
      ["charCodeToSimpleChar", require_char_code_to_simple_char_transform()],
      ["charCaseInsensitiveLowerCaseTransform", require_char_case_insensitive_lowercase_transform()],
      ["charClassRemoveDuplicates", require_char_class_remove_duplicates_transform()],
      ["quantifiersMerge", require_quantifiers_merge_transform()],
      ["quantifierRangeToSymbol", require_quantifier_range_to_symbol_transform()],
      ["charClassClassrangesToChars", require_char_class_classranges_to_chars_transform()],
      ["charClassToMeta", require_char_class_to_meta_transform()],
      ["charClassToSingleChar", require_char_class_to_single_char_transform()],
      ["charEscapeUnescape", require_char_escape_unescape_transform()],
      ["charClassClassrangesMerge", require_char_class_classranges_merge_transform()],
      ["disjunctionRemoveDuplicates", require_disjunction_remove_duplicates_transform()],
      ["groupSingleCharsToCharClass", require_group_single_chars_to_char_class()],
      ["removeEmptyGroup", require_remove_empty_group_transform()],
      ["ungroup", require_ungroup_transform()],
      ["combineRepeatingPatterns", require_combine_repeating_patterns_transform()]
    ]);
  }
});

// node_modules/regexp-tree/dist/optimizer/index.js
var require_optimizer = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/index.js"(exports2, module) {
    "use strict";
    var clone = require_clone();
    var parser2 = require_parser();
    var transform = require_transform();
    var optimizationTransforms = require_transforms2();
    module.exports = {
      optimize: function optimize(regexp) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$whitelist = _ref.whitelist, whitelist = _ref$whitelist === void 0 ? [] : _ref$whitelist, _ref$blacklist = _ref.blacklist, blacklist = _ref$blacklist === void 0 ? [] : _ref$blacklist;
        var transformsRaw = whitelist.length > 0 ? whitelist : Array.from(optimizationTransforms.keys());
        var transformToApply = transformsRaw.filter(function(transform2) {
          return !blacklist.includes(transform2);
        });
        var ast = regexp;
        if (regexp instanceof RegExp) {
          regexp = "" + regexp;
        }
        if (typeof regexp === "string") {
          ast = parser2.parse(regexp);
        }
        var result = new transform.TransformResult(ast);
        var prevResultString = void 0;
        do {
          prevResultString = result.toString();
          ast = clone(result.getAST());
          transformToApply.forEach(function(transformName) {
            if (!optimizationTransforms.has(transformName)) {
              throw new Error("Unknown optimization-transform: " + transformName + ". Available transforms are: " + Array.from(optimizationTransforms.keys()).join(", "));
            }
            var transformer = optimizationTransforms.get(transformName);
            var newResult = transform.transform(ast, transformer);
            if (newResult.toString() !== result.toString()) {
              if (newResult.toString().length <= result.toString().length) {
                result = newResult;
              } else {
                ast = clone(result.getAST());
              }
            }
          });
        } while (result.toString() !== prevResultString);
        return result;
      }
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js
var require_special_symbols = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js"(exports2, module) {
    "use strict";
    var EPSILON = "\u03B5";
    var EPSILON_CLOSURE = EPSILON + "*";
    module.exports = {
      EPSILON,
      EPSILON_CLOSURE
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js
var require_nfa = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js"(exports2, module) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_special_symbols();
    var EPSILON = _require.EPSILON;
    var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;
    var NFA = function() {
      function NFA2(inState, outState) {
        _classCallCheck(this, NFA2);
        this.in = inState;
        this.out = outState;
      }
      _createClass(NFA2, [{
        key: "matches",
        value: function matches(string) {
          return this.in.matches(string);
        }
      }, {
        key: "getAlphabet",
        value: function getAlphabet() {
          if (!this._alphabet) {
            this._alphabet = /* @__PURE__ */ new Set();
            var table = this.getTransitionTable();
            for (var state in table) {
              var transitions = table[state];
              for (var symbol in transitions) {
                if (symbol !== EPSILON_CLOSURE) {
                  this._alphabet.add(symbol);
                }
              }
            }
          }
          return this._alphabet;
        }
      }, {
        key: "getAcceptingStates",
        value: function getAcceptingStates() {
          if (!this._acceptingStates) {
            this.getTransitionTable();
          }
          return this._acceptingStates;
        }
      }, {
        key: "getAcceptingStateNumbers",
        value: function getAcceptingStateNumbers() {
          if (!this._acceptingStateNumbers) {
            this._acceptingStateNumbers = /* @__PURE__ */ new Set();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var acceptingState = _step.value;
                this._acceptingStateNumbers.add(acceptingState.number);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          return this._acceptingStateNumbers;
        }
      }, {
        key: "getTransitionTable",
        value: function getTransitionTable() {
          var _this = this;
          if (!this._transitionTable) {
            this._transitionTable = {};
            this._acceptingStates = /* @__PURE__ */ new Set();
            var visited = /* @__PURE__ */ new Set();
            var symbols = /* @__PURE__ */ new Set();
            var visitState = function visitState2(state) {
              if (visited.has(state)) {
                return;
              }
              visited.add(state);
              state.number = visited.size;
              _this._transitionTable[state.number] = {};
              if (state.accepting) {
                _this._acceptingStates.add(state);
              }
              var transitions = state.getTransitions();
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = transitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var _ref = _step2.value;
                  var _ref2 = _slicedToArray(_ref, 2);
                  var symbol = _ref2[0];
                  var symbolTransitions = _ref2[1];
                  var combinedState = [];
                  symbols.add(symbol);
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = void 0;
                  try {
                    for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var nextState = _step3.value;
                      visitState2(nextState);
                      combinedState.push(nextState.number);
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                  _this._transitionTable[state.number][symbol] = combinedState;
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            };
            visitState(this.in);
            visited.forEach(function(state) {
              delete _this._transitionTable[state.number][EPSILON];
              _this._transitionTable[state.number][EPSILON_CLOSURE] = [].concat(_toConsumableArray(state.getEpsilonClosure())).map(function(s) {
                return s.number;
              });
            });
          }
          return this._transitionTable;
        }
      }]);
      return NFA2;
    }();
    module.exports = NFA;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js
var require_dfa_minimizer = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js"(exports2, module) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    function _toArray(arr) {
      return Array.isArray(arr) ? arr : Array.from(arr);
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var currentTransitionMap = null;
    function minimize(dfa) {
      var table = dfa.getTransitionTable();
      var allStates = Object.keys(table);
      var alphabet = dfa.getAlphabet();
      var accepting = dfa.getAcceptingStateNumbers();
      currentTransitionMap = {};
      var nonAccepting = /* @__PURE__ */ new Set();
      allStates.forEach(function(state) {
        state = Number(state);
        var isAccepting = accepting.has(state);
        if (isAccepting) {
          currentTransitionMap[state] = accepting;
        } else {
          nonAccepting.add(state);
          currentTransitionMap[state] = nonAccepting;
        }
      });
      var all = [
        [nonAccepting, accepting].filter(function(set2) {
          return set2.size > 0;
        })
      ];
      var current = void 0;
      var previous = void 0;
      current = all[all.length - 1];
      previous = all[all.length - 2];
      var _loop = function _loop2() {
        var newTransitionMap = {};
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = current[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _set = _step3.value;
            var handledStates = {};
            var _set2 = _toArray(_set), first = _set2[0], rest = _set2.slice(1);
            handledStates[first] = /* @__PURE__ */ new Set([first]);
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = void 0;
            try {
              restSets:
                for (var _iterator4 = rest[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var state = _step4.value;
                  var _iteratorNormalCompletion5 = true;
                  var _didIteratorError5 = false;
                  var _iteratorError5 = void 0;
                  try {
                    for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                      var handledState = _step5.value;
                      if (areEquivalent(state, handledState, table, alphabet)) {
                        handledStates[handledState].add(state);
                        handledStates[state] = handledStates[handledState];
                        continue restSets;
                      }
                    }
                  } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                      }
                    } finally {
                      if (_didIteratorError5) {
                        throw _iteratorError5;
                      }
                    }
                  }
                  handledStates[state] = /* @__PURE__ */ new Set([state]);
                }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
            Object.assign(newTransitionMap, handledStates);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        currentTransitionMap = newTransitionMap;
        var newSets = new Set(Object.keys(newTransitionMap).map(function(state2) {
          return newTransitionMap[state2];
        }));
        all.push([].concat(_toConsumableArray(newSets)));
        current = all[all.length - 1];
        previous = all[all.length - 2];
      };
      while (!sameRow(current, previous)) {
        _loop();
      }
      var remaped = /* @__PURE__ */ new Map();
      var idx = 1;
      current.forEach(function(set2) {
        return remaped.set(set2, idx++);
      });
      var minimizedTable = {};
      var minimizedAcceptingStates = /* @__PURE__ */ new Set();
      var updateAcceptingStates = function updateAcceptingStates2(set2, idx2) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = set2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var state = _step.value;
            if (accepting.has(state)) {
              minimizedAcceptingStates.add(idx2);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref = _step2.value;
          var _ref2 = _slicedToArray(_ref, 2);
          var set = _ref2[0];
          var _idx = _ref2[1];
          minimizedTable[_idx] = {};
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = void 0;
          try {
            for (var _iterator6 = alphabet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var symbol = _step6.value;
              updateAcceptingStates(set, _idx);
              var originalTransition = void 0;
              var _iteratorNormalCompletion7 = true;
              var _didIteratorError7 = false;
              var _iteratorError7 = void 0;
              try {
                for (var _iterator7 = set[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  var originalState = _step7.value;
                  originalTransition = table[originalState][symbol];
                  if (originalTransition) {
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                  }
                } finally {
                  if (_didIteratorError7) {
                    throw _iteratorError7;
                  }
                }
              }
              if (originalTransition) {
                minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      dfa.setTransitionTable(minimizedTable);
      dfa.setAcceptingStateNumbers(minimizedAcceptingStates);
      return dfa;
    }
    function sameRow(r1, r2) {
      if (!r2) {
        return false;
      }
      if (r1.length !== r2.length) {
        return false;
      }
      for (var i = 0; i < r1.length; i++) {
        var s1 = r1[i];
        var s2 = r2[i];
        if (s1.size !== s2.size) {
          return false;
        }
        if ([].concat(_toConsumableArray(s1)).sort().join(",") !== [].concat(_toConsumableArray(s2)).sort().join(",")) {
          return false;
        }
      }
      return true;
    }
    function areEquivalent(s1, s2, table, alphabet) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = void 0;
      try {
        for (var _iterator8 = alphabet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var symbol = _step8.value;
          if (!goToSameSet(s1, s2, table, symbol)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return true;
    }
    function goToSameSet(s1, s2, table, symbol) {
      if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {
        return false;
      }
      var originalTransitionS1 = table[s1][symbol];
      var originalTransitionS2 = table[s2][symbol];
      if (!originalTransitionS1 && !originalTransitionS2) {
        return true;
      }
      return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);
    }
    module.exports = {
      minimize
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js
var require_dfa = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js"(exports2, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var DFAMinimizer = require_dfa_minimizer();
    var _require = require_special_symbols();
    var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;
    var DFA = function() {
      function DFA2(nfa) {
        _classCallCheck(this, DFA2);
        this._nfa = nfa;
      }
      _createClass(DFA2, [{
        key: "minimize",
        value: function minimize() {
          this.getTransitionTable();
          this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
          this._originalTransitionTable = this._transitionTable;
          DFAMinimizer.minimize(this);
        }
      }, {
        key: "getAlphabet",
        value: function getAlphabet() {
          return this._nfa.getAlphabet();
        }
      }, {
        key: "getAcceptingStateNumbers",
        value: function getAcceptingStateNumbers() {
          if (!this._acceptingStateNumbers) {
            this.getTransitionTable();
          }
          return this._acceptingStateNumbers;
        }
      }, {
        key: "getOriginaAcceptingStateNumbers",
        value: function getOriginaAcceptingStateNumbers() {
          if (!this._originalAcceptingStateNumbers) {
            this.getTransitionTable();
          }
          return this._originalAcceptingStateNumbers;
        }
      }, {
        key: "setTransitionTable",
        value: function setTransitionTable(table) {
          this._transitionTable = table;
        }
      }, {
        key: "setAcceptingStateNumbers",
        value: function setAcceptingStateNumbers(stateNumbers) {
          this._acceptingStateNumbers = stateNumbers;
        }
      }, {
        key: "getTransitionTable",
        value: function getTransitionTable() {
          var _this = this;
          if (this._transitionTable) {
            return this._transitionTable;
          }
          var nfaTable = this._nfa.getTransitionTable();
          var nfaStates = Object.keys(nfaTable);
          this._acceptingStateNumbers = /* @__PURE__ */ new Set();
          var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];
          var worklist = [startState];
          var alphabet = this.getAlphabet();
          var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();
          var dfaTable = {};
          var updateAcceptingStates = function updateAcceptingStates2(states2) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var nfaAcceptingState = _step.value;
                if (states2.indexOf(nfaAcceptingState) !== -1) {
                  _this._acceptingStateNumbers.add(states2.join(","));
                  break;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          };
          while (worklist.length > 0) {
            var states = worklist.shift();
            var dfaStateLabel = states.join(",");
            dfaTable[dfaStateLabel] = {};
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = alphabet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var symbol = _step2.value;
                var onSymbol = [];
                updateAcceptingStates(states);
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = void 0;
                try {
                  for (var _iterator3 = states[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var state = _step3.value;
                    var nfaStatesOnSymbol = nfaTable[state][symbol];
                    if (!nfaStatesOnSymbol) {
                      continue;
                    }
                    var _iteratorNormalCompletion4 = true;
                    var _didIteratorError4 = false;
                    var _iteratorError4 = void 0;
                    try {
                      for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var nfaStateOnSymbol = _step4.value;
                        if (!nfaTable[nfaStateOnSymbol]) {
                          continue;
                        }
                        onSymbol.push.apply(onSymbol, _toConsumableArray(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));
                      }
                    } catch (err) {
                      _didIteratorError4 = true;
                      _iteratorError4 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                          _iterator4.return();
                        }
                      } finally {
                        if (_didIteratorError4) {
                          throw _iteratorError4;
                        }
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError3 = true;
                  _iteratorError3 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                      _iterator3.return();
                    }
                  } finally {
                    if (_didIteratorError3) {
                      throw _iteratorError3;
                    }
                  }
                }
                var dfaStatesOnSymbolSet = new Set(onSymbol);
                var dfaStatesOnSymbol = [].concat(_toConsumableArray(dfaStatesOnSymbolSet));
                if (dfaStatesOnSymbol.length > 0) {
                  var dfaOnSymbolStr = dfaStatesOnSymbol.join(",");
                  dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;
                  if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {
                    worklist.unshift(dfaStatesOnSymbol);
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
          return this._transitionTable = this._remapStateNumbers(dfaTable);
        }
      }, {
        key: "_remapStateNumbers",
        value: function _remapStateNumbers(calculatedDFATable) {
          var newStatesMap = {};
          this._originalTransitionTable = calculatedDFATable;
          var transitionTable = {};
          Object.keys(calculatedDFATable).forEach(function(originalNumber2, newNumber) {
            newStatesMap[originalNumber2] = newNumber + 1;
          });
          for (var originalNumber in calculatedDFATable) {
            var originalRow = calculatedDFATable[originalNumber];
            var row = {};
            for (var symbol in originalRow) {
              row[symbol] = newStatesMap[originalRow[symbol]];
            }
            transitionTable[newStatesMap[originalNumber]] = row;
          }
          this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
          this._acceptingStateNumbers = /* @__PURE__ */ new Set();
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = void 0;
          try {
            for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _originalNumber = _step5.value;
              this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
          return transitionTable;
        }
      }, {
        key: "getOriginalTransitionTable",
        value: function getOriginalTransitionTable() {
          if (!this._originalTransitionTable) {
            this.getTransitionTable();
          }
          return this._originalTransitionTable;
        }
      }, {
        key: "matches",
        value: function matches(string) {
          var state = 1;
          var i = 0;
          var table = this.getTransitionTable();
          while (string[i]) {
            state = table[state][string[i++]];
            if (!state) {
              return false;
            }
          }
          if (!this.getAcceptingStateNumbers().has(state)) {
            return false;
          }
          return true;
        }
      }]);
      return DFA2;
    }();
    module.exports = DFA;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js
var require_state = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js"(exports2, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var State = function() {
      function State2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$accepting = _ref.accepting, accepting = _ref$accepting === void 0 ? false : _ref$accepting;
        _classCallCheck(this, State2);
        this._transitions = /* @__PURE__ */ new Map();
        this.accepting = accepting;
      }
      _createClass(State2, [{
        key: "getTransitions",
        value: function getTransitions() {
          return this._transitions;
        }
      }, {
        key: "addTransition",
        value: function addTransition(symbol, toState) {
          this.getTransitionsOnSymbol(symbol).add(toState);
          return this;
        }
      }, {
        key: "getTransitionsOnSymbol",
        value: function getTransitionsOnSymbol(symbol) {
          var transitions = this._transitions.get(symbol);
          if (!transitions) {
            transitions = /* @__PURE__ */ new Set();
            this._transitions.set(symbol, transitions);
          }
          return transitions;
        }
      }]);
      return State2;
    }();
    module.exports = State;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js
var require_nfa_state = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js"(exports2, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var State = require_state();
    var _require = require_special_symbols();
    var EPSILON = _require.EPSILON;
    var NFAState = function(_State) {
      _inherits(NFAState2, _State);
      function NFAState2() {
        _classCallCheck(this, NFAState2);
        return _possibleConstructorReturn(this, (NFAState2.__proto__ || Object.getPrototypeOf(NFAState2)).apply(this, arguments));
      }
      _createClass(NFAState2, [{
        key: "matches",
        value: function matches(string) {
          var visited = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
          if (visited.has(this)) {
            return false;
          }
          visited.add(this);
          if (string.length === 0) {
            if (this.accepting) {
              return true;
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var nextState = _step.value;
                if (nextState.matches("", visited)) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return false;
          }
          var symbol = string[0];
          var rest = string.slice(1);
          var symbolTransitions = this.getTransitionsOnSymbol(symbol);
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _nextState = _step2.value;
              if (_nextState.matches(rest)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _nextState2 = _step3.value;
              if (_nextState2.matches(string, visited)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          return false;
        }
      }, {
        key: "getEpsilonClosure",
        value: function getEpsilonClosure() {
          var _this2 = this;
          if (!this._epsilonClosure) {
            (function() {
              var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON);
              var closure = _this2._epsilonClosure = /* @__PURE__ */ new Set();
              closure.add(_this2);
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = void 0;
              try {
                for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var nextState = _step4.value;
                  if (!closure.has(nextState)) {
                    closure.add(nextState);
                    var nextClosure = nextState.getEpsilonClosure();
                    nextClosure.forEach(function(state) {
                      return closure.add(state);
                    });
                  }
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            })();
          }
          return this._epsilonClosure;
        }
      }]);
      return NFAState2;
    }(State);
    module.exports = NFAState;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js
var require_builders = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js"(exports2, module) {
    "use strict";
    var NFA = require_nfa();
    var NFAState = require_nfa_state();
    var _require = require_special_symbols();
    var EPSILON = _require.EPSILON;
    function char(c) {
      var inState = new NFAState();
      var outState = new NFAState({
        accepting: true
      });
      return new NFA(inState.addTransition(c, outState), outState);
    }
    function e() {
      return char(EPSILON);
    }
    function altPair(first, second) {
      first.out.accepting = false;
      second.out.accepting = true;
      first.out.addTransition(EPSILON, second.in);
      return new NFA(first.in, second.out);
    }
    function alt(first) {
      for (var _len = arguments.length, fragments = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        fragments[_key - 1] = arguments[_key];
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fragment = _step.value;
          first = altPair(first, fragment);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return first;
    }
    function orPair(first, second) {
      var inState = new NFAState();
      var outState = new NFAState();
      inState.addTransition(EPSILON, first.in);
      inState.addTransition(EPSILON, second.in);
      outState.accepting = true;
      first.out.accepting = false;
      second.out.accepting = false;
      first.out.addTransition(EPSILON, outState);
      second.out.addTransition(EPSILON, outState);
      return new NFA(inState, outState);
    }
    function or(first) {
      for (var _len2 = arguments.length, fragments = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        fragments[_key2 - 1] = arguments[_key2];
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = fragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var fragment = _step2.value;
          first = orPair(first, fragment);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      return first;
    }
    function repExplicit(fragment) {
      var inState = new NFAState();
      var outState = new NFAState({
        accepting: true
      });
      inState.addTransition(EPSILON, fragment.in);
      inState.addTransition(EPSILON, outState);
      fragment.out.accepting = false;
      fragment.out.addTransition(EPSILON, outState);
      outState.addTransition(EPSILON, fragment.in);
      return new NFA(inState, outState);
    }
    function rep(fragment) {
      fragment.in.addTransition(EPSILON, fragment.out);
      fragment.out.addTransition(EPSILON, fragment.in);
      return fragment;
    }
    function plusRep(fragment) {
      fragment.out.addTransition(EPSILON, fragment.in);
      return fragment;
    }
    function questionRep(fragment) {
      fragment.in.addTransition(EPSILON, fragment.out);
      return fragment;
    }
    module.exports = {
      alt,
      char,
      e,
      or,
      rep,
      repExplicit,
      plusRep,
      questionRep
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js
var require_nfa_from_regexp = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js"(exports2, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var parser2 = require_parser();
    var _require = require_builders();
    var alt = _require.alt;
    var char = _require.char;
    var or = _require.or;
    var rep = _require.rep;
    var plusRep = _require.plusRep;
    var questionRep = _require.questionRep;
    function gen(node) {
      if (node && !generator[node.type]) {
        throw new Error(node.type + " is not supported in NFA/DFA interpreter.");
      }
      return node ? generator[node.type](node) : "";
    }
    var generator = {
      RegExp: function RegExp2(node) {
        if (node.flags !== "") {
          throw new Error("NFA/DFA: Flags are not supported yet.");
        }
        return gen(node.body);
      },
      Alternative: function Alternative(node) {
        var fragments = (node.expressions || []).map(gen);
        return alt.apply(void 0, _toConsumableArray(fragments));
      },
      Disjunction: function Disjunction(node) {
        return or(gen(node.left), gen(node.right));
      },
      Repetition: function Repetition(node) {
        switch (node.quantifier.kind) {
          case "*":
            return rep(gen(node.expression));
          case "+":
            return plusRep(gen(node.expression));
          case "?":
            return questionRep(gen(node.expression));
          default:
            throw new Error("Unknown repeatition: " + node.quantifier.kind + ".");
        }
      },
      Char: function Char(node) {
        if (node.kind !== "simple") {
          throw new Error("NFA/DFA: Only simple chars are supported yet.");
        }
        return char(node.value);
      },
      Group: function Group(node) {
        return gen(node.expression);
      }
    };
    module.exports = {
      build: function build(regexp) {
        var ast = regexp;
        if (regexp instanceof RegExp) {
          regexp = "" + regexp;
        }
        if (typeof regexp === "string") {
          ast = parser2.parse(regexp, {
            captureLocations: true
          });
        }
        return gen(ast);
      }
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js
var require_finite_automaton = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js"(exports2, module) {
    "use strict";
    var NFA = require_nfa();
    var DFA = require_dfa();
    var nfaFromRegExp = require_nfa_from_regexp();
    var builders = require_builders();
    module.exports = {
      NFA,
      DFA,
      builders,
      toNFA: function toNFA(regexp) {
        return nfaFromRegExp.build(regexp);
      },
      toDFA: function toDFA(regexp) {
        return new DFA(this.toNFA(regexp));
      },
      test: function test(regexp, string) {
        return this.toDFA(regexp).matches(string);
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js
var require_runtime = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js"(exports2, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var RegExpTree = function() {
      function RegExpTree2(re, _ref) {
        var flags = _ref.flags, groups = _ref.groups, source = _ref.source;
        _classCallCheck(this, RegExpTree2);
        this._re = re;
        this._groups = groups;
        this.flags = flags;
        this.source = source || re.source;
        this.dotAll = flags.includes("s");
        this.global = re.global;
        this.ignoreCase = re.ignoreCase;
        this.multiline = re.multiline;
        this.sticky = re.sticky;
        this.unicode = re.unicode;
      }
      _createClass(RegExpTree2, [{
        key: "test",
        value: function test(string) {
          return this._re.test(string);
        }
      }, {
        key: "compile",
        value: function compile(string) {
          return this._re.compile(string);
        }
      }, {
        key: "toString",
        value: function toString() {
          if (!this._toStringResult) {
            this._toStringResult = "/" + this.source + "/" + this.flags;
          }
          return this._toStringResult;
        }
      }, {
        key: "exec",
        value: function exec(string) {
          var result = this._re.exec(string);
          if (!this._groups || !result) {
            return result;
          }
          result.groups = {};
          for (var group in this._groups) {
            var groupNumber = this._groups[group];
            result.groups[group] = result[groupNumber];
          }
          return result;
        }
      }]);
      return RegExpTree2;
    }();
    module.exports = {
      RegExpTree
    };
  }
});

// node_modules/regexp-tree/dist/regexp-tree.js
var require_regexp_tree2 = __commonJS({
  "node_modules/regexp-tree/dist/regexp-tree.js"(exports2, module) {
    "use strict";
    var compatTranspiler = require_compat_transpiler();
    var generator = require_generator();
    var optimizer = require_optimizer();
    var parser2 = require_parser();
    var _transform = require_transform();
    var _traverse = require_traverse();
    var fa = require_finite_automaton();
    var _require = require_runtime();
    var RegExpTree = _require.RegExpTree;
    var regexpTree = {
      parser: parser2,
      fa,
      TransformResult: _transform.TransformResult,
      parse: function parse(regexp, options2) {
        return parser2.parse("" + regexp, options2);
      },
      traverse: function traverse(ast, handlers, options2) {
        return _traverse.traverse(ast, handlers, options2);
      },
      transform: function transform(regexp, handlers) {
        return _transform.transform(regexp, handlers);
      },
      generate: function generate(ast) {
        return generator.generate(ast);
      },
      toRegExp: function toRegExp(regexp) {
        var compat = this.compatTranspile(regexp);
        return new RegExp(compat.getSource(), compat.getFlags());
      },
      optimize: function optimize(regexp, whitelist) {
        var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, blacklist = _ref.blacklist;
        return optimizer.optimize(regexp, { whitelist, blacklist });
      },
      compatTranspile: function compatTranspile(regexp, whitelist) {
        return compatTranspiler.transform(regexp, whitelist);
      },
      exec: function exec(re, string) {
        if (typeof re === "string") {
          var compat = this.compatTranspile(re);
          var extra = compat.getExtra();
          if (extra.namedCapturingGroups) {
            re = new RegExpTree(compat.toRegExp(), {
              flags: compat.getFlags(),
              source: compat.getSource(),
              groups: extra.namedCapturingGroups
            });
          } else {
            re = compat.toRegExp();
          }
        }
        return re.exec(string);
      }
    };
    module.exports = regexpTree;
  }
});

// node_modules/regexp-tree/index.js
var require_regexp_tree3 = __commonJS({
  "node_modules/regexp-tree/index.js"(exports2, module) {
    "use strict";
    module.exports = require_regexp_tree2();
  }
});

// node_modules/regex-to-strings/lib/Expansion.js
var require_Expansion = __commonJS({
  "node_modules/regex-to-strings/lib/Expansion.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    exports2.__esModule = true;
    function toIterable(getIterator) {
      return function beginIterating() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [5, __values(getIterator instanceof Function ? getIterator() : getIterator)];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      };
    }
    var Expansion = function() {
      function Expansion2(getIterator, count) {
        this.getIterator = toIterable(getIterator);
        this.count = count;
      }
      Expansion2.Blank = new Expansion2([""], 1);
      Expansion2.Empty = new Expansion2([], 0);
      return Expansion2;
    }();
    exports2["default"] = Expansion;
  }
});

// node_modules/regex-to-strings/lib/sorts/number-random.js
var require_number_random = __commonJS({
  "node_modules/regex-to-strings/lib/sorts/number-random.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    function chooseRandomInRange(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    exports2["default"] = chooseRandomInRange;
  }
});

// node_modules/pandemonium/weighted-random-index.js
var require_weighted_random_index = __commonJS({
  "node_modules/pandemonium/weighted-random-index.js"(exports2, module) {
    var DEFAULTS = {
      rng: Math.random,
      getWeight: null
    };
    function upperBound(array, value) {
      var l = array.length, d, c, i = 0;
      while (l) {
        d = l >>> 1;
        c = i + d;
        if (value < array[c]) {
          l = d;
        } else {
          i = c + 1;
          l -= d + 1;
        }
      }
      return i;
    }
    function createCachedWeightedRandomIndex(rngOrOptions, sequence) {
      var rng, options2;
      if (typeof rngOrOptions === "function") {
        rng = rngOrOptions;
        options2 = {};
      } else {
        rng = rngOrOptions.rng || DEFAULTS.rng;
        options2 = rngOrOptions;
      }
      var getWeight = typeof options2.getWeight === "function" ? options2.getWeight : null;
      var l = sequence.length;
      var CDF = new Float64Array(l);
      var total = 0;
      var weight;
      for (var i = 0; i < l; i++) {
        weight = getWeight ? getWeight(sequence[i], i) : sequence[i];
        total += weight;
        CDF[i] = total;
      }
      return function() {
        var random = rng() * total;
        return upperBound(CDF, random);
      };
    }
    function createWeightedRandomIndex(rngOrOptions) {
      var rng, options2;
      if (typeof rngOrOptions === "function") {
        rng = rngOrOptions;
        options2 = {};
      } else {
        rng = rngOrOptions.rng || DEFAULTS.rng;
        options2 = rngOrOptions;
      }
      var getWeight = typeof options2.getWeight === "function" ? options2.getWeight : null;
      return function(sequence) {
        var total = 0;
        var winner = 0;
        var weight;
        for (var i = 0, l = sequence.length; i < l; i++) {
          weight = getWeight ? getWeight(sequence[i], i) : sequence[i];
          total += weight;
          if (rng() * total < weight)
            winner = i;
        }
        return winner;
      };
    }
    var weightedRandomIndex = createWeightedRandomIndex(Math.random);
    weightedRandomIndex.createCachedWeightedRandomIndex = createCachedWeightedRandomIndex;
    weightedRandomIndex.createWeightedRandomIndex = createWeightedRandomIndex;
    module.exports = weightedRandomIndex;
  }
});

// node_modules/regex-to-strings/lib/sorts/weighted-random.js
var require_weighted_random = __commonJS({
  "node_modules/regex-to-strings/lib/sorts/weighted-random.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var weighted_random_index_1 = __importDefault(require_weighted_random_index());
    function chooseRandomWeight(weights) {
      return weighted_random_index_1["default"](weights);
    }
    exports2["default"] = chooseRandomWeight;
  }
});

// node_modules/regex-to-strings/lib/helpers/iterate-sorted.js
var require_iterate_sorted = __commonJS({
  "node_modules/regex-to-strings/lib/helpers/iterate-sorted.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.iteratePermutations = exports2.iterateWeightedByCount = void 0;
    var number_random_1 = __importDefault(require_number_random());
    var weighted_random_1 = __importDefault(require_weighted_random());
    function iterateWeightedByCount(options2) {
      var iterators, weights, iRandom, _a2, done, value;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            iterators = options2.map(function(option) {
              return option.getIterator();
            });
            weights = options2.map(function(option) {
              return option.count;
            });
            _b.label = 1;
          case 1:
            if (!(iterators.length > 0))
              return [3, 5];
            iRandom = weighted_random_1["default"](weights);
            _a2 = iterators[iRandom].next(), done = _a2.done, value = _a2.value;
            if (!done)
              return [3, 2];
            iterators.splice(iRandom, 1);
            weights.splice(iRandom, 1);
            return [3, 4];
          case 2:
            return [4, value];
          case 3:
            _b.sent();
            weights[iRandom]--;
            _b.label = 4;
          case 4:
            return [3, 1];
          case 5:
            return [2];
        }
      });
    }
    exports2.iterateWeightedByCount = iterateWeightedByCount;
    function iteratePermutations(expansions) {
      function iterateChildPermutations() {
        var _a3, done2, thisValue, childIterator, childIterator_1, childIterator_1_1, childValue, e_1_1;
        var e_1, _b2;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _a3 = thisIterator.next(), done2 = _a3.done, thisValue = _a3.value;
              if (done2) {
                return [2];
              }
              childIterator = iteratePermutations(childExpansions);
              _c.label = 1;
            case 1:
              _c.trys.push([1, 6, 7, 8]);
              childIterator_1 = __values(childIterator), childIterator_1_1 = childIterator_1.next();
              _c.label = 2;
            case 2:
              if (!!childIterator_1_1.done)
                return [3, 5];
              childValue = childIterator_1_1.value;
              return [4, "" + thisValue + childValue];
            case 3:
              _c.sent();
              _c.label = 4;
            case 4:
              childIterator_1_1 = childIterator_1.next();
              return [3, 2];
            case 5:
              return [3, 8];
            case 6:
              e_1_1 = _c.sent();
              e_1 = { error: e_1_1 };
              return [3, 8];
            case 7:
              try {
                if (childIterator_1_1 && !childIterator_1_1.done && (_b2 = childIterator_1["return"]))
                  _b2.call(childIterator_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
              return [7];
            case 8:
              numCompletedValuesThisIterator++;
              return [2];
          }
        });
      }
      var _a2, thisExpansion, childExpansions, thisIterator, numCompletedValuesThisIterator, inProgressIterators, iRandom, _b, done, value;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _a2 = __read(expansions), thisExpansion = _a2[0], childExpansions = _a2.slice(1);
            thisIterator = thisExpansion.getIterator();
            numCompletedValuesThisIterator = 0;
            if (!(expansions.length <= 1))
              return [3, 2];
            return [5, __values(thisIterator)];
          case 1:
            return [2, _c.sent()];
          case 2:
            inProgressIterators = [];
            _c.label = 3;
          case 3:
            if (!(numCompletedValuesThisIterator < thisExpansion.count))
              return [3, 7];
            iRandom = number_random_1["default"](0, thisExpansion.count - 1);
            if (iRandom > inProgressIterators.length - 1) {
              inProgressIterators.push(iterateChildPermutations());
              iRandom = inProgressIterators.length - 1;
            }
            _b = inProgressIterators[iRandom].next(), done = _b.done, value = _b.value;
            if (!done)
              return [3, 4];
            inProgressIterators.splice(iRandom, 1);
            return [3, 6];
          case 4:
            return [4, value];
          case 5:
            _c.sent();
            _c.label = 6;
          case 6:
            return [3, 3];
          case 7:
            return [2];
        }
      });
    }
    exports2.iteratePermutations = iteratePermutations;
  }
});

// node_modules/regex-to-strings/lib/expanders/alternative-pattern.js
var require_alternative_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/expanders/alternative-pattern.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.expandAlternative = void 0;
    var Expansion_1 = __importDefault(require_Expansion());
    var iterate_sorted_1 = require_iterate_sorted();
    function traverseTree(tree) {
      if (!tree.length) {
        return Expansion_1["default"].Empty;
      }
      var firstBranch = this.expandExpression(tree[0]);
      var restOfTree = traverseTree.call(this, tree.slice(1));
      if (restOfTree.count <= 0) {
        return firstBranch;
      }
      var iterator = function() {
        return iterate_sorted_1.iteratePermutations([firstBranch, restOfTree]);
      };
      var numPermutations = firstBranch.count * restOfTree.count;
      return new Expansion_1["default"](iterator, numPermutations);
    }
    function expandAlternative(node) {
      return traverseTree.call(this, node.expressions);
    }
    exports2.expandAlternative = expandAlternative;
  }
});

// node_modules/pandemonium/random.js
var require_random = __commonJS({
  "node_modules/pandemonium/random.js"(exports2, module) {
    function createRandom(rng) {
      return function(a, b) {
        return a + Math.floor(rng() * (b - a + 1));
      };
    }
    var random = createRandom(Math.random);
    random.createRandom = createRandom;
    module.exports = random;
  }
});

// node_modules/pandemonium/shuffle-in-place.js
var require_shuffle_in_place = __commonJS({
  "node_modules/pandemonium/shuffle-in-place.js"(exports2, module) {
    var createRandom = require_random().createRandom;
    function createShuffleInPlace(rng) {
      var customRandom = createRandom(rng);
      return function(sequence) {
        var length = sequence.length, lastIndex = length - 1;
        var index = -1;
        while (++index < length) {
          var r = customRandom(index, lastIndex), value = sequence[r];
          sequence[r] = sequence[index];
          sequence[index] = value;
        }
      };
    }
    var shuffleInPlace = createShuffleInPlace(Math.random);
    shuffleInPlace.createShuffleInPlace = createShuffleInPlace;
    module.exports = shuffleInPlace;
  }
});

// node_modules/pandemonium/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/pandemonium/shuffle.js"(exports2, module) {
    var createShuffleInPlace = require_shuffle_in_place().createShuffleInPlace;
    function createShuffle(rng) {
      var customShuffleInPlace = createShuffleInPlace(rng);
      return function(sequence) {
        var copy = sequence.slice();
        customShuffleInPlace(copy);
        return copy;
      };
    }
    var shuffle = createShuffle(Math.random);
    shuffle.createShuffle = createShuffle;
    module.exports = shuffle;
  }
});

// node_modules/regex-to-strings/lib/sorts/fisher-yates-random.js
var require_fisher_yates_random = __commonJS({
  "node_modules/regex-to-strings/lib/sorts/fisher-yates-random.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var shuffle_1 = __importDefault(require_shuffle());
    function sort(items) {
      return shuffle_1["default"](items);
    }
    exports2["default"] = sort;
  }
});

// node_modules/regex-to-strings/lib/types/regexp-tree-guards.js
var require_regexp_tree_guards = __commonJS({
  "node_modules/regex-to-strings/lib/types/regexp-tree-guards.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.isSimpleQuantifier = exports2.isSimpleChar = exports2.isRepetition = exports2.isRangeQuantifier = exports2.isMetaChar = exports2.isNumericBackreference = exports2.isNamedBackreference = exports2.isGroup = exports2.isDisjunction = exports2.isClassRange = exports2.isCharacterClass = exports2.isChar = exports2.isCapturingGroup = exports2.isBackreference = exports2.isAssertion = exports2.isAlternative = void 0;
    function isAlternative(node) {
      return node.type === "Alternative";
    }
    exports2.isAlternative = isAlternative;
    function isAssertion(node) {
      return node.type === "Assertion";
    }
    exports2.isAssertion = isAssertion;
    function isBackreference(node) {
      return node.type === "Backreference";
    }
    exports2.isBackreference = isBackreference;
    function isCapturingGroup(node) {
      return node.capturing;
    }
    exports2.isCapturingGroup = isCapturingGroup;
    function isChar(node) {
      return node.type === "Char";
    }
    exports2.isChar = isChar;
    function isCharacterClass(node) {
      return node.type === "CharacterClass";
    }
    exports2.isCharacterClass = isCharacterClass;
    function isClassRange(node) {
      return node.type === "ClassRange";
    }
    exports2.isClassRange = isClassRange;
    function isDisjunction(node) {
      return node.type === "Disjunction";
    }
    exports2.isDisjunction = isDisjunction;
    function isGroup(node) {
      return node.type === "Group";
    }
    exports2.isGroup = isGroup;
    function isNamedBackreference(node) {
      return node.kind === "name";
    }
    exports2.isNamedBackreference = isNamedBackreference;
    function isNumericBackreference(node) {
      return node.kind === "number";
    }
    exports2.isNumericBackreference = isNumericBackreference;
    function isMetaChar(char) {
      return char.kind === "meta";
    }
    exports2.isMetaChar = isMetaChar;
    function isRangeQuantifier(quantifier) {
      return quantifier.kind === "Range";
    }
    exports2.isRangeQuantifier = isRangeQuantifier;
    function isRepetition(node) {
      return node.type === "Repetition";
    }
    exports2.isRepetition = isRepetition;
    function isSimpleChar(char) {
      return char.kind === "simple";
    }
    exports2.isSimpleChar = isSimpleChar;
    function isSimpleQuantifier(quantifier) {
      return ["+", "*", "?"].includes(quantifier.kind);
    }
    exports2.isSimpleQuantifier = isSimpleQuantifier;
  }
});

// node_modules/regex-to-strings/lib/expanders/char-pattern.js
var require_char_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/expanders/char-pattern.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.expandChar = void 0;
    var Expansion_1 = __importDefault(require_Expansion());
    var fisher_yates_random_1 = __importDefault(require_fisher_yates_random());
    var Guards = __importStar(require_regexp_tree_guards());
    var alphaOffsetCharCode = "a".charCodeAt(0) - 1;
    function assertNever(x) {
      throw new Error("Unexpected char type: " + x);
    }
    function expandCharByCodePoint(codePoint, flags) {
      var char = String.fromCodePoint(codePoint);
      var expanded = flags.includes("i") && char.toUpperCase() !== char.toLowerCase() ? [char.toLowerCase(), char.toUpperCase()] : [char];
      var sortChars = function() {
        return fisher_yates_random_1["default"](expanded);
      };
      return new Expansion_1["default"](sortChars, expanded.length);
    }
    function translateEscapedControlChar(escapedControlChar) {
      var controlChar = escapedControlChar.value.substr(-1);
      var controlCharCodeLower = controlChar.toLowerCase().charCodeAt(0);
      var controlCharCodeTranslated = controlCharCodeLower - alphaOffsetCharCode;
      var controlCharString = String.fromCharCode(controlCharCodeTranslated);
      return new Expansion_1["default"]([controlCharString], 1);
    }
    function expandChar(node) {
      var flags = this.flags;
      if (Guards.isSimpleChar(node)) {
        return expandCharByCodePoint(node.codePoint, flags);
      } else if (["oct", "hex", "unicode"].includes(node.kind)) {
        return expandCharByCodePoint(node.codePoint, flags);
      } else if (node.kind === "control") {
        return translateEscapedControlChar(node);
      } else if (node.kind === "decimal") {
        var m = '"' + node.value + '" not removed by decimalCharToOctalCharTransform';
        throw new Error(m);
      } else if (Number.isInteger(node.codePoint)) {
        return expandCharByCodePoint(node.codePoint, flags);
      } else if (Guards.isMetaChar(node)) {
        throw new Error('"' + node.value + '" not removed by metaToCharClassTransform');
      }
      return assertNever(node);
    }
    exports2.expandChar = expandChar;
  }
});

// node_modules/regex-to-strings/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/regex-to-strings/lib/constants/index.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    exports2.__esModule = true;
    exports2.Chars = void 0;
    var nbsp = String.fromCharCode(160);
    var whitespace = (" 	\r\n" + nbsp).split("");
    var digits = "0123456789".split("");
    var underscore = "_";
    var basicLowercase = "abcdefghijklmnopqrstuvwxyz".split("");
    var basicUppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    var basicAlpha = __spreadArray(__spreadArray(__spreadArray([], __read(basicLowercase)), __read(basicUppercase)), [underscore]);
    var basicSpecial = "~`!@#$%^&*()-=+<,>.?/[]{}|\\:;\"'".split("");
    var extendedLowercase = "\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF".split("");
    var extendedUppercase = "\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF".split("");
    var shy = String.fromCharCode(173);
    var extendedSpecial = ("\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xD7\xF7" + shy).split("");
    var windows1252Special = "\u20AC\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\u017D\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\u017E\u0178".split("");
    var extended = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(extendedLowercase)), __read(extendedUppercase)), __read(extendedSpecial)), __read(windows1252Special));
    var all = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(whitespace)), __read(digits)), __read(basicAlpha)), __read(basicSpecial)), __read(extended));
    exports2.Chars = {
      all,
      basicAlpha,
      basicSpecial,
      digits,
      extended,
      whitespace
    };
  }
});

// node_modules/regex-to-strings/lib/helpers/utils.js
var require_utils2 = __commonJS({
  "node_modules/regex-to-strings/lib/helpers/utils.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.fill = void 0;
    function fill(start, end) {
      var result = new Array(1 + end - start);
      for (var i = start; i <= end; i++) {
        result[i - start] = i;
      }
      return result;
    }
    exports2.fill = fill;
  }
});

// node_modules/regex-to-strings/lib/expanders/character-class-pattern.js
var require_character_class_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/expanders/character-class-pattern.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.expandCharacterClass = void 0;
    var constants_1 = require_constants();
    var Expansion_1 = __importDefault(require_Expansion());
    var fisher_yates_random_1 = __importDefault(require_fisher_yates_random());
    var Guards = __importStar(require_regexp_tree_guards());
    var utils_1 = require_utils2();
    function getReferencedCodePoints(expression) {
      if (Guards.isClassRange(expression)) {
        var minCodePoint = expression.from.codePoint;
        var maxCodePoint = expression.to.codePoint;
        return utils_1.fill(minCodePoint, maxCodePoint);
      }
      return [expression.codePoint];
    }
    var allCodePointOptions = constants_1.Chars.all.map(function(char) {
      return char.charCodeAt(0);
    });
    function expandCharacterClass(node) {
      var _this = this;
      var applyCaseInsensitiveFlag = function(accumulator, char) {
        if (_this.flags.includes("i") && char.toLowerCase() !== char.toUpperCase()) {
          return accumulator.concat([char.toLowerCase(), char.toUpperCase()]);
        }
        return accumulator.concat(char);
      };
      var referencedCodePoints = node.expressions.reduce(function(accumulator, expression) {
        var codePoints = getReferencedCodePoints(expression);
        return accumulator.concat(codePoints);
      }, []);
      var expandedClass = allCodePointOptions.filter(function(opt) {
        return !node.negative || !referencedCodePoints.includes(opt);
      }).filter(function(opt) {
        return node.negative || referencedCodePoints.includes(opt);
      }).map(function(codePoint) {
        return String.fromCodePoint(codePoint);
      }).reduce(applyCaseInsensitiveFlag, []);
      var sortChars = function() {
        return fisher_yates_random_1["default"](expandedClass);
      };
      return new Expansion_1["default"](sortChars, expandedClass.length);
    }
    exports2.expandCharacterClass = expandCharacterClass;
  }
});

// node_modules/regex-to-strings/lib/expanders/disjunction-pattern.js
var require_disjunction_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/expanders/disjunction-pattern.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.expandDisjunction = void 0;
    var Expansion_1 = __importDefault(require_Expansion());
    var iterate_sorted_1 = require_iterate_sorted();
    function expandDisjunction(node) {
      var _this = this;
      var expressions = [node.left, node.right];
      var expansions = expressions.map(function(e) {
        return _this.expandExpression(e);
      });
      var expandBothSides = function() {
        return iterate_sorted_1.iterateWeightedByCount(expansions);
      };
      var iterationsSum = expansions[0].count + expansions[1].count;
      return new Expansion_1["default"](expandBothSides, iterationsSum);
    }
    exports2.expandDisjunction = expandDisjunction;
  }
});

// node_modules/regex-to-strings/lib/expanders/group-pattern.js
var require_group_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/expanders/group-pattern.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.expandGroup = exports2.expandBackreference = void 0;
    var Expansion_1 = __importDefault(require_Expansion());
    var Guards = __importStar(require_regexp_tree_guards());
    function assertNever(x) {
      throw new Error("Unexpected backreference: " + x);
    }
    var namedGroups = {};
    var numberedGroups = {};
    function expandBackreference(node) {
      var lookupBackreference = function() {
        return [];
      };
      if (Guards.isNamedBackreference(node)) {
        lookupBackreference = function() {
          return [namedGroups[node.reference]];
        };
      } else if (Guards.isNumericBackreference(node)) {
        lookupBackreference = function() {
          return [numberedGroups[node.number]];
        };
      } else {
        assertNever(node);
      }
      return new Expansion_1["default"](lookupBackreference, 1);
    }
    exports2.expandBackreference = expandBackreference;
    function expandGroup(node) {
      var generator = this.expandExpression(node.expression);
      function expandAndStoreCapture(expression) {
        if (Guards.isCapturingGroup(node)) {
          numberedGroups[node.number] = expression;
          if (node.name) {
            namedGroups[node.name] = expression;
          }
        }
        return expression;
      }
      function expandAndStoreCaptures() {
        var _a2, _b, expression, e_1_1;
        var e_1, _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 5, 6, 7]);
              _a2 = __values(generator.getIterator()), _b = _a2.next();
              _d.label = 1;
            case 1:
              if (!!_b.done)
                return [3, 4];
              expression = _b.value;
              return [4, expandAndStoreCapture(expression)];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              _b = _a2.next();
              return [3, 1];
            case 4:
              return [3, 7];
            case 5:
              e_1_1 = _d.sent();
              e_1 = { error: e_1_1 };
              return [3, 7];
            case 6:
              try {
                if (_b && !_b.done && (_c = _a2["return"]))
                  _c.call(_a2);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
              return [7];
            case 7:
              return [2];
          }
        });
      }
      return new Expansion_1["default"](expandAndStoreCaptures, generator.count);
    }
    exports2.expandGroup = expandGroup;
  }
});

// node_modules/regex-to-strings/lib/expanders/repetition-pattern.js
var require_repetition_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/expanders/repetition-pattern.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.expandRepetition = void 0;
    var Expansion_1 = __importDefault(require_Expansion());
    var Guards = __importStar(require_regexp_tree_guards());
    var iterate_sorted_1 = require_iterate_sorted();
    var utils_1 = require_utils2();
    function assertNever(x) {
      throw new Error("Unexpected quantifier: " + x);
    }
    function getNumOccurrences(quantifier) {
      if (Guards.isSimpleQuantifier(quantifier)) {
        var transformer = "simpleQuantifierToRangeQuantifierTransform";
        throw new Error('"' + quantifier.kind + '" not removed by ' + transformer);
      } else if (!Guards.isRangeQuantifier(quantifier)) {
        assertNever(quantifier);
      }
      var from = quantifier.from, to = quantifier.to;
      return [from, to !== void 0 ? to : 100];
    }
    function expandRepetition(node) {
      var _a2 = __read(getNumOccurrences(node.quantifier), 2), minOccurrences = _a2[0], maxOccurrences = _a2[1];
      var numOccurrenceOptions = utils_1.fill(minOccurrences, maxOccurrences);
      var expansionOnce = this.expandExpression(node.expression);
      var allExpansions = numOccurrenceOptions.map(function(numOccurrences) {
        if (numOccurrences <= 0) {
          return Expansion_1["default"].Blank;
        }
        var expansionNTimes = new Array(numOccurrences).fill(expansionOnce);
        var numPermutationsThisNumOccurrences = Math.pow(expansionOnce.count, numOccurrences);
        return new Expansion_1["default"](function() {
          return iterate_sorted_1.iteratePermutations(expansionNTimes);
        }, numPermutationsThisNumOccurrences);
      });
      var totalNumPermutations = allExpansions.reduce(function(sum, _a3) {
        var count = _a3.count;
        return sum + count;
      }, 0);
      return new Expansion_1["default"](function() {
        return iterate_sorted_1.iterateWeightedByCount(allExpansions);
      }, totalNumPermutations);
    }
    exports2.expandRepetition = expandRepetition;
  }
});

// node_modules/regex-to-strings/lib/Expander.js
var require_Expander = __commonJS({
  "node_modules/regex-to-strings/lib/Expander.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var Expansion_1 = __importDefault(require_Expansion());
    var alternative_pattern_1 = require_alternative_pattern();
    var char_pattern_1 = require_char_pattern();
    var character_class_pattern_1 = require_character_class_pattern();
    var disjunction_pattern_1 = require_disjunction_pattern();
    var group_pattern_1 = require_group_pattern();
    var repetition_pattern_1 = require_repetition_pattern();
    var Guards = __importStar(require_regexp_tree_guards());
    function assertNever(x) {
      throw new Error("Unexpected node type: " + x);
    }
    var Expander = function() {
      function Expander2(flags) {
        this.expandAlternative = alternative_pattern_1.expandAlternative;
        this.expandBackreference = group_pattern_1.expandBackreference;
        this.expandChar = char_pattern_1.expandChar;
        this.expandCharacterClass = character_class_pattern_1.expandCharacterClass;
        this.expandDisjunction = disjunction_pattern_1.expandDisjunction;
        this.expandGroup = group_pattern_1.expandGroup;
        this.expandRepetition = repetition_pattern_1.expandRepetition;
        this.flags = flags;
      }
      Expander2.prototype.expandExpression = function(expression) {
        if (expression === null) {
          return Expansion_1["default"].Blank;
        } else if (Guards.isAlternative(expression)) {
          return this.expandAlternative(expression);
        } else if (Guards.isAssertion(expression)) {
          return Expansion_1["default"].Blank;
        } else if (Guards.isBackreference(expression)) {
          return this.expandBackreference(expression);
        } else if (Guards.isChar(expression)) {
          return this.expandChar(expression);
        } else if (Guards.isCharacterClass(expression)) {
          return this.expandCharacterClass(expression);
        } else if (Guards.isDisjunction(expression)) {
          return this.expandDisjunction(expression);
        } else if (Guards.isGroup(expression)) {
          return this.expandGroup(expression);
        } else if (Guards.isRepetition(expression)) {
          return this.expandRepetition(expression);
        }
        return assertNever(expression);
      };
      return Expander2;
    }();
    exports2["default"] = Expander;
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module) {
    "use strict";
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/regex-to-strings/lib/transforms/decimal-char-to-simple-char-transform.js
var require_decimal_char_to_simple_char_transform = __commonJS({
  "node_modules/regex-to-strings/lib/transforms/decimal-char-to-simple-char-transform.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var escape_string_regexp_1 = __importDefault(require_escape_string_regexp());
    var decimalCharToSimpleCharTransform = {
      Char: function(charPath) {
        var char = charPath.node;
        if (char.kind !== "decimal") {
          return;
        }
        var decimalAsOctal = parseInt(char.codePoint.toString(), 8);
        var convertedDecimalAsChar = String.fromCodePoint(decimalAsOctal);
        var charEscaped = escape_string_regexp_1["default"](convertedDecimalAsChar);
        var simpleChar = {
          codePoint: char.codePoint,
          kind: "simple",
          symbol: charEscaped,
          type: "Char",
          value: charEscaped
        };
        charPath.replace(simpleChar);
      }
    };
    exports2["default"] = decimalCharToSimpleCharTransform;
  }
});

// node_modules/regex-to-strings/lib/transforms/utils.js
var require_utils3 = __commonJS({
  "node_modules/regex-to-strings/lib/transforms/utils.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports2.__esModule = true;
    exports2.createEscapedSimpleChar = exports2.createSimpleChar = void 0;
    function createSimpleChar(value) {
      if (value.length !== 1)
        throw new Error("value must be a char");
      return {
        codePoint: value.codePointAt(0) || 0,
        kind: "simple",
        symbol: value,
        type: "Char",
        value
      };
    }
    exports2.createSimpleChar = createSimpleChar;
    function createEscapedSimpleChar(value) {
      return __assign(__assign({}, createSimpleChar(value)), { escaped: true });
    }
    exports2.createEscapedSimpleChar = createEscapedSimpleChar;
  }
});

// node_modules/regex-to-strings/lib/transforms/meta-to-char-class-transform.js
var require_meta_to_char_class_transform = __commonJS({
  "node_modules/regex-to-strings/lib/transforms/meta-to-char-class-transform.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    exports2.__esModule = true;
    var constants_1 = require_constants();
    var Guards = __importStar(require_regexp_tree_guards());
    var utils_1 = require_utils3();
    var replacer = {
      Alternative: function(parentNode, replacement, child) {
        var iChild = parentNode.expressions.indexOf(child);
        if (iChild > -1) {
          parentNode.expressions[iChild] = replacement;
        }
      },
      CharacterClass: function(parentNode, replacement, child) {
        var _a2;
        var iChild = parentNode.expressions.indexOf(child);
        if (iChild > -1) {
          (_a2 = parentNode.expressions).splice.apply(_a2, __spreadArray([iChild, 1], __read(replacement.expressions)));
        }
      },
      Disjunction: function(parentNode, replacement, child) {
        if (parentNode.left === child) {
          parentNode.left = replacement;
        } else if (parentNode.right === child) {
          parentNode.right = replacement;
        }
      },
      Group: function(parentNode, replacement) {
        parentNode.expression = replacement;
      },
      RegExp: function(parentNode, replacement) {
        parentNode.body = replacement;
      },
      Repetition: function(parentNode, replacement) {
        parentNode.expression = replacement;
      }
    };
    var optionsAlpha = constants_1.Chars.basicAlpha.map(utils_1.createSimpleChar);
    var optionsDigit = constants_1.Chars.digits.map(utils_1.createSimpleChar);
    var optionsWhitespace = constants_1.Chars.whitespace.map(utils_1.createSimpleChar);
    var needEscape = ["]", "-", "\\"];
    var noEscape = constants_1.Chars.basicSpecial.filter(function(c) {
      return !needEscape.includes(c);
    });
    var optionsOther = __spreadArray(__spreadArray([], __read(noEscape.map(utils_1.createSimpleChar))), __read(needEscape.map(utils_1.createEscapedSimpleChar)));
    var optionsExtended = constants_1.Chars.extended.map(utils_1.createSimpleChar);
    function getMetaCharExpressions(metaChar, regExpFlags) {
      switch (metaChar.value) {
        case ".": {
          var optionsNewLine = utils_1.createSimpleChar("\n");
          var optionsDotAll = regExpFlags.includes("s") ? [optionsNewLine] : [];
          var whitespaceNoBreaks = constants_1.Chars.whitespace.filter(function(c) {
            return !"\r\n".includes(c);
          });
          var optionsWhitespaceNoBreak = whitespaceNoBreaks.map(utils_1.createSimpleChar);
          return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(optionsAlpha)), __read(optionsDigit)), __read(optionsWhitespaceNoBreak)), __read(optionsOther)), __read(optionsExtended)), __read(optionsDotAll));
        }
        case "\\w":
          return __spreadArray(__spreadArray([], __read(optionsAlpha)), __read(optionsDigit));
        case "\\W":
          return __spreadArray(__spreadArray(__spreadArray([], __read(optionsWhitespace)), __read(optionsOther)), __read(optionsExtended));
        case "\\d":
          return optionsDigit;
        case "\\D":
          return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(optionsAlpha)), __read(optionsWhitespace)), __read(optionsOther)), __read(optionsExtended));
        case "\\s":
          return optionsWhitespace;
        case "\\S":
          return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(optionsAlpha)), __read(optionsDigit)), __read(optionsOther)), __read(optionsExtended));
        default:
          return [];
      }
    }
    var metaToCharClassTransform = {
      flags: "",
      init: function(ast) {
        this.flags = ast.flags;
      },
      Char: function(charPath) {
        var char = charPath.node, parent = charPath.parent, parentPath = charPath.parentPath;
        if (!parent || !parentPath || !replacer[parent.type]) {
          return;
        }
        if (!Guards.isMetaChar(char)) {
          return;
        }
        var charClassExpressions = getMetaCharExpressions(char, this.flags);
        if (!charClassExpressions.length) {
          return;
        }
        var characterClass = {
          expressions: charClassExpressions,
          type: "CharacterClass"
        };
        var replaceParent = replacer[parent.type];
        replaceParent(parentPath.node, characterClass, char);
      }
    };
    exports2["default"] = metaToCharClassTransform;
  }
});

// node_modules/regex-to-strings/lib/transforms/simple-quantifier-to-range-quantifier-transform.js
var require_simple_quantifier_to_range_quantifier_transform = __commonJS({
  "node_modules/regex-to-strings/lib/transforms/simple-quantifier-to-range-quantifier-transform.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    exports2.__esModule = true;
    var Guards = __importStar(require_regexp_tree_guards());
    function assertNever(x) {
      throw new Error("Unexpected quantifier kind: " + x);
    }
    function getNumOccurrences(quantifier) {
      if (quantifier.kind === "?") {
        return [0, 1];
      } else if (quantifier.kind === "+") {
        return [1, void 0];
      } else if (quantifier.kind === "*") {
        return [0, void 0];
      }
      return assertNever(quantifier.kind);
    }
    var simpleQuantifierToRangeQuantifierTransform = {
      Quantifier: function(quantifierPath) {
        var quantifier = quantifierPath.node;
        if (!Guards.isSimpleQuantifier(quantifier)) {
          return;
        }
        var _a2 = __read(getNumOccurrences(quantifier), 2), minOccurrences = _a2[0], maxOccurrences = _a2[1];
        var equivalentRangeQuantifier = {
          from: minOccurrences,
          greedy: quantifier.greedy,
          kind: "Range",
          to: maxOccurrences,
          type: "Quantifier"
        };
        quantifierPath.replace(equivalentRangeQuantifier);
      }
    };
    exports2["default"] = simpleQuantifierToRangeQuantifierTransform;
  }
});

// node_modules/regex-to-strings/lib/transforms/index.js
var require_transforms3 = __commonJS({
  "node_modules/regex-to-strings/lib/transforms/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var decimal_char_to_simple_char_transform_1 = __importDefault(require_decimal_char_to_simple_char_transform());
    var meta_to_char_class_transform_1 = __importDefault(require_meta_to_char_class_transform());
    var simple_quantifier_to_range_quantifier_transform_1 = __importDefault(require_simple_quantifier_to_range_quantifier_transform());
    var transforms = [
      decimal_char_to_simple_char_transform_1["default"],
      meta_to_char_class_transform_1["default"],
      simple_quantifier_to_range_quantifier_transform_1["default"]
    ];
    exports2["default"] = transforms;
  }
});

// node_modules/regex-to-strings/lib/pattern.js
var require_pattern = __commonJS({
  "node_modules/regex-to-strings/lib/pattern.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.toRegExp = exports2.expandAll = exports2.expandN = exports2.expand = exports2.count = void 0;
    var regexp_tree_1 = require_regexp_tree3();
    var Expander_1 = __importDefault(require_Expander());
    var Expansion_1 = __importDefault(require_Expansion());
    var _1 = require_lib();
    var transforms_1 = __importDefault(require_transforms3());
    var regexAsStringPattern = /^\/([^/\[\\]|\\.|\[([^\]\\]|\\.)*\])*\/[a-z]*$/i;
    function count(pattern) {
      return _1.expand(pattern).count;
    }
    exports2.count = count;
    function expand(pattern) {
      if (pattern === null) {
        return Expansion_1["default"].Empty;
      } else if (!pattern) {
        return Expansion_1["default"].Blank;
      }
      var patternFormatted = _1.toRegExp(pattern);
      var transformed = regexp_tree_1.transform(patternFormatted, transforms_1["default"]);
      var parsed = regexp_tree_1.parse(transformed.toString());
      var expander = new Expander_1["default"](parsed.flags);
      return expander.expandExpression(parsed.body);
    }
    exports2.expand = expand;
    function expandN2(pattern, maxExpansions) {
      var results = [];
      var generator = _1.expand(pattern).getIterator();
      var expansion = generator.next();
      while (!expansion.done && results.length < maxExpansions) {
        results.push(expansion.value);
        expansion = generator.next();
      }
      return results;
    }
    exports2.expandN = expandN2;
    function expandAll(pattern) {
      return __spreadArray([], __read(_1.expand(pattern).getIterator()));
    }
    exports2.expandAll = expandAll;
    function toRegExp(pattern) {
      if (pattern instanceof RegExp) {
        return pattern;
      } else if (regexAsStringPattern.test(pattern.trim())) {
        return regexp_tree_1.compatTranspile(pattern).toRegExp();
      } else {
        return "/" + pattern + "/";
      }
    }
    exports2.toRegExp = toRegExp;
  }
});

// node_modules/regex-to-strings/lib/index.js
var require_lib = __commonJS({
  "node_modules/regex-to-strings/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    exports2.__esModule = true;
    __exportStar(require_pattern(), exports2);
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color2 & 1) * mult * 255;
      const g = (color2 >> 1 & 1) * mult * 255;
      const b = (color2 >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module) {
    var colorString = require_color_string();
    var convert = require_color_convert();
    var skippedModels = [
      "keyword",
      "gray",
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color(object, model) {
      if (!(this instanceof Color)) {
        return new Color(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color2 = [];
        for (i = 0; i < labels.length; i++) {
          color2.push(object[labels[i]]);
        }
        this.color = zeroArray(color2);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          const limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to[self2.model](args);
      },
      percentString(places) {
        const self2 = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p = weight === void 0 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = color1.alpha() - color2.alpha();
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        const w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color(this);
        }
        if (args.length > 0) {
          return new Color(args, model);
        }
        return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color[model] = function(...args) {
        let color2 = args[0];
        if (typeof color2 === "number") {
          color2 = zeroArray(args, channels);
        }
        return new Color(color2, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m of model) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array, length) {
      for (let i = 0; i < length; i++) {
        if (typeof array[i] !== "number") {
          array[i] = 0;
        }
      }
      return array;
    }
    module.exports = Color;
  }
});

// node_modules/lit-html/lib/dom.js
var isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
var removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.removeChild(start);
    start = n;
  }
};

// node_modules/lit-html/lib/template.js
var marker = `{{lit-${String(Math.random()).slice(2)}}}`;
var nodeMarker = `<!--${marker}-->`;
var markerRegex = new RegExp(`${marker}|${nodeMarker}`);
var boundAttributeSuffix = "$lit$";
var Template = class {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element.content, 133, null, false);
    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const { strings, values: { length } } = result;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const { length: length2 } = attributes;
          let count = 0;
          for (let i = 0; i < length2; i++) {
            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
              count++;
            }
          }
          while (count-- > 0) {
            const stringForPart = strings[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({ type: "attribute", index, name, strings: statics });
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings2 = data.split(markerRegex);
          const lastIndex = strings2.length - 1;
          for (let i = 0; i < lastIndex; i++) {
            let insert;
            let s = strings2[i];
            if (s === "") {
              insert = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert = document.createTextNode(s);
            }
            parent.insertBefore(insert, node);
            this.parts.push({ type: "node", index: ++index });
          }
          if (strings2[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings2[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index === lastPartIndex) {
            index++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index;
          this.parts.push({ type: "node", index });
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index--;
          }
          partIndex++;
        } else {
          let i = -1;
          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
            this.parts.push({ type: "node", index: -1 });
            partIndex++;
          }
        }
      }
    }
    for (const n of nodesToRemove) {
      n.parentNode.removeChild(n);
    }
  }
};
var endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};
var isTemplatePartActive = (part) => part.index !== -1;
var createMarker = () => document.createComment("");
var lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

// node_modules/lit-html/lib/modify-template.js
var walkerNodeFilter = 133;
function removeNodesFromTemplate(template, nodesToRemove) {
  const { element: { content }, parts: parts2 } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let part = parts2[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;
  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode;
    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    }
    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node);
      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    }
    if (currentRemovingNode !== null) {
      removeCount++;
    }
    while (part !== void 0 && part.index === nodeIndex) {
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
      part = parts2[partIndex];
    }
  }
  nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
}
var countNodes = (node) => {
  let count = node.nodeType === 11 ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
  while (walker.nextNode()) {
    count++;
  }
  return count;
};
var nextActiveIndexInTemplateParts = (parts2, startIndex = -1) => {
  for (let i = startIndex + 1; i < parts2.length; i++) {
    const part = parts2[i];
    if (isTemplatePartActive(part)) {
      return i;
    }
  }
  return -1;
};
function insertNodeIntoTemplate(template, node, refNode = null) {
  const { element: { content }, parts: parts2 } = template;
  if (refNode === null || refNode === void 0) {
    content.appendChild(node);
    return;
  }
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let insertCount = 0;
  let walkerIndex = -1;
  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;
    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }
    while (partIndex !== -1 && parts2[partIndex].index === walkerIndex) {
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts2[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
        }
        return;
      }
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
    }
  }
}

// node_modules/lit-html/lib/directive.js
var directives = /* @__PURE__ */ new WeakMap();
var directive = (f) => (...args) => {
  const d = f(...args);
  directives.set(d, true);
  return d;
};
var isDirective = (o) => {
  return typeof o === "function" && directives.has(o);
};

// node_modules/lit-html/lib/part.js
var noChange = {};
var nothing = {};

// node_modules/lit-html/lib/template-instance.js
var TemplateInstance = class {
  constructor(template, processor, options2) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options2;
  }
  update(values) {
    let i = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i]);
      }
      i++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
};

// node_modules/lit-html/lib/template-result.js
var policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (s) => s });
var commentMarker = ` ${marker} `;
var TemplateResult = class {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  getHTML() {
    const l = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i = 0; i < l; i++) {
      const s = this.strings[i];
      const commentOpen = s.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s);
      if (attributeMatch === null) {
        html2 += s + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l];
    return html2;
  }
  getTemplateElement() {
    const template = document.createElement("template");
    let value = this.getHTML();
    if (policy !== void 0) {
      value = policy.createHTML(value);
    }
    template.innerHTML = value;
    return template;
  }
};

// node_modules/lit-html/lib/parts.js
var isPrimitive = (value) => {
  return value === null || !(typeof value === "object" || typeof value === "function");
};
var isIterable = (value) => {
  return Array.isArray(value) || !!(value && value[Symbol.iterator]);
};
var AttributeCommitter = class {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];
    for (let i = 0; i < strings.length - 1; i++) {
      this.parts[i] = this._createPart();
    }
  }
  _createPart() {
    return new AttributePart(this);
  }
  _getValue() {
    const strings = this.strings;
    const l = strings.length - 1;
    const parts2 = this.parts;
    if (l === 1 && strings[0] === "" && strings[1] === "") {
      const v = parts2[0].value;
      if (typeof v === "symbol") {
        return String(v);
      }
      if (typeof v === "string" || !isIterable(v)) {
        return v;
      }
    }
    let text = "";
    for (let i = 0; i < l; i++) {
      text += strings[i];
      const part = parts2[i];
      if (part !== void 0) {
        const v = part.value;
        if (isPrimitive(v) || !isIterable(v)) {
          text += typeof v === "string" ? v : String(v);
        } else {
          for (const t of v) {
            text += typeof t === "string" ? t : String(t);
          }
        }
      }
    }
    text += strings[l];
    return text;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
};
var AttributePart = class {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value;
      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective(this.value)) {
      const directive2 = this.value;
      this.value = noChange;
      directive2(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
};
var NodePart = class {
  constructor(options2) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options2;
  }
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());
    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    const value = this.__pendingValue;
    if (value === noChange) {
      return;
    }
    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value) {
    if (this.value === value) {
      return;
    }
    this.clear();
    this.__insert(value);
    this.value = value;
  }
  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? "" : value;
    const valueAsString = typeof value === "string" ? value : String(value);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value;
  }
  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);
    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      const instance = new TemplateInstance(template, value.processor, this.options);
      const fragment = instance._clone();
      instance.update(value.values);
      this.__commitNode(fragment);
      this.value = instance;
    }
  }
  __commitIterable(value) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
};
var BooleanAttributePart = class {
  constructor(element, name, strings) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings.length !== 2 || strings[0] !== "" || strings[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element;
    this.name = name;
    this.strings = strings;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value = !!this.__pendingValue;
    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value;
    }
    this.__pendingValue = noChange;
  }
};
var PropertyCommitter = class extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === "" && strings[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
};
var PropertyPart = class extends AttributePart {
};
var eventOptionsSupported = false;
(() => {
  try {
    const options2 = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (_e) {
  }
})();
var EventPart = class {
  constructor(element, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e) => this.handleEvent(e);
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }
};
var getOptions = (o) => o && (eventOptionsSupported ? { capture: o.capture, passive: o.passive, once: o.once } : o.capture);

// node_modules/lit-html/lib/template-factory.js
function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(result.type, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    template = new Template(result, result.getTemplateElement());
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
}
var templateCaches = /* @__PURE__ */ new Map();

// node_modules/lit-html/lib/render.js
var parts = /* @__PURE__ */ new WeakMap();
var render = (result, container, options2) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options2)));
    part.appendInto(container);
  }
  part.setValue(result);
  part.commit();
};

// node_modules/lit-html/lib/default-template-processor.js
var DefaultTemplateProcessor = class {
  handleAttributeExpressions(element, name, strings, options2) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element, name.slice(1), strings);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart(element, name.slice(1), options2.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart(element, name.slice(1), strings)];
    }
    const committer = new AttributeCommitter(element, name, strings);
    return committer.parts;
  }
  handleTextExpression(options2) {
    return new NodePart(options2);
  }
};
var defaultTemplateProcessor = new DefaultTemplateProcessor();

// node_modules/lit-html/lit-html.js
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
var html = (strings, ...values) => new TemplateResult(strings, values, "html", defaultTemplateProcessor);

// node_modules/lit-html/lib/shady-render.js
var getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
var compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === "undefined") {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
  console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
var shadyTemplateFactory = (scopeName) => (result) => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    const element = result.getTemplateElement();
    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }
    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
};
var TEMPLATE_TYPES = ["html", "svg"];
var removeStylesFromLitTemplates = (scopeName) => {
  TEMPLATE_TYPES.forEach((type) => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
    if (templates !== void 0) {
      templates.keyString.forEach((template) => {
        const { element: { content } } = template;
        const styles = /* @__PURE__ */ new Set();
        Array.from(content.querySelectorAll("style")).forEach((s) => {
          styles.add(s);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};
var shadyRenderSet = /* @__PURE__ */ new Set();
var prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName);
  const templateElement = !!template ? template.element : document.createElement("template");
  const styles = renderedDOM.querySelectorAll("style");
  const { length } = styles;
  if (length === 0) {
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }
  const condensedStyle = document.createElement("style");
  for (let i = 0; i < length; i++) {
    const style2 = styles[i];
    style2.parentNode.removeChild(style2);
    condensedStyle.textContent += style2.textContent;
  }
  removeStylesFromLitTemplates(scopeName);
  const content = templateElement.content;
  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  }
  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content.querySelector("style");
  if (window.ShadyCSS.nativeShadow && style !== null) {
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = /* @__PURE__ */ new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
var render2 = (result, container, options2) => {
  if (!options2 || typeof options2 !== "object" || !options2.scopeName) {
    throw new Error("The `scopeName` option is required.");
  }
  const scopeName = options2.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options2));
  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);
    const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
    prepareTemplateStyles(scopeName, renderContainer, template);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  }
  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};

// node_modules/lit-element/lib/updating-element.js
var _a;
window.JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? "" : null;
      case Object:
      case Array:
        return value == null ? value : JSON.stringify(value);
    }
    return value;
  },
  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;
      case Number:
        return value === null ? null : Number(value);
      case Object:
      case Array:
        return JSON.parse(value);
    }
    return value;
  }
};
var notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var STATE_HAS_UPDATED = 1;
var STATE_UPDATE_REQUESTED = 1 << 2;
var STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
var STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
var finalized = "finalized";
var UpdatingElement = class extends HTMLElement {
  constructor() {
    super();
    this.initialize();
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this._classProperties.forEach((v, p) => {
      const attr = this._attributeNameForProperty(p, v);
      if (attr !== void 0) {
        this._attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const superProperties = Object.getPrototypeOf(this)._classProperties;
      if (superProperties !== void 0) {
        superProperties.forEach((v, k) => this._classProperties.set(k, v));
      }
    }
  }
  static createProperty(name, options2 = defaultPropertyDeclaration) {
    this._ensureClassProperties();
    this._classProperties.set(name, options2);
    if (options2.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }
    const key = typeof name === "symbol" ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options2);
    if (descriptor !== void 0) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  static getPropertyDescriptor(name, key, options2) {
    return {
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdateInternal(name, oldValue, options2);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  static finalize() {
    const superCtor = Object.getPrototypeOf(this);
    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }
    this[finalized] = true;
    this._ensureClassProperties();
    this._attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
  }
  static _attributeNameForProperty(name, options2) {
    const attribute2 = options2.attribute;
    return attribute2 === false ? void 0 : typeof attribute2 === "string" ? attribute2 : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  static _propertyValueFromAttribute(value, options2) {
    const type = options2.type;
    const converter = options2.converter || defaultConverter;
    const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  static _propertyValueToAttribute(value, options2) {
    if (options2.reflect === void 0) {
      return;
    }
    const type = options2.type;
    const converter = options2.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  initialize() {
    this._updateState = 0;
    this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
    this._changedProperties = /* @__PURE__ */ new Map();
    this._saveInstanceProperties();
    this.requestUpdateInternal();
  }
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        const value = this[p];
        delete this[p];
        if (!this._instanceProperties) {
          this._instanceProperties = /* @__PURE__ */ new Map();
        }
        this._instanceProperties.set(p, value);
      }
    });
  }
  _applyInstanceProperties() {
    this._instanceProperties.forEach((v, p) => this[p] = v);
    this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    if (this._enableUpdatingResolver !== void 0) {
      this._enableUpdatingResolver();
      this._enableUpdatingResolver = void 0;
    }
  }
  disconnectedCallback() {
  }
  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }
  _propertyToAttribute(name, value, options2 = defaultPropertyDeclaration) {
    const ctor = this.constructor;
    const attr = ctor._attributeNameForProperty(name, options2);
    if (attr !== void 0) {
      const attrValue = ctor._propertyValueToAttribute(value, options2);
      if (attrValue === void 0) {
        return;
      }
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }
  _attributeToProperty(name, value) {
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }
    const ctor = this.constructor;
    const propName = ctor._attributeToPropertyMap.get(name);
    if (propName !== void 0) {
      const options2 = ctor.getPropertyOptions(propName);
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = ctor._propertyValueFromAttribute(value, options2);
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  requestUpdateInternal(name, oldValue, options2) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      const ctor = this.constructor;
      options2 = options2 || ctor.getPropertyOptions(name);
      if (ctor._valueHasChanged(this[name], oldValue, options2.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        }
        if (options2.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === void 0) {
            this._reflectingProperties = /* @__PURE__ */ new Map();
          }
          this._reflectingProperties.set(name, options2);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  requestUpdate(name, oldValue) {
    this.requestUpdateInternal(name, oldValue);
    return this.updateComplete;
  }
  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    try {
      await this._updatePromise;
    } catch (e) {
    }
    const result = this.performUpdate();
    if (result != null) {
      await result;
    }
    return !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }
  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  performUpdate() {
    if (!this._hasRequestedUpdate) {
      return;
    }
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }
    let shouldUpdate = false;
    const changedProperties = this._changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this._markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  get updateComplete() {
    return this._getUpdateComplete();
  }
  _getUpdateComplete() {
    return this._updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
      this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
      this._reflectingProperties = void 0;
    }
    this._markUpdated();
  }
  updated(_changedProperties) {
  }
  firstUpdated(_changedProperties) {
  }
};
_a = finalized;
UpdatingElement[_a] = true;

// node_modules/lit-element/lib/decorators.js
var ElementProto = Element.prototype;
var legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;

// node_modules/lit-element/lib/css-tag.js
var supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var CSSResult = class {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  get styleSheet() {
    if (this._styleSheet === void 0) {
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();
        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var unsafeCSS = (value) => {
  return new CSSResult(String(value), constructionToken);
};
var textFromCSSResult = (value) => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
var css = (strings, ...values) => {
  const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};

// node_modules/lit-element/lit-element.js
(window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.4.0");
var renderNotImplemented = {};
var LitElement = class extends UpdatingElement {
  static getStyles() {
    return this.styles;
  }
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
      return;
    }
    const userStyles = this.getStyles();
    if (Array.isArray(userStyles)) {
      const addStyles = (styles2, set2) => styles2.reduceRight((set3, s) => Array.isArray(s) ? addStyles(s, set3) : (set3.add(s), set3), set2);
      const set = addStyles(userStyles, /* @__PURE__ */ new Set());
      const styles = [];
      set.forEach((v) => styles.unshift(v));
      this._styles = styles;
    } else {
      this._styles = userStyles === void 0 ? [] : [userStyles];
    }
    this._styles = this._styles.map((s) => {
      if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
        const cssText = Array.prototype.slice.call(s.cssRules).reduce((css2, rule) => css2 + rule.cssText, "");
        return unsafeCSS(cssText);
      }
      return s;
    });
  }
  initialize() {
    super.initialize();
    this.constructor._getUniqueStyles();
    this.renderRoot = this.createRenderRoot();
    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  createRenderRoot() {
    return this.attachShadow({ mode: "open" });
  }
  adoptStyles() {
    const styles = this.constructor._styles;
    if (styles.length === 0) {
      return;
    }
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
    } else {
      this._needsShimAdoptedStyleSheets = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hasUpdated && window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
  }
  update(changedProperties) {
    const templateResult = this.render();
    super.update(changedProperties);
    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
    }
    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;
      this.constructor._styles.forEach((s) => {
        const style = document.createElement("style");
        style.textContent = s.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  render() {
    return renderNotImplemented;
  }
};
LitElement["finalized"] = true;
LitElement.render = render2;

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = /[&<>"']/g;
var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape2(html2, encode) {
  if (encode) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html2) {
  return html2.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape2(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text, [])
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape2(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim() : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, "");
      return {
        type: "blockquote",
        raw: cap[0],
        tokens: this.lexer.blockTokens(text, []),
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0];
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            line = rawLine;
            if (this.options.pedantic) {
              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(line)) {
              break;
            }
            if (headingBeginRegex.test(line)) {
              break;
            }
            if (nextBulletRegex.test(line)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (line.search(/[^ ]/) >= indent || !line.trim()) {
              itemContents += "\n" + line.slice(indent);
            } else if (!blankLine) {
              itemContents += "\n" + line;
            } else {
              break;
            }
            if (!blankLine && !line.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        const spacers = list.items[i].tokens.filter((t) => t.type === "space");
        const hasMultipleLineBreaks = spacers.every((t) => {
          const chars = t.raw.split("");
          let lineBreaks = 0;
          for (const char of chars) {
            if (char === "\n") {
              lineBreaks += 1;
            }
            if (lineBreaks > 1) {
              return true;
            }
          }
          return false;
        });
        if (!list.loose && spacers.length && hasMultipleLineBreaks) {
          list.loose = true;
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        token.type = "paragraph";
        token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]);
        token.tokens = [];
        this.lexer.inline(token.text, token.tokens);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3])
        cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      return {
        type: "def",
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = [];
          this.lexer.inline(item.header[j].text, item.header[j].tokens);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = [];
            this.lexer.inline(row[k].text, row[k].tokens);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const token = {
        type: "paragraph",
        raw: cap[0],
        text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      const token = {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape2(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link || !link.href) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = src.slice(1, lLength + match.index + rLength);
          return {
            type: "em",
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text2,
            tokens: this.lexer.inlineTokens(text2, [])
          };
        }
        const text = src.slice(2, lLength + match.index + rLength - 1);
        return {
          type: "strong",
          raw: src.slice(0, lLength + match.index + rLength + 1),
          text,
          tokens: this.lexer.inlineTokens(text, [])
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape2(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2], [])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape2(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape2(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape2(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape2(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + text;
        } else {
          href = text;
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0];
      } else {
        text = escape2(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
});
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /\\\*|\\_/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  static get rules() {
    return {
      block,
      inline
    };
  }
  static lex(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.lex(src);
  }
  static lexInline(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens) {
    this.inlineQueue.push({ src, tokens });
  }
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape2(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape2(lang, true) + '">' + (escaped ? code : escape2(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html2) {
    return html2;
  }
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>
`;
    }
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  em(text) {
    return `<em>${text}</em>`;
  }
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(text) {
    return `<del>${text}</del>`;
  }
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + escape2(href) + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  static parse(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parse(tokens);
  }
  static parseInline(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parseInline(tokens);
  }
  parse(tokens, top = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length)
      return done();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
    }
    throw e;
  }
}
marked.options = marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const opts = merge({}, ...args);
  const extensions2 = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  let hasExtensions;
  args.forEach((pack) => {
    if (pack.extensions) {
      hasExtensions = true;
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions2.renderers ? extensions2.renderers[ext.name] : null;
          if (prevRenderer) {
            extensions2.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions2.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions2[ext.level]) {
            extensions2[ext.level].unshift(ext.tokenizer);
          } else {
            extensions2[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions2.startBlock) {
                extensions2.startBlock.push(ext.start);
              } else {
                extensions2.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions2.startInline) {
                extensions2.startInline.push(ext.start);
              } else {
                extensions2.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions2.childTokens[ext.name] = ext.childTokens;
        }
      });
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        pack.walkTokens.call(this, token);
        if (walkTokens2) {
          walkTokens2.call(this, token);
        }
      };
    }
    if (hasExtensions) {
      opts.extensions = extensions2;
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  for (const token of tokens) {
    callback.call(marked, token);
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          marked.walkTokens(cell.tokens, callback);
        }
        for (const row of token.rows) {
          for (const cell of row) {
            marked.walkTokens(cell.tokens, callback);
          }
        }
        break;
      }
      case "list": {
        marked.walkTokens(token.items, callback);
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            marked.walkTokens(token[childTokens], callback);
          });
        } else if (token.tokens) {
          marked.walkTokens(token.tokens, callback);
        }
      }
    }
  }
};
marked.parseInline = function(src, opt) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
    }
    throw e;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// node_modules/openapi-explorer/dist/es/openapi-explorer.js
var import_prismjs3 = __toESM(require_prism());

// node_modules/prismjs/components/prism-css.js
(function(Prism5) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism5.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
      }
    },
    "url": {
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism5.languages.css["atrule"].inside.rest = Prism5.languages.css;
  var markup = Prism5.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);

// node_modules/prismjs/components/prism-yaml.js
(function(Prism5) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism5.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism5.languages.yml = Prism5.languages.yaml;
})(Prism);

// node_modules/prismjs/components/prism-go.js
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];

// node_modules/prismjs/components/prism-java.js
(function(Prism5) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism5.languages.java = Prism5.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "function": [
      Prism5.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    }
  });
  Prism5.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism5.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);

// node_modules/prismjs/components/prism-json.js
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;

// node_modules/prismjs/components/prism-bash.js
(function(Prism5) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    inside: null
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism5.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      {
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    "string": [
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      {
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism5.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside[toBeCopied[i]] = Prism5.languages.bash[toBeCopied[i]];
  }
  Prism5.languages.shell = Prism5.languages.bash;
})(Prism);

// node_modules/prismjs/components/prism-python.js
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;

// node_modules/prismjs/components/prism-http.js
(function(Prism5) {
  function headerValueOf(name) {
    return RegExp("(^(?:" + name + "):[ 	]*(?![ 	]))[^]+", "i");
  }
  Prism5.languages.http = {
    "request-line": {
      pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
      inside: {
        "method": {
          pattern: /^[A-Z]+\b/,
          alias: "property"
        },
        "request-target": {
          pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
          lookbehind: true,
          alias: "url",
          inside: Prism5.languages.uri
        },
        "http-version": {
          pattern: /^(\s)HTTP\/[\d.]+/,
          lookbehind: true,
          alias: "property"
        }
      }
    },
    "response-status": {
      pattern: /^HTTP\/[\d.]+ \d+ .+/m,
      inside: {
        "http-version": {
          pattern: /^HTTP\/[\d.]+/,
          alias: "property"
        },
        "status-code": {
          pattern: /^(\s)\d+(?=\s)/,
          lookbehind: true,
          alias: "number"
        },
        "reason-phrase": {
          pattern: /^(\s).+/,
          lookbehind: true,
          alias: "string"
        }
      }
    },
    "header": {
      pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
      inside: {
        "header-value": [
          {
            pattern: headerValueOf(/Content-Security-Policy/.source),
            lookbehind: true,
            alias: ["csp", "languages-csp"],
            inside: Prism5.languages.csp
          },
          {
            pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
            lookbehind: true,
            alias: ["hpkp", "languages-hpkp"],
            inside: Prism5.languages.hpkp
          },
          {
            pattern: headerValueOf(/Strict-Transport-Security/.source),
            lookbehind: true,
            alias: ["hsts", "languages-hsts"],
            inside: Prism5.languages.hsts
          },
          {
            pattern: headerValueOf(/[^:]+/.source),
            lookbehind: true
          }
        ],
        "header-name": {
          pattern: /^[^:]+/,
          alias: "keyword"
        },
        "punctuation": /^:/
      }
    }
  };
  var langs = Prism5.languages;
  var httpLanguages = {
    "application/javascript": langs.javascript,
    "application/json": langs.json || langs.javascript,
    "application/xml": langs.xml,
    "text/xml": langs.xml,
    "text/html": langs.html,
    "text/css": langs.css,
    "text/plain": langs.plain
  };
  var suffixTypes = {
    "application/json": true,
    "application/xml": true
  };
  function getSuffixPattern(contentType2) {
    var suffix = contentType2.replace(/^[a-z]+\//, "");
    var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
    return "(?:" + contentType2 + "|" + suffixPattern + ")";
  }
  var options2;
  for (var contentType in httpLanguages) {
    if (httpLanguages[contentType]) {
      options2 = options2 || {};
      var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
      options2[contentType.replace(/\//g, "-")] = {
        pattern: RegExp(
          "(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + /[^ \t\w-][\s\S]*/.source,
          "i"
        ),
        lookbehind: true,
        inside: httpLanguages[contentType]
      };
    }
  }
  if (options2) {
    Prism5.languages.insertBefore("http", "header", options2);
  }
})(Prism);

// node_modules/prismjs/components/prism-csharp.js
(function(Prism5) {
  function replace(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m, index) {
      return "(?:" + replacements[+index] + ")";
    });
  }
  function re(pattern, replacements, flags) {
    return RegExp(replace(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i = 0; i < depthLog2; i++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    typeDeclaration: "class enum interface record struct",
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name, generic]);
  var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
  var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism5.languages.csharp = Prism5.languages.extend("clike", {
    "string": [
      {
        pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
        lookbehind: true,
        greedy: true
      }
    ],
    "class-name": [
      {
        pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name, typeExpression]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name]),
        lookbehind: true
      },
      {
        pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\bwhere\s+)<<0>>/.source, [name]),
        lookbehind: true
      },
      {
        pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name]),
        inside: typeInside
      }
    ],
    "keyword": keywords,
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism5.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism5.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism5.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    "generic-method": {
      pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name, generic]),
      inside: {
        "function": re(/^<<0>>/.source, [name]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      pattern: re(
        /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
        [typeDeclarationKeywords, genericName, name, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]
      ),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism5.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
  Prism5.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism5.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism5.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism5.languages.insertBefore("csharp", "string", {
    "interpolation-string": [
      {
        pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(mInterpolation, mInterpolationRound)
      },
      {
        pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(sInterpolation, sInterpolationRound)
      }
    ],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism5.languages.dotnet = Prism5.languages.cs = Prism5.languages.csharp;
})(Prism);

// node_modules/openapi-explorer/dist/es/styles/font-styles.js
var font_styles_default = css`.hover-bg:hover{background:var(--bg3)}::selection{background:var(--selection-bg);color:var(--selection-fg)}.regular-font{font-family:var(--font-regular)}.mono-font{font-family:var(--font-mono)}.title{font-size:calc(var(--font-size-small) + 18px);font-weight:400}.sub-title{font-size:20px}.req-res-title{font-family:var(--font-regular);font-size:calc(var(--font-size-small) + 4px);font-weight:700}.tiny-title{font-size:calc(var(--font-size-small) + 1px);font-weight:700}.regular-font-size{font-size:var(--font-size-regular)}.small-font-size{font-size:var(--font-size-small)}.upper{text-transform:uppercase}.primary-text{color:var(--primary-color)}.bold-text{font-weight:700}.gray-text{color:var(--light-fg)}.red-text{color:var(--red)}.blue-text{color:var(--blue)}.multiline{overflow:scroll;max-height:var(--resp-area-height,300px);color:var(--fg3)}.method-fg.put{color:var(--orange)}.method-fg.post{color:var(--green)}.method-fg.get,.method-fg.head{color:var(--blue)}.method-fg.delete{color:var(--red)}.method-fg.options{color:var(--purple)}.method-fg.patch{color:var(--yellow)}h1{font-family:var(--font-regular);font-size:28px;padding-top:10px;letter-spacing:normal;font-weight:400}h2{font-family:var(--font-regular);font-size:24px;padding-top:10px;letter-spacing:normal;font-weight:400}h3{font-family:var(--font-regular);font-size:18px;padding-top:10px;letter-spacing:normal;font-weight:400}h4{font-family:var(--font-regular);font-size:16px;padding-top:10px;letter-spacing:normal;font-weight:400}h5{font-family:var(--font-regular);font-size:14px;padding-top:10px;letter-spacing:normal;font-weight:400}h6{font-family:var(--font-regular);font-size:14px;padding-top:10px;letter-spacing:normal;font-weight:400}h1,h2,h3,h4,h5{margin-block-end:.2em}h3{margin-top:0}p{margin-block-start:.5em}a{color:var(--blue);cursor:pointer}a.inactive-link{color:var(--fg);text-decoration:none;cursor:text}code,pre{margin:0;font-family:var(--font-mono);font-size:calc(var(--font-size-mono) - 1px)}.m-markdown,.m-markdown-small{display:block}.m-markdown li,.m-markdown p,.m-markdown span{font-size:var(--font-size-regular);line-height:calc(var(--font-size-regular) + 6px)}.m-markdown-small li,.m-markdown-small p,.m-markdown-small span{font-size:var(--font-size-small);line-height:calc(var(--font-size-small) + 6px)}.m-markdown p:not(:first-child){margin-block-start:24px}.m-markdown-small p:not(:first-child){margin-block-start:12px}.m-markdown-small p:first-child{margin-block-start:0}.m-markdown p,.m-markdown-small p{margin-block-end:0}.toolbar .m-markdown p,.toolbar .m-markdown-small p{margin-block-start:0}.m-markdown code span{font-size:var(--font-size-mono)}.m-markdown code,.m-markdown-small code{padding:1px 6px;border-radius:2px;color:var(--inline-code-fg);background-color:var(--bg3);font-size:calc(var(--font-size-mono));line-height:1.2}.m-markdown-small code{font-size:calc(var(--font-size-mono) - 1px)}.m-markdown pre,.m-markdown-small pre{white-space:pre-wrap;overflow-x:auto;line-height:normal;border-radius:2px;border:1px solid var(--code-border-color)}.m-markdown pre{padding:8px;background-color:var(--code-bg);color:var(--code-fg)}.m-markdown-small pre{margin-top:4px;padding:2px 4px;background-color:var(--bg3);color:var(--fg2)}.m-markdown pre code,.m-markdown-small pre code{border:none;padding:0}.m-markdown pre code{color:var(--code-fg);background-color:var(--code-bg);background-color:transparent}.m-markdown-small pre code{color:var(--fg2);background-color:var(--bg3)}.m-markdown ol,.m-markdown ul{padding-inline-start:30px}.m-markdown-small ol,.m-markdown-small ul{padding-inline-start:20px}.m-markdown a,.m-markdown-small a{color:var(--blue)}.m-markdown img,.m-markdown-small img{max-width:100%}.m-markdown table,.m-markdown-small table{border-spacing:0;margin:10px 0;border-collapse:separate;border:1px solid var(--border-color);border-radius:var(--border-radius);font-size:calc(var(--font-size-small) + 1px);line-height:calc(var(--font-size-small) + 4px);max-width:100%}.m-markdown-small table{font-size:var(--font-size-small);line-height:calc(var(--font-size-small) + 2px);margin:8px 0}.m-markdown td,.m-markdown th,.m-markdown-small td,.m-markdown-small th{vertical-align:top;border-top:1px solid var(--border-color);line-height:calc(var(--font-size-small) + 4px)}.m-markdown tr:first-child th,.m-markdown-small tr:first-child th{border-top:0 none}.m-markdown td,.m-markdown th{padding:10px 12px}.m-markdown-small td,.m-markdown-small th{padding:8px 8px}.m-markdown th,.m-markdown-small th{font-weight:600;background-color:var(--bg2);vertical-align:middle}.m-markdown-small table code{font-size:calc(var(--font-size-mono) - 2px)}.m-markdown table code{font-size:calc(var(--font-size-mono) - 1px)}.m-markdown blockquote,.m-markdown-small blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid var(--border-color);padding:6px 0 6px 6px}`;

// node_modules/openapi-explorer/dist/es/styles/input-styles.js
var input_styles_default = css`.m-btn{border-radius:var(--border-radius);font-weight:600;display:inline-block;padding:6px 16px;font-size:var(--font-size-small);outline:0;line-height:1;text-align:center;white-space:nowrap;border:2px solid var(--primary-color);background-color:transparent;transition:background-color .2s;user-select:none;cursor:pointer;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}.m-btn.primary{background-color:var(--primary-color);color:var(--primary-btn-text-color)}.m-btn.thin-border{border-width:1px}.m-btn.large{padding:8px 14px}.m-btn.small{padding:5px 12px}.m-btn.tiny{padding:5px 6px}.m-btn.circle{border-radius:50%}.m-btn:hover{background-color:var(--primary-color);color:var(--primary-btn-text-color)}.m-btn.nav{border:2px solid var(--secondary-color)}.m-btn.nav:hover{background-color:var(--secondary-color)}.m-btn:disabled{background-color:var(--bg3);color:var(--fg3);border-color:var(--fg3);cursor:progress;opacity:.4}.toolbar-copy-btn{cursor:pointer;padding:.125rem .5rem;margin:0 2px;font-size:.8rem;width:56px;color:var(--primary-btn-text-color);border-radius:2px;border:none;background-color:var(--primary-color)}.tab-content .toolbar-copy-btn{position:absolute;top:8px;right:8px;margin-right:8px}.tab-content .toolbar-copy-btn+pre{white-space:pre;max-height:400px;overflow:auto;display:flex;padding-right:70px}button,input,pre,select,textarea{color:var(--fg);outline:0;background-color:var(--input-bg);border:1px solid var(--border-color);border-radius:var(--border-radius)}button{font-family:var(--font-regular)}input[type=file],input[type=password],input[type=text],pre,select,textarea{font-family:var(--font-mono);font-weight:400;font-size:var(--font-size-small);transition:border .2s;padding:6px 5px}select{font-family:var(--font-regular);padding-right:30px;background-image:url("data:image/svg+xml;charset=utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%3Cpath%20d%3D%22M10.3%203.3L6%207.6%201.7%203.3A1%201%200%2000.3%204.7l5%205a1%201%200%20001.4%200l5-5a1%201%200%2010-1.4-1.4z%22%20fill%3D%22%23777777%22%2F%3E%3C%2Fsvg%3E");background-position:calc(100% - 5px) center;background-repeat:no-repeat;background-size:10px;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer}select:hover{border-color:var(--primary-color)}input[type=password]::placeholder,input[type=text]::placeholder,textarea::placeholder{color:var(--placeholder-color);opacity:1}input[type=password]:active,input[type=password]:focus,input[type=text]:active,input[type=text]:focus,select:focus,textarea:active,textarea:focus{border:1px solid var(--primary-color)}input[type=file]{font-family:var(--font-regular);padding:2px;cursor:pointer;border:1px solid var(--primary-color);min-height:calc(var(--font-size-small) + 18px)}input[type=file]::-webkit-file-upload-button{font-family:var(--font-regular);font-size:var(--font-size-small);outline:0;cursor:pointer;padding:3px 8px;border:1px solid var(--primary-color);background-color:var(--primary-color);color:var(--primary-btn-text-color);border-radius:var(--border-radius);-webkit-appearance:none}pre,textarea{scrollbar-width:thin;scrollbar-color:var(--border-color) var(--input-bg)}pre::-webkit-scrollbar,textarea::-webkit-scrollbar{width:8px;height:8px}pre::-webkit-scrollbar-track,textarea::-webkit-scrollbar-track{background:var(--input-bg)}pre::-webkit-scrollbar-thumb,textarea::-webkit-scrollbar-thumb{border-radius:2px;background-color:var(--border-color)}.link{font-size:var(--font-size-small);text-decoration:underline;color:var(--blue);font-family:var(--font-mono);margin-bottom:2px}input[type=checkbox]:focus{outline:0}input[type=checkbox]{appearance:none;display:inline-block;background-color:var(--light-bg);border-radius:9px;cursor:pointer;height:18px;position:relative;transition:border .15s,padding .25s;min-width:36px;width:36px;vertical-align:top}input[type=checkbox]:after{position:absolute;background-color:var(--bg);border-radius:8px;content:'';top:0;left:0;right:16px;display:block;height:16px;transition:left .25s .1s,right .15s .175s}input[type=checkbox]:checked{box-shadow:inset 0 0 0 13px var(--primary-color);border-color:var(--primary-color)}input[type=checkbox]:checked:after{border:1px solid var(--primary-color);left:16px;right:1px;transition:border .25s,left .15s .25s,right .25s .175s}input.oauth-client-id{flex-grow:1;max-width:300px}input.oauth-client-secret{flex-grow:1;max-width:300px}`;

// node_modules/openapi-explorer/dist/es/styles/flex-styles.js
var flex_styles_default = css`.col,.row{display:flex}.row{align-items:center;flex-direction:row}.col{align-items:stretch;flex-direction:column}`;

// node_modules/openapi-explorer/dist/es/styles/table-styles.js
var table_styles_default = css`.m-table{border-spacing:0;border-collapse:separate;border:1px solid var(--light-border-color);border-radius:var(--border-radius);margin:0;max-width:100%}.m-table tr:first-child td,.m-table tr:first-child th{border-top:0 none}.m-table td,.m-table th{font-size:var(--font-size-small);padding:4px 5px 4px}.m-table td:not([align]),.m-table th:not([align]){text-align:left}.m-table th{color:var(--fg2);font-size:var(--font-size-small);line-height:calc(var(--font-size-small) + 18px);font-weight:600;letter-spacing:normal;background-color:var(--bg2);vertical-align:bottom;border-bottom:1px solid var(--light-border-color)}.m-table>tbody>tr>td,.m-table>tr>td{border-top:1px solid var(--light-border-color)}.table-title{font-size:var(--font-size-small);font-weight:700;vertical-align:middle;margin:12px 0 4px 0}`;

// node_modules/openapi-explorer/dist/es/styles/endpoint-styles.js
var endpoint_styles_default = css`.only-large-screen{display:none}.endpoint-head .path{display:flex;font-family:var(--font-mono);font-size:var(--font-size-small);align-items:center;overflow-wrap:break-word;word-break:break-all}.endpoint-head .descr{font-size:var(--font-size-small);color:var(--light-fg);font-weight:400;align-items:center;overflow-wrap:break-word;word-break:break-all;display:none}.m-endpoint.expanded{margin-bottom:16px}.m-endpoint>.endpoint-head{border-width:1px 1px 1px 5px;border-style:solid;border-color:transparent;border-top-color:var(--light-border-color);display:flex;padding:6px 16px;align-items:center;cursor:pointer}.m-endpoint>.endpoint-head.put.expanded,.m-endpoint>.endpoint-head.put:hover{border-color:var(--orange);background-color:var(--light-orange)}.m-endpoint>.endpoint-head.post.expanded,.m-endpoint>.endpoint-head.post:hover{border-color:var(--green);background-color:var(--light-green)}.m-endpoint>.endpoint-head.get.expanded,.m-endpoint>.endpoint-head.get:hover,.m-endpoint>.endpoint-head.head.expanded,.m-endpoint>.endpoint-head.head:hover{border-color:var(--blue);background-color:var(--light-blue)}.m-endpoint>.endpoint-head.delete.expanded,.m-endpoint>.endpoint-head.delete:hover{border-color:var(--red);background-color:var(--light-red)}.m-endpoint>.endpoint-head.patch.expanded,.m-endpoint>.endpoint-head.patch:hover{border-color:var(--yellow);background-color:var(--light-yellow)}.m-endpoint>.endpoint-head.options.expanded,.m-endpoint>.endpoint-head.options:hover{border-color:var(--purple);background-color:var(--light-purple)}.m-endpoint .endpoint-body{word-break:break-word;flex-wrap:wrap;padding:16px 0 0 0;border-width:0 1px 1px 5px;border-style:solid;box-shadow:0 4px 3px -3px rgba(0,0,0,.15)}.m-endpoint .endpoint-body.delete{border-color:var(--red)}.m-endpoint .endpoint-body.put{border-color:var(--orange)}.m-endpoint .endpoint-body.post{border-color:var(--green)}.m-endpoint .endpoint-body.get,.m-endpoint .endpoint-body.head{border-color:var(--blue)}.m-endpoint .endpoint-body.patch{border-color:var(--yellow)}.m-endpoint .endpoint-body.options{border-color:var(--purple)}.summary{padding:8px 8px}.summary .title{font-size:calc(var(--font-size-regular) + 2px);margin-bottom:6px;word-break:break-word}.method{padding:2px 5px;vertical-align:middle;font-size:var(--font-size-small);height:calc(var(--font-size-small) + 16px);line-height:calc(var(--font-size-small) + 8px);width:68px;flex-shrink:0;border-radius:2px;display:inline-block;text-align:center;font-weight:700;text-transform:uppercase;margin-right:5px}.method.delete{border:2px solid var(--red)}.method.put{border:2px solid var(--orange)}.method.post{border:2px solid var(--green)}.method.get,.method.head{border:2px solid var(--blue)}.method.patch{border:2px solid var(--yellow)}.method.options{border:2px solid var(--purple)}.req-resp-container{display:flex;margin-top:16px;align-items:stretch;flex-wrap:wrap;flex-direction:column}.view-request{flex:1;min-height:100px;max-width:100%;padding:16px 8px;overflow:hidden;border-width:0;border-style:dashed}.request,.response{flex:1;min-height:100px;max-width:100%;padding:16px 8px;overflow:hidden}.request{border-width:0 0 1px 0;border-style:dashed}.patch .request{border-top:1px dashed var(--yellow);border-color:var(--yellow)}.options .request{border-top:1px dashed var(--purple);border-color:var(--purple)}.put .request{border-top:1px dashed var(--orange);border-color:var(--orange)}.post .request{border-top:1px dashed var(--green);border-color:var(--green)}.get .request,.head .request{border-top:1px dashed var(--blue);border-color:var(--blue)}.delete .request{border-top:1px dashed var(--red);border-color:var(--red)}@media only screen and (min-width:1024px){.only-large-screen{display:block}.endpoint-head .path{font-size:var(--font-size-regular);min-width:400px}.endpoint-head .descr{display:flex}.descr .m-markdown-small,.endpoint-head .m-markdown-small{display:block}.req-resp-container{flex-direction:var(--layout,row)}.request{border-width:0 1px 0 0;padding:16px}.response{padding:16px}.summary{padding:8px 16px}}.security-info-button{position:absolute;top:3px;right:2px;font-size:var(--font-size-small);line-height:1.5}@media only screen and (max-width:768px){.security-info-button{display:none}}pre.code-sample{padding:8px;min-height:30px;font-family:var(--font-mono);font-size:var(--font-size-small)}`;

// node_modules/openapi-explorer/dist/es/styles/prism-styles.js
var prism_styles_default = css`code[class*=language-],pre[class*=language-]{text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-]{white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:var(--light-fg)}.token.punctuation{color:var(--fg)}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:var(--pink)}.token.function-name{color:var(--blue)}.token.boolean,.token.function,.token.number{color:var(--red)}.token.class-name,.token.constant,.token.property,.token.symbol{color:var(--code-property-color)}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:var(--code-keyword-color)}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:var(--green);white-space:pre-wrap;line-break:anywhere}.token.entity,.token.operator,.token.url{color:var(--code-operator-color)}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}`;

// node_modules/openapi-explorer/dist/es/styles/tab-styles.js
var tab_styles_default = css`.tab-panel{border:none}.tab-buttons{height:30px;border-bottom:1px solid var(--light-border-color);align-items:stretch;overflow-y:hidden;overflow-x:auto;scrollbar-width:thin}.tab-buttons::-webkit-scrollbar{height:1px;background-color:var(--border-color)}.tab-btn{border:none;border-bottom:3px solid transparent;color:var(--light-fg);background-color:transparent;white-space:nowrap;cursor:pointer;outline:0;font-family:var(--font-regular);font-size:var(--font-size-small);margin-right:16px;padding:1px}.tab-btn.active{border-bottom:3px solid var(--primary-color);font-weight:700;color:var(--primary-color)}.tab-btn:hover{color:var(--primary-color)}.tab-content{position:relative}`;

// node_modules/openapi-explorer/dist/es/styles/nav-styles.js
var nav_styles_default = css`.nav-bar{width:0;height:100%;overflow:hidden;color:var(--nav-text-color);background-color:var(--nav-bg-color);background-blend-mode:multiply;line-height:calc(var(--font-size-small) + 4px);display:none;position:relative;flex-direction:column;flex-wrap:nowrap;word-break:break-word}.nav-scroll{overflow-x:hidden;overflow-y:auto;overflow-y:overlay;scrollbar-width:thin;scrollbar-color:var(--nav-hover-bg-color) transparent}.nav-bar-tag{display:flex;align-items:center;justify-content:space-between;flex-direction:row}.nav-bar-tag-icon{font-size:16px;padding-right:1px;color:var(--nav-text-color)}.nav-bar-tag-icon:hover{color:var(--nav-hover-text-color)}.nav-bar.focused .nav-bar-tag-and-paths.collapsed .nav-bar-paths-under-tag{display:none}.nav-bar-tag-and-paths.collapsed .nav-bar-tag-icon.collapse-button-arrow{display:none}.nav-bar-tag-and-paths.expanded .nav-bar-tag-icon.expand-button-arrow{display:none}.nav-bar.focused,.nav-scroll{border-top:1px solid var(--secondary-color)}.nav-scroll::-webkit-scrollbar{width:10px}.nav-scroll::-webkit-scrollbar-track{background:0 0}.nav-scroll::-webkit-scrollbar-thumb{background-color:var(--nav-hover-bg-color)}.nav-bar-tag{font-size:var(--font-size-regular);color:var(--secondary-color);border-left:4px solid transparent;font-weight:700;padding:15px 15px 15px 10px}.nav-bar-components,.nav-bar-h1,.nav-bar-h2,.nav-bar-info,.nav-bar-path,.nav-bar-tag,slot[name=nav-section]::slotted(*){display:flex;cursor:pointer;border-left:4px solid transparent}.nav-bar-h1,.nav-bar-h2,.nav-bar-path{font-size:calc(var(--font-size-small) + 1px);padding:var(--nav-item-padding)}.nav-bar-path.small-font{font-size:var(--font-size-small)}.nav-bar-info,slot[name=nav-section]::slotted(*){font-size:var(--font-size-regular);padding:16px 10px;font-weight:700}.nav-bar-section{display:flex;flex-direction:row;justify-content:space-between;font-size:var(--font-size-small);color:var(--nav-text-color);padding:15px 15px 5px 5px;font-weight:700;border-bottom:1px solid var(--nav-text-color);background:var(--nav-bg-color)}.sticky-scroll-element{position:sticky;top:0}.nav-bar-h2{margin-left:12px}.nav-bar-h1.active,.nav-bar-h1.active:hover,.nav-bar-h2.active,.nav-bar-h2.active:hover,.nav-bar-info.active,.nav-bar-info.active:hover,.nav-bar-path.active,.nav-bar-path.active:hover,.nav-bar-tag.active,.nav-bar-tag.active:hover,slot[name=nav-section]::slotted(.active),slot[name=nav-section]::slotted(.active:hover){border-left:4px solid var(--secondary-color);color:var(--secondary-color);background-color:var(--nav-hover-bg-color)}.nav-bar-h1:hover,.nav-bar-h2:hover,.nav-bar-info:hover,.nav-bar-path:hover,.nav-bar-tag:hover,slot[name=nav-section]::slotted(:hover){color:var(--nav-hover-text-color);background-color:var(--nav-hover-bg-color)}`;

// node_modules/openapi-explorer/dist/es/styles/info-styles.js
var info_styles_default = css`#api-info{font-size:calc(var(--font-size-regular) - 1px);margin-top:8px margin-left: -15px}#api-info span:before{content:"|";display:inline-block;opacity:.5;width:15px;text-align:center}#api-info span:first-child:before{content:"";width:0}`;

// node_modules/openapi-explorer/dist/es/styles/advanced-search-styles.js
var advanced_search_styles_default = css`*,:after,:before{box-sizing:border-box}.dialog-box-overlay{background-color:var(--overlay-bg);position:fixed;left:0;top:0;width:100vw;height:100vh;overflow:hidden;z-index:var(--dialog-z-index)}.dialog-box{position:fixed;top:100px;left:50%;transform:translate(-50%,0);display:flex;flex-direction:column;width:50vw;background-color:var(--bg2);color:var(--fg2);border-radius:4px;overflow:hidden;border:1px solid var(--border-color);box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}.dialog-box-header{position:sticky;top:0;align-self:stretch;display:flex;align-items:center;padding:0 16px;min-height:60px;max-height:60px;border-bottom:1px solid var(--light-border-color);overflow:hidden}.dialog-box .m-btn{padding:1px 6px}.dialog-box-content{padding:16px;display:block}.dialog-box-title{flex-grow:1;font-size:20px}.advanced-search-dialog-input{width:100%}#advanced-search-dialog-input{width:100%}.advanced-search-locations{display:flex;flex-direction:column;margin:8px 0 24px}.advanced-search-locations label{font-size:var(--font-size-small)}.advanced-search-results{max-height:400px;overflow:auto}`;

// node_modules/openapi-explorer/dist/es/utils/common-utils.js
var invalidCharsRegEx = new RegExp(/[\s#:?&={}]/, "g");
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function copyToClipboard(data, e) {
  const btnEl = e.currentTarget;
  const textArea = document.createElement("textarea");
  textArea.value = data;
  textArea.style.position = "fixed";
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  try {
    document.execCommand("copy");
    btnEl.innerText = "Copied";
    setTimeout(() => {
      btnEl.innerText = "Copy";
    }, 5e3);
  } catch (err) {
    console.error("Unable to copy", err);
  }
  document.body.removeChild(textArea);
}
function componentIsInSearch(searchVal, component) {
  return component.name.toLowerCase().includes(searchVal.toLowerCase());
}
function pathIsInSearch(searchVal, path) {
  const stringToSearch = `${path.method} ${path.path} ${path.summary || path.description || ""} ${path.operationId || ""}`.toLowerCase();
  return stringToSearch.includes(searchVal.toLowerCase());
}
function schemaKeys(schemaProps, result = /* @__PURE__ */ new Set()) {
  if (!schemaProps) {
    return result;
  }
  Object.keys(schemaProps).forEach((key) => {
    result.add(key);
    if (schemaProps[key].properties) {
      schemaKeys(schemaProps[key].properties, result);
    } else if (schemaProps[key].items && schemaProps[key].items.properties) {
      schemaKeys(schemaProps[key].items.properties, result);
    }
  });
  return result;
}
function advancedSearch(searchVal, allSpecTags, searchOptions = []) {
  if (!searchVal.trim() || searchOptions.length === 0) {
    return void 0;
  }
  const pathsMatched = [];
  allSpecTags.forEach((tag) => {
    tag.paths.forEach((path) => {
      let stringToSearch = "";
      if (searchOptions.includes("search-api-path")) {
        stringToSearch = path.path;
      }
      if (searchOptions.includes("search-api-descr")) {
        stringToSearch = `${stringToSearch} ${path.summary || path.description || ""}`;
      }
      if (searchOptions.includes("search-api-params")) {
        stringToSearch = `${stringToSearch} ${path.parameters && path.parameters.map((v) => v.name).join(" ") || ""}`;
      }
      if (searchOptions.includes("search-api-request-body") && path.requestBody) {
        let schemaKeySet = /* @__PURE__ */ new Set();
        for (const contentType in path.requestBody && path.requestBody.content) {
          if (path.requestBody.content[contentType].schema && path.requestBody.content[contentType].schema.properties) {
            schemaKeySet = schemaKeys(path.requestBody.content[contentType].schema.properties);
          }
          stringToSearch = `${stringToSearch} ${[...schemaKeySet].join(" ")}`;
        }
      }
      if (searchOptions.includes("search-api-resp-descr")) {
        stringToSearch = `${stringToSearch} ${Object.values(path.responses).map((v) => v.description || "").join(" ")}`;
      }
      if (stringToSearch.toLowerCase().includes(searchVal.trim().toLowerCase())) {
        pathsMatched.push({
          elementId: path.elementId,
          method: path.method,
          path: path.path,
          summary: path.summary || path.description || "",
          deprecated: path.deprecated
        });
      }
    });
  });
  return pathsMatched;
}
function getCurrentElement() {
  const currentQuery = (window.location.hash || "").split("?")[1];
  const query = new URLSearchParams(currentQuery);
  return decodeURIComponent(query.get("route") || "");
}
function replaceState(rawElementId) {
  const elementId = rawElementId && rawElementId.replace(/^#/, "") || "";
  const currentNavigationHashPart = (window.location.hash || "").split("?")[0].replace(/^#/, "");
  const currentQuery = (window.location.hash || "").split("?")[1];
  const query = new URLSearchParams(currentQuery);
  query.delete("route");
  const newQuery = query.toString().length > 1 ? `${query.toString()}&route=${elementId}` : `route=${elementId}`;
  window.history.replaceState(null, null, `#${currentNavigationHashPart}?${newQuery}`);
}

// node_modules/openapi-explorer/dist/es/utils/spec-parser.js
var import_openapi_resolver = __toESM(require_openapi_resolver_browser());
async function ProcessSpec(specUrlOrObject, serverUrl = "") {
  const inputSpecIsAUrl = typeof specUrlOrObject === "string" && specUrlOrObject.match(/^http/) || typeof specUrlOrObject === "object" && typeof specUrlOrObject.href === "string";
  let jsonParsedSpec;
  try {
    jsonParsedSpec = await (0, import_openapi_resolver.default)(specUrlOrObject);
  } catch (error) {
    console.error("Error parsing specification", error);
    throw Error("SpecificationNotFound");
  }
  if (!jsonParsedSpec) {
    throw Error("SpecificationNotFound");
  }
  const tags = groupByTags(jsonParsedSpec);
  const components = getComponents(jsonParsedSpec);
  const infoDescriptionHeaders = jsonParsedSpec.info && jsonParsedSpec.info.description ? getHeadersFromMarkdown(jsonParsedSpec.info.description) : [];
  const securitySchemes = [];
  if (jsonParsedSpec.components && jsonParsedSpec.components.securitySchemes) {
    Object.entries(jsonParsedSpec.components.securitySchemes).forEach((kv) => {
      const securityObj = {
        apiKeyId: kv[0],
        ...kv[1]
      };
      securityObj.value = "";
      securityObj.finalKeyValue = "";
      if (kv[1].type === "apiKey" || kv[1].type === "http") {
        securityObj.name = kv[1].name || "Authorization";
        securityObj.user = "";
        securityObj.password = "";
      } else if (kv[1].type === "oauth2") {
        securityObj.name = "Authorization";
        securityObj.clientId = "";
        securityObj.clientSecret = "";
      }
      securitySchemes.push(securityObj);
    });
  }
  securitySchemes.forEach((v) => {
    if (v.type === "http") {
      v.typeDisplay = v.scheme === "basic" ? "HTTP Basic" : "HTTP Bearer";
    } else if (v.type === "apiKey") {
      v.typeDisplay = `API Key (${v.name})`;
    } else if (v.type === "oauth2") {
      v.typeDisplay = "OAuth2.0";
    } else {
      v.typeDisplay = v.type;
    }
  });
  let servers = [];
  if (Array.isArray(jsonParsedSpec.servers) && jsonParsedSpec.servers.length) {
    jsonParsedSpec.servers.forEach((v) => {
      let computedUrl = v.url.trim();
      if (!(computedUrl.startsWith("http") || computedUrl.startsWith("//") || computedUrl.startsWith("{"))) {
        if (window.location.origin.startsWith("http")) {
          v.url = window.location.origin + v.url;
          computedUrl = v.url;
        }
      }
      if (v.variables) {
        Object.entries(v.variables).forEach((kv) => {
          const regex = new RegExp(`{${kv[0]}}`, "g");
          computedUrl = computedUrl.replace(regex, kv[1].default || "");
          kv[1].value = kv[1].default || "";
        });
      }
      v.computedUrl = computedUrl;
    });
    if (serverUrl && !jsonParsedSpec.servers.some((s) => s.url === serverUrl || s.computedUrl === serverUrl)) {
      jsonParsedSpec.servers = [{
        url: serverUrl,
        computedUrl: serverUrl
      }].concat(jsonParsedSpec.servers);
    }
  } else if (serverUrl) {
    jsonParsedSpec.servers = [{
      url: serverUrl,
      computedUrl: serverUrl
    }];
  } else if (inputSpecIsAUrl) {
    jsonParsedSpec.servers = [{
      url: new URL(specUrlOrObject).origin,
      computedUrl: new URL(specUrlOrObject).origin
    }];
  } else if (window.location.origin.startsWith("http")) {
    jsonParsedSpec.servers = [{
      url: window.location.origin,
      computedUrl: window.location.origin
    }];
  } else {
    jsonParsedSpec.servers = [{
      url: "http://localhost",
      computedUrl: "http://localhost"
    }];
  }
  servers = jsonParsedSpec.servers;
  const parsedSpec = {
    info: jsonParsedSpec.info,
    infoDescriptionHeaders,
    tags,
    components,
    externalDocs: jsonParsedSpec.externalDocs,
    securitySchemes,
    servers
  };
  return parsedSpec;
}
function getHeadersFromMarkdown(markdownContent) {
  const tokens = marked.lexer(markdownContent);
  const headers = tokens.filter((v) => v.type === "heading" && v.depth <= 2);
  return headers || [];
}
function getComponents(openApiSpec) {
  if (!openApiSpec.components) {
    return [];
  }
  const components = [];
  for (const component in openApiSpec.components) {
    const subComponents = Object.keys(openApiSpec.components[component]).map((sComponent) => ({
      expanded: true,
      id: `${component.toLowerCase()}-${sComponent.toLowerCase()}`.replace(invalidCharsRegEx, "-"),
      name: sComponent,
      component: openApiSpec.components[component][sComponent]
    })).sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
    let cmpDescription;
    let cmpName;
    switch (component) {
      case "schemas":
        cmpName = "Schemas";
        cmpDescription = "";
        break;
      case "responses":
        cmpName = "Responses";
        cmpDescription = "Describes responses from an API Operation, including design-time, static links to operations based on the response.";
        break;
      case "parameters":
        cmpName = "Parameters";
        cmpDescription = "Describes operation parameters. A unique parameter is defined by a combination of a name and location.";
        break;
      case "examples":
        cmpName = "Examples";
        cmpDescription = "List of Examples for operations, can be requests, responses and objects examples.";
        break;
      case "requestBodies":
        break;
      case "headers":
        cmpName = "Headers";
        cmpDescription = 'Headers follows the structure of the Parameters but they are explicitly in "header"';
        break;
      case "securitySchemes":
        break;
      case "links":
        cmpName = "Links";
        cmpDescription = "Links represent a possible design-time link for a response. The presence of a link does not guarantee the caller's ability to successfully invoke it, rather it provides a known relationship and traversal mechanism between responses and other operations.";
        break;
      case "callbacks":
        cmpName = "Callbacks";
        cmpDescription = "A map of possible out-of band callbacks related to the parent operation. Each value in the map is a Path Item Object that describes a set of requests that may be initiated by the API provider and the expected responses. The key value used to identify the path item object is an expression, evaluated at runtime, that identifies a URL to use for the callback operation.";
        break;
      default:
        cmpName = component;
        cmpDescription = component;
        break;
    }
    if (cmpName) {
      components.push({
        expanded: true,
        name: cmpName,
        description: cmpDescription,
        subComponents
      });
    }
  }
  return components;
}
function groupByTags(openApiSpec) {
  const supportedMethods = ["get", "put", "post", "delete", "patch", "head", "options"];
  const tags = openApiSpec.tags && Array.isArray(openApiSpec.tags) ? openApiSpec.tags.map((t) => ({
    elementId: `tag--${t.name.replace(invalidCharsRegEx, "-")}`,
    name: t.name,
    description: t.description || "",
    headers: t.description ? getHeadersFromMarkdown(t.description) : [],
    paths: [],
    expanded: true
  })) : [];
  const pathsAndWebhooks = openApiSpec.paths || {};
  if (openApiSpec.webhooks) {
    for (const [key, value] of Object.entries(openApiSpec.webhooks)) {
      value._type = "webhook";
      pathsAndWebhooks[key] = value;
    }
  }
  for (const pathOrHookName in pathsAndWebhooks) {
    const commonParams = pathsAndWebhooks[pathOrHookName].parameters;
    const commonPathProp = {
      servers: pathsAndWebhooks[pathOrHookName].servers || [],
      parameters: pathsAndWebhooks[pathOrHookName].parameters || []
    };
    const isWebhook = pathsAndWebhooks[pathOrHookName]._type === "webhook";
    supportedMethods.forEach((methodName) => {
      if (pathsAndWebhooks[pathOrHookName][methodName]) {
        const pathOrHookObj = openApiSpec.paths[pathOrHookName][methodName];
        const pathTags = Array.isArray(pathOrHookObj.tags) ? pathOrHookObj.tags : pathOrHookObj.tags && [pathOrHookObj.tags] || [];
        if (pathTags.length === 0) {
          pathTags.push("General \u2982");
        }
        pathTags.forEach((tag) => {
          let tagObj;
          let specTagsItem;
          if (openApiSpec.tags) {
            specTagsItem = openApiSpec.tags.find((v) => v.name.toLowerCase() === tag.toLowerCase());
          }
          tagObj = tags.find((v) => v.name === tag);
          if (!tagObj) {
            tagObj = {
              elementId: `tag--${tag.replace(invalidCharsRegEx, "-")}`,
              name: tag,
              description: specTagsItem && specTagsItem.description || "",
              headers: specTagsItem && specTagsItem.description ? getHeadersFromMarkdown(specTagsItem.description) : [],
              paths: [],
              expanded: true
            };
            tags.push(tagObj);
          }
          let shortSummary = (pathOrHookObj.summary || pathOrHookObj.description || `${methodName.toUpperCase()} ${pathOrHookName}`).trim();
          if (shortSummary.length > 100) {
            shortSummary = shortSummary.split(/[.|!|?]\s|[\r?\n]/)[0];
          }
          let finalParameters = [];
          if (commonParams) {
            if (pathOrHookObj.parameters) {
              finalParameters = commonParams.filter((commonParam) => {
                if (!pathOrHookObj.parameters.some((param) => commonParam.name === param.name && commonParam.in === param.in)) {
                  return commonParam;
                }
                return void 0;
              }).concat(pathOrHookObj.parameters);
            } else {
              finalParameters = commonParams.slice(0);
            }
          } else {
            finalParameters = pathOrHookObj.parameters ? pathOrHookObj.parameters.slice(0) : [];
          }
          if (pathOrHookObj.callbacks) {
            for (const [callbackName, callbackConfig] of Object.entries(pathOrHookObj.callbacks)) {
              const originalCallbackEntries = Object.entries(callbackConfig);
              const filteredCallbacks = originalCallbackEntries.filter((entry) => typeof entry[1] === "object") || [];
              pathOrHookObj.callbacks[callbackName] = Object.fromEntries(filteredCallbacks);
              if (filteredCallbacks.length !== originalCallbackEntries.length) {
                console.warn(`OpenAPI Explorer: Invalid Callback found in ${callbackName}`);
              }
            }
          }
          tagObj.paths.push({
            expanded: false,
            isWebhook,
            expandedAtLeastOnce: false,
            summary: pathOrHookObj.summary || "",
            description: pathOrHookObj.description || "",
            shortSummary,
            method: methodName,
            path: pathOrHookName,
            operationId: pathOrHookObj.operationId,
            elementId: `${methodName}-${pathOrHookName.replace(invalidCharsRegEx, "-")}`,
            servers: pathOrHookObj.servers ? commonPathProp.servers.concat(pathOrHookObj.servers) : commonPathProp.servers,
            parameters: finalParameters,
            requestBody: pathOrHookObj.requestBody,
            responses: pathOrHookObj.responses,
            callbacks: pathOrHookObj.callbacks,
            deprecated: pathOrHookObj.deprecated,
            security: pathOrHookObj.security || openApiSpec.security,
            xCodeSamples: pathOrHookObj["x-codeSamples"] || pathOrHookObj["x-code-samples"] || ""
          });
        });
      }
    });
  }
  return tags.filter((tag) => tag.paths && tag.paths.length > 0);
}

// node_modules/lit-html/directives/unsafe-html.js
var previousValues = /* @__PURE__ */ new WeakMap();
var unsafeHTML = directive((value) => (part) => {
  if (!(part instanceof NodePart)) {
    throw new Error("unsafeHTML can only be used in text bindings");
  }
  const previousValue = previousValues.get(part);
  if (previousValue !== void 0 && isPrimitive(value) && value === previousValue.value && part.value === previousValue.fragment) {
    return;
  }
  const template = document.createElement("template");
  template.innerHTML = value;
  const fragment = document.importNode(template.content, true);
  part.setValue(fragment);
  previousValues.set(part, { value, fragment });
});

// node_modules/openapi-explorer/dist/es/templates/security-scheme-template.js
var import_base64url = __toESM(require_base64url2());
function onApiKeyChange(apiKeyId, e) {
  let apiKeyValue = "";
  const securityObj = this.resolvedSpec.securitySchemes.find((v) => v.apiKeyId === apiKeyId);
  if (!securityObj) {
    return;
  }
  const trEl = e.target.closest("tr");
  if (securityObj.type && securityObj.type === "http" && securityObj.scheme && securityObj.scheme.toLowerCase() === "basic") {
    const userVal = trEl.querySelector(".api-key-user").value.trim();
    const passwordVal = trEl.querySelector(".api-key-password").value.trim();
    if (passwordVal) {
      apiKeyValue = `Basic ${btoa(`${userVal}:${passwordVal}`)}`;
    }
  } else {
    apiKeyValue = trEl.querySelector(".api-key-input").value.trim();
    if (apiKeyValue) {
      if (securityObj.scheme && securityObj.scheme.toLowerCase() === "bearer") {
        apiKeyValue = `Bearer ${apiKeyValue.replace(/^Bearer\s+/i, "")}`;
      }
    }
  }
  securityObj.finalKeyValue = apiKeyValue;
  this.requestUpdate();
}
function onClearAllApiKeys() {
  this.resolvedSpec.securitySchemes.forEach((v) => {
    v.user = "";
    v.password = "";
    v.value = "";
    v.finalKeyValue = "";
  });
  this.requestUpdate();
}
function updateOAuthKey(apiKeyId, tokenType = "Bearer", accessToken) {
  const securityObj = this.resolvedSpec.securitySchemes.find((v) => v.apiKeyId === apiKeyId);
  const tokenPrefix = tokenType && tokenType.toLowerCase() === "bearer" ? "Bearer" : tokenType;
  securityObj.finalKeyValue = `${tokenPrefix}${tokenPrefix ? " " : ""}${accessToken}`;
  this.requestUpdate();
}
async function fetchAccessToken(tokenUrl, clientId, clientSecret, redirectUrl, grantType, authCode, sendClientSecretIn = "header", apiKeyId, authFlowDivEl, scopes = null) {
  const respDisplayEl = authFlowDivEl ? authFlowDivEl.querySelector(".oauth-resp-display") : void 0;
  const urlFormParams = new URLSearchParams();
  const headers = new Headers();
  urlFormParams.append("grant_type", grantType);
  if (redirectUrl) {
    urlFormParams.append("redirect_uri", redirectUrl);
  }
  if (authCode) {
    urlFormParams.append("code", authCode);
  }
  if (sendClientSecretIn === "header") {
    headers.set("Authorization", `Basic ${btoa(`${clientId}:${clientSecret}`)}`);
  } else {
    urlFormParams.append("client_id", clientId);
    if (clientSecret) {
      urlFormParams.append("client_secret", clientSecret);
    }
  }
  if (scopes) {
    urlFormParams.append("scope", scopes);
  }
  const {
    codeVerifier
  } = JSON.parse(localStorage.getItem("openapi-explorer-oauth") || "{}");
  localStorage.removeItem("openapi-explorer-oauth");
  if (codeVerifier) {
    urlFormParams.append("code_verifier", codeVerifier);
  }
  try {
    const resp = await fetch(tokenUrl, {
      method: "POST",
      headers,
      body: urlFormParams
    });
    const tokenResp = await resp.json();
    if (!resp.ok) {
      if (respDisplayEl) {
        respDisplayEl.innerHTML = `<span style="color:var(--red)">${tokenResp.error_description || tokenResp.error_description || "Unable to get access token"}</span>`;
      }
      return;
    }
    if (tokenResp.token_type && tokenResp.access_token) {
      updateOAuthKey.call(this, apiKeyId, tokenResp.token_type, tokenResp.access_token);
      if (respDisplayEl) {
        respDisplayEl.innerHTML = '<span style="color:var(--green)">Access Token Received</span>';
      }
    }
  } catch (err) {
    if (respDisplayEl) {
      respDisplayEl.innerHTML = '<span style="color:var(--red)">Failed to get access token</span>';
    }
  }
}
function getCookieValue(keyId) {
  const foundCookie = (document.cookie || "").split(";").find((c) => c.split("=")[0] === keyId);
  return foundCookie && foundCookie.split("=")[1] || "";
}
function toObject(urlSearchParams) {
  const result = {};
  const entries = urlSearchParams && urlSearchParams.entries() || [];
  for (const [key, value] of entries) {
    result[key] = value;
  }
  return result;
}
async function checkForAuthToken(redirectToApiLocation) {
  const parameters = toObject(new URLSearchParams(window.location.search));
  const hashQuery = toObject(new URLSearchParams(window.location.hash.slice(1)));
  Object.assign(parameters, hashQuery);
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete("nonce");
  newUrl.searchParams.delete("expires_in");
  newUrl.searchParams.delete("access_token");
  newUrl.searchParams.delete("token_type");
  newUrl.searchParams.delete("id_token");
  newUrl.searchParams.delete("state");
  newUrl.searchParams.delete("code");
  newUrl.searchParams.delete("iss");
  newUrl.searchParams.delete("scope");
  newUrl.searchParams.delete("prompt");
  newUrl.searchParams.delete("hd");
  newUrl.searchParams.delete("authuser");
  newUrl.searchParams.delete("redirect_auth");
  if (!parameters.state) {
    return;
  }
  const sanitizedUrlWithHash = newUrl.toString().replace(/#((code|state|access_token|id_token|authuser|expires_in|hd|prompt|scope|token_type)=[^&]+&?)*$/ig, "");
  history.replaceState({}, void 0, sanitizedUrlWithHash);
  const {
    apiKeyId,
    flowId,
    url
  } = JSON.parse(import_base64url.default.decode(parameters.state));
  if (redirectToApiLocation && url && !parameters.redirect_auth) {
    const apiExplorerLocation = new URL(url);
    Object.keys(parameters).forEach((key) => apiExplorerLocation.searchParams.append(key, parameters[key]));
    apiExplorerLocation.searchParams.append("redirect_auth", true);
    window.location.replace(apiExplorerLocation.toString());
    return;
  }
  if (parameters.code) {
    const securityObj = this.resolvedSpec.securitySchemes.find((v) => v.apiKeyId === apiKeyId);
    const tokenUrl = securityObj && securityObj.flows[flowId] && new URL(securityObj.flows[flowId].tokenUrl || "", this.selectedServer.computedUrl);
    await fetchAccessToken.call(this, tokenUrl, securityObj.clientId, securityObj.clientSecret, securityObj.redirectUri || window.location.href, "authorization_code", parameters.code, null, apiKeyId);
    return;
  }
  updateOAuthKey.call(this, apiKeyId, parameters.token_type, parameters.access_token);
}
async function onInvokeOAuthFlow(apiKeyId, flowType, authUrl, tokenUrl, e) {
  const authFlowDivEl = e.target.closest(".oauth-flow");
  const clientId = authFlowDivEl.querySelector(".oauth-client-id") ? authFlowDivEl.querySelector(".oauth-client-id").value.trim() : "";
  const clientSecret = authFlowDivEl.querySelector(".oauth-client-secret") ? authFlowDivEl.querySelector(".oauth-client-secret").value.trim() : "";
  const sendClientSecretIn = authFlowDivEl.querySelector(".oauth-send-client-secret-in") ? authFlowDivEl.querySelector(".oauth-send-client-secret-in").value.trim() : "header";
  const checkedScopeEls = [...authFlowDivEl.querySelectorAll('input[type="checkbox"]:checked')];
  const securityObj = this.resolvedSpec.securitySchemes.find((v) => v.apiKeyId === apiKeyId);
  let grantType = "";
  let responseType = "";
  const errEls = [...authFlowDivEl.parentNode.querySelectorAll(".oauth-resp-display")];
  errEls.forEach((v) => {
    v.innerHTML = "";
  });
  if (flowType === "authorizationCode" || flowType === "implicit") {
    const authUrlObj = new URL(authUrl);
    const authCodeParams = new URLSearchParams(authUrlObj.search);
    if (flowType === "authorizationCode") {
      const randomBytes = new Uint32Array(3);
      (window.crypto || window.msCrypto).getRandomValues(randomBytes);
      authCodeParams.set("nonce", randomBytes.toString("hex").split(",").join(""));
      grantType = "authorization_code";
      responseType = "code";
      const codeVerifier = randomBytes.toString("hex").split(",").join("");
      const hash = await (window.crypto || window.msCrypto).subtle.digest("SHA-256", new TextEncoder().encode(codeVerifier));
      const codeChallenge = (0, import_base64url.default)(hash);
      authCodeParams.set("code_challenge", codeChallenge);
      authCodeParams.set("code_challenge_method", "S256");
      localStorage.setItem("openapi-explorer-oauth", JSON.stringify({
        codeVerifier
      }));
    } else if (flowType === "implicit") {
      responseType = "token";
    }
    const selectedScopes = checkedScopeEls.map((v) => v.value).join(" ");
    if (selectedScopes) {
      authCodeParams.set("scope", selectedScopes);
    }
    authCodeParams.set("client_id", clientId);
    authCodeParams.set("redirect_uri", securityObj.redirectUri || window.location.href);
    authCodeParams.set("response_type", responseType);
    authCodeParams.set("state", import_base64url.default.encode(JSON.stringify({
      apiKeyId,
      flowId: flowType,
      url: window.location.href
    })));
    authUrlObj.search = authCodeParams.toString();
    window.location.assign(authUrlObj.toString());
  } else if (flowType === "clientCredentials") {
    grantType = "client_credentials";
    const selectedScopes = checkedScopeEls.map((v) => v.value).join(" ");
    fetchAccessToken.call(this, tokenUrl, clientId, clientSecret, "", grantType, "", sendClientSecretIn, apiKeyId, authFlowDivEl, selectedScopes);
  }
}
function oAuthFlowTemplate(flowName, securityObj, authFlow) {
  const apiKeyId = securityObj.apiKeyId;
  const getFullUrl = (url) => url ? new URL(url, this.selectedServer.computedUrl) : void 0;
  const authorizationUrl = getFullUrl(authFlow.authorizationUrl, this.selectedServer.computedUrl);
  const tokenUrl = getFullUrl(authFlow.tokenUrl, this.selectedServer.computedUrl);
  const refreshUrl = getFullUrl(authFlow.refreshUrl, this.selectedServer.computedUrl);
  let flowNameDisplay;
  if (flowName === "authorizationCode") {
    flowNameDisplay = "Authorization Code Flow";
  } else if (flowName === "clientCredentials") {
    flowNameDisplay = "Client Credentials Flow";
  } else if (flowName === "implicit") {
    flowNameDisplay = "Implicit Flow";
  } else {
    flowNameDisplay = flowName;
  }
  return html` <div class="oauth-flow" style="padding:10px 0;margin-bottom:10px"> <div class="tiny-title upper" style="margin-bottom:5px">${flowNameDisplay}</div> ${authorizationUrl ? html`<div><span style="width:75px;display:inline-block">Auth URL</span> <span class="mono-font"> ${authorizationUrl} </span></div>` : ""} ${tokenUrl ? html`<div><span style="width:75px;display:inline-block">Token URL</span> <span class="mono-font">${tokenUrl}</span></div>` : ""} ${refreshUrl ? html`<div><span style="width:75px;display:inline-block">Refresh URL</span> <span class="mono-font">${refreshUrl}</span></div>` : ""} ${flowName === "authorizationCode" || flowName === "clientCredentials" || flowName === "implicit" ? html` ${authFlow.scopes ? html` <span> Scopes </span> <div class="oauth-scopes" part="section-auth-scopes" style="width:100%;display:flex;flex-direction:column;flex-wrap:wrap;margin:0 0 .125rem 0"> ${Object.entries(authFlow.scopes).map((scopeAndDescr, index) => html` <div class="m-checkbox" style="display:inline-flex;align-items:center"> <input type="checkbox" checked="checked" part="checkbox checkbox-auth-scope" id="${flowName}${index}" value="${scopeAndDescr[0]}"> <label for="${flowName}${index}" style="margin-left:5px"> <span class="mono-font">${scopeAndDescr[0]}</span> ${scopeAndDescr[0] !== scopeAndDescr[1] ? ` - ${scopeAndDescr[1] || ""}` : ""} </label> </div> `)} </div> ` : ""} <div style="display:flex"> <input type="text" part="textbox textbox-auth-client-id" value="${securityObj.clientId || ""}" placeholder="Client ID" spellcheck="false" class="oauth-client-id"> ${flowName === "clientCredentials" ? html` <input type="password" part="textbox textbox-auth-client-secret" value="" placeholder="Client Secret" spellcheck="false" class="oauth-client-secret" style="margin:0 5px"> <select aria-label="oauth client secret location" style="margin-right:5px" class="oauth-send-client-secret-in"> <option value="header" selected="selected"> Authorization Header </option> <option value="request-body"> Request Body </option> </select>` : html`<div style="width:5px"></div>`} ${flowName === "authorizationCode" || flowName === "clientCredentials" || flowName === "implicit" ? html` <button class="m-btn thin-border" part="btn btn-outline" @click="${(e) => {
    onInvokeOAuthFlow.call(this, apiKeyId, flowName, authorizationUrl, tokenUrl, e);
  }}">GET TOKEN</button>` : ""} </div> <div class="oauth-resp-display red-text small-font-size"></div> ` : ""} </div> `;
}
function securitySchemeTemplate() {
  const schemes = this.resolvedSpec && this.resolvedSpec.securitySchemes;
  if (!schemes) {
    return void 0;
  }
  const providedApiKeys = schemes.filter((v) => v.finalKeyValue);
  return html` <section id="auth" part="section-auth" class="observe-me ${this.renderStyle === "focused" ? "section-gap--focused-mode" : "section-gap"}"> <slot name="authentication"> <div class="section-padding"> <div class="sub-title regular-font">AUTHENTICATION</div> <div class="small-font-size" style="display:flex;align-items:center;min-height:30px"> ${providedApiKeys.length > 0 ? html` <div class="blue-text"> ${providedApiKeys.length} API key applied </div> <div style="flex:1"></div> <button class="m-btn thin-border" part="btn btn-outline" @click="${() => {
    onClearAllApiKeys.call(this);
  }}">CLEAR ALL API KEYS</button>` : html`<div class="red-text">No API key applied</div>`} </div> ${schemes.length > 0 ? html` <table role="presentation" class="m-table" style="width:100%"> ${schemes.map((v) => html` <tr> <td style="max-width:500px;overflow-wrap:break-word"> <div style="min-height:24px"> <span style="font-weight:700">${v.typeDisplay}</span> ${v.finalKeyValue ? html` <span class="blue-text"> ${v.finalKeyValue ? "Key Applied" : ""} </span> <button class="m-btn thin-border small" part="btn btn-outline" @click="${() => {
    v.finalKeyValue = "";
    this.requestUpdate();
  }}">REMOVE</button> ` : ""} </div> ${v.description ? html` <div class="m-markdown"> ${unsafeHTML(marked(v.description || ""))} </div>` : ""} </td> <td> ${v.type && (v.type.toLowerCase() === "apikey" || v.type.toLowerCase() === "http" && v.scheme && v.scheme.toLowerCase() === "bearer") ? html` ${v.type.toLowerCase() === "apikey" ? html`Send <code>${v.name}</code> in <code>${v.in}</code> with the given value:` : html`Send <code>Authorization</code> in <code>header</code> containing the word <code>Bearer</code> followed by a space and a Token String.`} <div style="display:flex"> ${v.in === "cookie" ? html` <div style="display:block"> <input type="text" value="${getCookieValue(v.apiKeyId)}" disabled="disabled" class="api-key-input" placeholder="IygRVGf54B59e0GAkKmigGfuiVlp/uhFfk2ifA+jMMJzau2F1jPldc09gPTfnMw13BFBxqUZIFDm55DPfwkb0A==" spellcheck="false" style="resize:horizontal;width:100%"> <br> <small> <strong>Cookies</strong>&nbsp;are set and configured by the remote service, therefore it is not possible to configure them from the browser. </small> </div>` : html` <input type="text" value="${v.value}" class="api-key-input" placeholder="api-token" spellcheck="false"> <button class="m-btn thin-border" style="margin-left:5px" part="btn btn-outline" @click="${(e) => {
    onApiKeyChange.call(this, v.apiKeyId, e);
  }}"> ${v.finalKeyValue ? "UPDATE" : "SET"} </button>`} </div>` : ""} ${v.type && v.type.toLowerCase() === "http" && v.scheme && v.scheme.toLowerCase() === "basic" ? html` Send the <code>Authorization</code> header containing the type <code>Basic</code> followed by a space and a base64 encoded string of <code>username:password</code>. <div style="display:flex"> <input type="text" value="${v.user}" placeholder="username" spellcheck="false" class="api-key-user" style="width:100px"> <input type="password" value="${v.password}" placeholder="password" spellcheck="false" class="api-key-password" style="width:100px;margin:0 5px"> <button class="m-btn thin-border" @click="${(e) => {
    onApiKeyChange.call(this, v.apiKeyId, e);
  }}" part="btn btn-outline"> ${v.finalKeyValue ? "UPDATE" : "SET"} </button> </div>` : ""} </td> </tr> ${v.type.toLowerCase() === "oauth2" ? html` <tr> <td colspan="2" style="border:none;padding-left:48px"> ${Object.keys(v.flows).map((f) => oAuthFlowTemplate.call(this, f, v, v.flows[f]))} </td> </tr> ` : ""} `)} </table>` : ""} </div> </slot> </section> `;
}
function getOauthScopeTemplate(scopes) {
  if (!scopes || !scopes.length || !Array.isArray(scopes)) {
    return "";
  }
  return html` <div> <b>Required scopes:</b> <br> <div style="margin-left:8px"> ${scopes.map((scope) => html`<span>${scope}</span>&nbsp;`)} </div> </div>`;
}
function pathSecurityTemplate(pathSecurity) {
  if (this.resolvedSpec.securitySchemes && pathSecurity) {
    const orSecurityKeys1 = [];
    pathSecurity.forEach((pSecurity) => {
      const andSecurityKeys1 = [];
      const andKeyTypes = [];
      Object.keys(pSecurity).forEach((pathSecurityKey) => {
        const s = this.resolvedSpec.securitySchemes.find((ss) => ss.apiKeyId === pathSecurityKey);
        if (s) {
          andKeyTypes.push(s.typeDisplay);
          andSecurityKeys1.push({
            ...s,
            scopes: pSecurity[pathSecurityKey]
          });
        }
      });
      orSecurityKeys1.push({
        securityTypes: andKeyTypes.length > 1 ? `${andKeyTypes[0]} + ${andKeyTypes.length - 1} more` : andKeyTypes[0],
        securityDefs: andSecurityKeys1
      });
    });
    return html`<div class="security-info-button" data-content-id="auth" @click="${(e) => this.scrollToEventTarget(e, false)}"> <div style="position:relative;display:flex;min-width:350px;max-width:700px;justify-content:flex-end"> <svg width="16" height="24" style="cursor:pointer"> <g> <path style="fill:var(--fg3)" d="m13.8,8.5l0,-2.6l0,0c0,-3.2 -2.6,-5.8 -5.8,-5.8s-5.8,2.6 -5.8,5.8l0,0l0,2.6l-2.1,0l0,11.2l16,0l0,-11.2l-2.1,0l-0,0l0,0l0,0l-0,0zm-9.8,-2.6c0,0 0,0 0,0c0,-2.2 1.8,-4 4,-4c2.2,0 4,1.8 4,4c0,0 0,0 0,0l0,2.6l-8.03,0l0,-2.6l0,0l0,0z"/> </g> </svg> ${orSecurityKeys1.map((orSecurityItem1, i) => html` ${i !== 0 ? html`<div style="padding:3px 4px"> OR </div>` : ""} <div class="tooltip" style="cursor:pointer"> <div style="padding:2px 4px;white-space:nowrap;text-overflow:ellipsis;max-width:150px;overflow:hidden"> <span part="anchor anchor-operation-security"> ${orSecurityItem1.securityTypes} </span> </div> <div class="tooltip-text" style="position:absolute;color:var(--fg);top:26px;right:0;border:1px solid var(--border-color);padding:2px 4px;display:block"> ${orSecurityItem1.securityDefs.length > 1 ? html`<div>Requires <b>all</b> of the following </div>` : ""} <div style="padding-left:8px"> ${orSecurityItem1.securityDefs.map((andSecurityItem, j) => html` ${andSecurityItem.type === "oauth2" ? html` <div> ${orSecurityItem1.securityDefs.length > 1 ? html`<b>${j + 1}.</b> &nbsp;` : html`Requires`} OAuth token (${andSecurityItem.apiKeyId}) in <b>Authorization header</b> ${getOauthScopeTemplate(andSecurityItem.scopes)} </div>` : andSecurityItem.type === "http" ? html` <div> ${orSecurityItem1.securityDefs.length > 1 ? html`<b>${j + 1}.</b> &nbsp;` : html`Requires`} ${andSecurityItem.scheme === "basic" ? "Base 64 encoded username:password" : "Bearer Token"} in <b>Authorization header</b> ${getOauthScopeTemplate(andSecurityItem.scopes)} </div>` : html` <div> ${orSecurityItem1.securityDefs.length > 1 ? html`<b>${j + 1}.</b> &nbsp;` : html`Requires`} Token in <b>${andSecurityItem.name} ${andSecurityItem.in}</b> ${getOauthScopeTemplate(andSecurityItem.scopes)} </div>`} `)} </div> </div> </div> `)} </div> </div>`;
  }
  return "";
}

// node_modules/openapi-explorer/dist/es/templates/code-samples-template.js
var import_prismjs = __toESM(require_prism());
function codeSamplesTemplate(xCodeSamples) {
  return html` <section class="table-title top-gap"> CODE SAMPLES  <div class="tab-panel col" @click="${(e) => {
    if (!e.target.classList.contains("tab-btn")) {
      return;
    }
    const clickedTab = e.target.dataset.tab;
    const tabButtons = [...e.currentTarget.querySelectorAll(".tab-btn")];
    const tabContents = [...e.currentTarget.querySelectorAll(".tab-content")];
    tabButtons.forEach((tabBtnEl) => tabBtnEl.classList[tabBtnEl.dataset.tab === clickedTab ? "add" : "remove"]("active"));
    tabContents.forEach((tabBodyEl) => {
      tabBodyEl.style.display = tabBodyEl.dataset.tab === clickedTab ? "block" : "none";
    });
  }}"> <div class="tab-buttons row" style="width:100"> ${xCodeSamples.map((v, i) => html`<button class="tab-btn ${i === 0 ? "active" : ""}" data-tab="${v.lang}${i}"> ${v.label || v.lang} </button>`)} </div> ${xCodeSamples.map((v, i) => html` <div class="tab-content m-markdown code-sample-wrapper" style="display:${i === 0 ? "block" : "none"}" data-tab="${v.lang}${i}"> <button class="toolbar-copy-btn" @click="${(e) => {
    copyToClipboard(v.source, e);
  }}">Copy</button> <pre>
          <code>${import_prismjs.default.languages[v.lang && v.lang.toLowerCase()] ? unsafeHTML(import_prismjs.default.highlight(v.source, import_prismjs.default.languages[v.lang && v.lang.toLowerCase()], v.lang && v.lang.toLowerCase())) : v.source}</code>
        </pre> </div>`)} </div></section>`;
}

// node_modules/openapi-explorer/dist/es/templates/callback-template.js
function callbackTemplate(callbacks) {
  return html` <div class="api-request col regular-font request-panel ${this.renderStyle}-mode"> ${Object.entries(callbacks).map((kv) => html` <div class="${this.renderStyle}-request"> <div class="req-res-title">CALLBACKS</div> <div class="table-title">${kv[0]}</div> ${Object.entries(kv[1]).map((pathObj) => html` <div class="mono-font small-font-size" style="display:flex"> <div style="width:100%"> ${Object.entries(pathObj[1]).map((method) => html` <div> <div style="margin-top:12px"> <div class="method method-fg ${method[0]}" style="width:70px;border:none;margin:0;padding:0;line-height:20px;vertical-align:baseline;text-align:left"> <span style="font-size:20px"> &#x2944; </span> ${method[0]} </div> <span style="line-height:20px;vertical-align:baseline">${pathObj[0]} </span> </div> <div class="expanded-req-resp-container"> <api-request class="request-panel" callback="true" method="${method[0] || ""}" , path="${pathObj[0] || ""}" .parameters="${method[1] && method[1].parameters || ""}" .request_body="${method[1] && method[1].requestBody || ""}" fill-defaults="${this.fillRequestWithDefault}" enable-console="false" render-style="${this.renderStyle}" schema-style="${this.displaySchemaAsTable ? "table" : "tree"}" active-schema-tab="${this.defaultSchemaTab}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="${this.schemaHideReadOnly}" fetch-credentials="${this.fetchCredentials}" exportparts="btn btn-fill btn-outline btn-try"> </api-request> <api-response callback="true" .responses="${method[1] && method[1].responses}" render-style="${this.renderStyle}" schema-style="${this.displaySchemaAsTable ? "table" : "tree"}" active-schema-tab="${this.defaultSchemaTab}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" exportparts="btn--resp btn-fill--resp btn-outline--resp"> </api-response> </div> </div> `)} </div> </div> `)} </div> `)} </div> `;
}

// node_modules/openapi-explorer/dist/es/components/api-request.js
var import_prismjs2 = __toESM(require_prism());

// node_modules/openapi-explorer/dist/es/components/mime-types.js
var import_mime_db = __toESM(require_mime_db());
var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
function extension(type) {
  if (!type || typeof type !== "string") {
    return false;
  }
  const match = EXTRACT_TYPE_REGEXP.exec(type);
  const exts = match && exports.extensions[match[1].toLowerCase()];
  if (!exts || !exts.length) {
    return false;
  }
  return exts[0];
}
var extensions = {};
var types = {};
populateMaps();
function populateMaps() {
  const preference = ["nginx", "apache", void 0, "iana"];
  Object.keys(import_mime_db.default).forEach(function forEachMimeType(type) {
    const mime = import_mime_db.default[type];
    const exts = mime.extensions;
    if (!exts || !exts.length) {
      return;
    }
    extensions[type] = exts;
    for (let i = 0; i < exts.length; i++) {
      const extensionToTest = exts[i];
      if (types[extensionToTest]) {
        const from = preference.indexOf(import_mime_db.default[types[extensionToTest]].source);
        const to = preference.indexOf(mime.source);
        if (types[extensionToTest] !== "application/octet-stream" && (from > to || from === to && types[extensionToTest].substr(0, 12) === "application/")) {
          continue;
        }
      }
      types[extensionToTest] = type;
    }
  });
}

// node_modules/openapi-explorer/dist/es/components/api-request.js
var import_xml_but_prettier = __toESM(require_dist());

// node_modules/openapi-explorer/dist/es/utils/schema-utils.js
var import_lodash = __toESM(require_lodash());
var import_regex_to_strings = __toESM(require_lib());

// node_modules/openapi-explorer/dist/es/utils/xml/xml.js
var XML_CHARACTER_MAP = {
  "&": "&amp;",
  '"': "&quot;",
  "'": "&apos;",
  "<": "&lt;",
  ">": "&gt;"
};
function escapeForXML(string) {
  return string && string.replace ? string.replace(/([&"<>'])/g, function(str, item) {
    return XML_CHARACTER_MAP[item];
  }) : string;
}
var DEFAULT_INDENT = "    ";
function xml(input, rawOptions) {
  let options2 = rawOptions;
  if (typeof options2 !== "object") {
    options2 = {
      indent: options2
    };
  }
  let output = "";
  const indent = !options2.indent ? "" : options2.indent === true ? DEFAULT_INDENT : options2.indent;
  let instant = true;
  function delay(func) {
    if (!instant) {
      func();
    } else {
      process.nextTick(func);
    }
  }
  function append(_, out) {
    if (out !== void 0) {
      output += out;
    }
  }
  function add(value, last) {
    format(append, resolve(value, indent, indent ? 1 : 0), last);
  }
  function addXmlDeclaration(declaration) {
    const encoding = declaration.encoding || "UTF-8";
    const attr = {
      version: "1.0",
      encoding
    };
    if (declaration.standalone) {
      attr.standalone = declaration.standalone;
    }
    add({
      "?xml": {
        _attr: attr
      }
    });
    output = output.replace("/>", "?>");
  }
  delay(function() {
    instant = false;
  });
  if (options2.declaration) {
    addXmlDeclaration(options2.declaration);
  }
  if (input && input.forEach) {
    input.forEach(function(value, i) {
      add(value, i + 1 === input.length);
    });
  } else {
    add(input, true);
  }
  return output;
}
function create_indent(character, count) {
  return new Array(count || 0).join(character || "");
}
function resolve(data, indent, indent_count_raw) {
  const indent_count = indent_count_raw || 0;
  const indent_spaces = create_indent(indent, indent_count);
  let name;
  let values = data;
  const interrupt = false;
  if (typeof data === "object") {
    const keys = Object.keys(data);
    name = keys[0];
    values = data[name];
    if (values && values._elem) {
      values._elem.name = name;
      values._elem.icount = indent_count;
      values._elem.indent = indent;
      values._elem.indents = indent_spaces;
      values._elem.interrupt = values;
      return values._elem;
    }
  }
  const attributes = [];
  const content = [];
  let isStringContent;
  function get_attributes(obj) {
    const keys = Object.keys(obj);
    keys.forEach(function(key) {
      attributes.push(attribute(key, obj[key]));
    });
  }
  switch (typeof values) {
    case "object":
      if (values === null) {
        break;
      }
      if (values._attr) {
        get_attributes(values._attr);
      }
      if (values._cdata) {
        content.push(`${`<![CDATA[${values._cdata}`.replace(/\]\]>/g, "]]]]><![CDATA[>")}]]>`);
      }
      if (values.forEach) {
        isStringContent = false;
        content.push("");
        values.forEach(function(value) {
          if (typeof value === "object") {
            const _name = Object.keys(value)[0];
            if (_name === "_attr") {
              get_attributes(value._attr);
            } else {
              content.push(resolve(value, indent, indent_count + 1));
            }
          } else {
            content.pop();
            isStringContent = true;
            content.push(escapeForXML(value));
          }
        });
        if (!isStringContent) {
          content.push("");
        }
      }
      break;
    default:
      content.push(escapeForXML(values));
  }
  return {
    name,
    interrupt,
    attributes,
    content,
    icount: indent_count,
    indents: indent_spaces,
    indent
  };
}
function format(append, elem, end) {
  if (typeof elem !== "object") {
    append(false, elem);
    return;
  }
  const len = elem.interrupt ? 1 : elem.content.length;
  function proceed() {
    while (elem.content.length) {
      const value = elem.content.shift();
      if (value === void 0) {
        continue;
      }
      if (interrupt(value)) {
        return;
      }
      format(append, value);
    }
    append(false, (len > 1 ? elem.indents : "") + (elem.name ? `</${elem.name}>` : "") + (elem.indent && !end ? "\n" : ""));
  }
  function interrupt(value) {
    if (value.interrupt) {
      value.interrupt.append = append;
      value.interrupt.end = proceed;
      value.interrupt = false;
      append(true);
      return true;
    }
    return false;
  }
  append(false, elem.indents + (elem.name ? `<${elem.name}` : "") + (elem.attributes.length ? ` ${elem.attributes.join(" ")}` : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
  if (!len) {
    append(false, elem.indent ? "\n" : "");
    return;
  }
  if (!interrupt(elem)) {
    proceed();
  }
}
function attribute(key, value) {
  return `${key}="${escapeForXML(value)}"`;
}

// node_modules/openapi-explorer/dist/es/utils/schema-utils.js
var IS_MISSING_TYPE_INFO_TYPE = "";
function getTypeInfo(schema) {
  if (!schema) {
    return void 0;
  }
  let dataType = "";
  let constraint = "";
  if (schema.circularReference) {
    dataType = `{recursive: ${schema.circularReference.name}} `;
  } else if (schema.type) {
    const arraySchema = Array.isArray(schema.type) ? schema.type : typeof schema.type === "string" ? schema.type.split("\u2503") : schema.type;
    dataType = Array.isArray(arraySchema) ? arraySchema.filter((s) => s !== "null").join("\u2503") : schema.type;
    if (schema.format || schema.enum) {
      dataType = dataType.replace("string", schema.enum ? "enum" : schema.format);
    }
  } else {
    dataType = IS_MISSING_TYPE_INFO_TYPE;
  }
  const info = {
    type: dataType,
    format: schema.format || "",
    pattern: schema.pattern && !schema.enum ? schema.pattern : "",
    readOrWriteOnly: schema.readOnly && "\u{1F181}" || schema.writeOnly && "\u{1F186}" || "",
    deprecated: !!schema.deprecated,
    example: Array.isArray(schema.example) ? schema.example : typeof schema.example !== "undefined" ? `${schema.example}` : "",
    default: schema.default || "",
    title: schema.title || "",
    description: schema.description || "",
    constraint: "",
    allowedValues: "",
    arrayType: "",
    html: ""
  };
  info.allowedValues = Array.isArray(schema.enum) ? schema.enum.join("\u2503") : "";
  if (dataType === "array" && schema.items) {
    var _schema$items$default;
    const arrayItemType = schema.items.type;
    const arrayItemDefault = (_schema$items$default = schema.items.default) !== null && _schema$items$default !== void 0 ? _schema$items$default : "";
    info.arrayType = `${schema.type} of ${Array.isArray(arrayItemType) ? arrayItemType.join("") : arrayItemType}`;
    info.default = arrayItemDefault;
    info.allowedValues = Array.isArray(schema.items.enum) ? schema.items.enum.join("\u2503") : "";
  }
  if (dataType.match(/integer|number/g)) {
    var _schema$minimum, _schema$maximum;
    const minimum = (_schema$minimum = schema.minimum) !== null && _schema$minimum !== void 0 ? _schema$minimum : schema.exclusiveMinimum;
    const maximum = (_schema$maximum = schema.maximum) !== null && _schema$maximum !== void 0 ? _schema$maximum : schema.exclusiveMaximum;
    const leftBound = schema.minimum !== void 0 ? "[" : "(";
    const rightBound = schema.maximum !== void 0 ? "]" : ")";
    if (typeof minimum === "number" || typeof maximum === "number") {
      constraint = `Range: ${leftBound}${minimum !== null && minimum !== void 0 ? minimum : ""},${maximum !== null && maximum !== void 0 ? maximum : ""}${rightBound}`;
    }
    if (schema.multipleOf !== void 0) {
      constraint += `${constraint ? ", " : ""}Multiples: ${schema.multipleOf}`;
    }
  }
  if (dataType.match(/string/g)) {
    if (schema.minLength !== void 0 && schema.maxLength !== void 0) {
      constraint += `Min length: ${schema.minLength}, Max length: ${schema.maxLength}`;
    } else if (schema.minLength !== void 0) {
      constraint += `Min length: ${schema.minLength}`;
    } else if (schema.maxLength !== void 0) {
      constraint += `Max length: ${schema.maxLength}`;
    }
  }
  info.constraint = constraint;
  info.html = JSON.stringify({
    type: info.type,
    readOrWriteOnly: info.readOrWriteOnly,
    constraint: info.constraint,
    defaultValue: info.default,
    example: info.example,
    allowedValues: info.allowedValues,
    pattern: info.pattern,
    schemaDescription: info.description,
    schemaTitle: info.title,
    deprecated: info.deprecated
  });
  return info;
}
function getSampleValueByType(schemaObj, fallbackPropertyName, skipExampleStrings) {
  var _schemaObj$type;
  const example = schemaObj.examples ? schemaObj.examples[0] : schemaObj.example;
  if (example === "") {
    return "";
  }
  if (example === null) {
    return null;
  }
  if (example === 0) {
    return 0;
  }
  if (skipExampleStrings && typeof example === "string") {
    return "";
  }
  if (example) {
    return example;
  }
  if (schemaObj.default) {
    return schemaObj.default;
  }
  if (Object.keys(schemaObj).length === 0) {
    return null;
  }
  if (schemaObj.$ref) {
    return schemaObj.$ref;
  }
  const typeValue = Array.isArray(schemaObj.type) ? schemaObj.type.filter((t) => t !== "null")[0] : (_schemaObj$type = schemaObj.type) !== null && _schemaObj$type !== void 0 ? _schemaObj$type : "";
  if (typeValue.match(/^integer|^number/g)) {
    const multipleOf = Number.isNaN(Number(schemaObj.multipleOf)) ? void 0 : Number(schemaObj.multipleOf);
    const maximum = Number.isNaN(Number(schemaObj.maximum)) ? void 0 : Number(schemaObj.maximum);
    const minimumPossibleVal = Number.isNaN(Number(schemaObj.minimum)) ? Number.isNaN(Number(schemaObj.exclusiveMinimum)) ? maximum || 0 : Number(schemaObj.exclusiveMinimum) + (typeValue.startsWith("integer") ? 1 : 1e-3) : Number(schemaObj.minimum);
    const finalVal = multipleOf ? multipleOf >= minimumPossibleVal ? multipleOf : minimumPossibleVal % multipleOf === 0 ? minimumPossibleVal : Math.ceil(minimumPossibleVal / multipleOf) * multipleOf : minimumPossibleVal;
    return finalVal;
  }
  if (typeValue.match(/^boolean/g)) {
    return false;
  }
  if (typeValue.match(/^null/g)) {
    return null;
  }
  if (skipExampleStrings && typeValue.match(/^string/g)) {
    return "";
  }
  if (typeValue.match(/^string/g)) {
    if (schemaObj.enum) {
      return schemaObj.enum[0];
    }
    if (schemaObj.pattern) {
      const examplePattern = schemaObj.pattern.replace(/[+*](?![^\][]*[\]])/g, "{8}").replace(/\{\d*,(\d+)?\}/g, "{8}");
      return (0, import_regex_to_strings.expandN)(examplePattern, 1)[0] || fallbackPropertyName || "string";
    }
    if (schemaObj.format) {
      switch (schemaObj.format.toLowerCase()) {
        case "url":
          return "https://example.com";
        case "uri":
          return "urn:namespace:type:example/resource";
        case "date":
          return new Date().toISOString().split("T")[0];
        case "time":
          return new Date().toISOString().split("T")[1];
        case "date-time":
          return new Date().toISOString();
        case "duration":
          return "P3Y6M4DT12H30M5S";
        case "email":
        case "idn-email":
          return "user@example.com";
        case "hostname":
        case "idn-hostname":
          return "www.example.com";
        case "ipv4":
          return "192.168.0.1";
        case "ipv6":
          return "2001:0db8:5b96:0000:0000:426f:8e17:642a";
        case "uuid":
          return "4e0ba220-9575-11eb-a8b3-0242ac130003";
        default:
          return schemaObj.format;
      }
    } else {
      return fallbackPropertyName || "string";
    }
  }
  return "?";
}
function duplicateExampleWithNewPropertyValues(objectExamples, propertyName, propertyValues) {
  return objectExamples.reduce((exampleList, example) => {
    const examplesFromPropertyValues = propertyValues.slice(0, 2).map((value) => ({
      ...(0, import_lodash.default)(example),
      [propertyName]: value
    }));
    return exampleList.concat(...examplesFromPropertyValues);
  }, []).slice(0, 10);
}
function getExampleValuesFromSchema(schema, config = {}) {
  if (config.xml) {
    const xmlResult = getExampleValuesFromSchemaRecursive(schema.type === "object" ? {
      properties: {
        _root: schema
      }
    } : schema, config);
    return xmlResult.map((example) => example[0]);
  }
  return getExampleValuesFromSchemaRecursive(schema, config);
}
function getExampleValuesFromSchemaRecursive(schema, config = {}) {
  if (!schema) {
    return [];
  }
  const xmlAttributes = {};
  const xmlTagProperties = [];
  const {
    prefix,
    namespace
  } = schema.xml || {};
  if (namespace) {
    xmlAttributes[prefix ? `xmlns:${prefix}` : "xmlns"] = namespace;
  }
  const nodeName = schema.items && schema.items.xml && schema.items.xml.name || schema.xml && schema.xml.name || config.propertyName || "root";
  const overridePropertyName = prefix ? `${prefix}:${nodeName}` : nodeName;
  if (schema.allOf) {
    return getExampleValuesFromSchemaRecursive(schema.allOf[0], config);
  }
  if (schema.oneOf) {
    return schema.oneOf.map((s) => getExampleValuesFromSchemaRecursive(s, config)).flat(1);
  }
  if (schema.anyOf) {
    return schema.anyOf.map((s) => getExampleValuesFromSchemaRecursive(s, config)).flat(1);
  }
  if (schema.type === "array" || schema.items) {
    if (!config.xml) {
      return [getExampleValuesFromSchemaRecursive(schema.items || {}, config)];
    }
    if (!schema.xml || !schema.xml.wrapped) {
      const arrayExamples2 = getExampleValuesFromSchemaRecursive(schema.items || {}, config);
      xmlTagProperties.push({
        [overridePropertyName]: arrayExamples2[0]
      }, {
        _attr: xmlAttributes
      });
      return [xmlTagProperties];
    }
    const arrayExamples = getExampleValuesFromSchemaRecursive(schema.items || {}, {
      ...config,
      propertyName: overridePropertyName
    });
    xmlTagProperties.push({
      [overridePropertyName]: arrayExamples[0]
    }, {
      _attr: xmlAttributes
    });
    return [xmlTagProperties];
  }
  if (schema.type === "object" || schema.properties) {
    let objectExamples = [{}];
    Object.keys(schema.properties || {}).forEach((propertyName) => {
      const innerSchema = schema.properties[propertyName];
      if (innerSchema.deprecated) {
        return;
      }
      if (innerSchema.readOnly && !config.includeReadOnly) {
        return;
      }
      if (innerSchema.writeOnly && !config.includeWriteOnly) {
        return;
      }
      const propertyExamples = getExampleValuesFromSchemaRecursive(innerSchema, {
        ...config,
        propertyName
      });
      objectExamples = duplicateExampleWithNewPropertyValues(objectExamples, propertyName, propertyExamples);
      if (innerSchema.xml && innerSchema.xml.namespace) {
        xmlAttributes[innerSchema.xml.prefix ? `xmlns:${innerSchema.xml.prefix}` : "xmlns"] = namespace;
      }
      const innerNodeName = innerSchema.xml && innerSchema.xml.name || propertyName || config.propertyName;
      const innerOverridePropertyName = prefix ? `${prefix}:${innerNodeName}` : innerNodeName;
      if (innerSchema.xml && innerSchema.xml.attribute) {
        xmlAttributes[innerOverridePropertyName] = propertyExamples[0];
      } else {
        xmlTagProperties.push({
          [innerOverridePropertyName]: propertyExamples[0]
        });
      }
    });
    if (Object.keys(xmlAttributes).length) {
      xmlTagProperties.push({
        _attr: xmlAttributes
      });
    }
    return config.xml ? [xmlTagProperties] : objectExamples;
  }
  const value = getSampleValueByType(schema, config.propertyName, config.skipExampleStrings);
  return [value];
}
function schemaInObjectNotation(schema, obj, level = 0, suffix = "") {
  if (!schema) {
    return void 0;
  }
  if (schema.allOf) {
    const objWithAllProps = {};
    if (schema.allOf.length === 1 && !schema.allOf[0].properties && !schema.allOf[0].items) {
      const tempSchema = schema.allOf[0];
      return `${getTypeInfo(tempSchema).html}`;
    }
    schema.allOf.map((v, i) => {
      if (v.type === "object" || v.properties || v.allOf || v.anyOf || v.oneOf) {
        const propSuffix = (v.anyOf || v.oneOf) && i > 0 ? i : "";
        const partialObj = schemaInObjectNotation(v, {}, level + 1, propSuffix);
        Object.assign(objWithAllProps, partialObj);
      } else if (v.type === "array" || v.items) {
        const partialObj = schemaInObjectNotation(v, {}, level + 1);
        Object.assign(objWithAllProps, partialObj);
      } else if (v.type) {
        const prop = `prop${Object.keys(objWithAllProps).length}`;
        const typeObj = getTypeInfo(v);
        objWithAllProps[prop] = `${typeObj.html}`;
      }
    });
    obj = objWithAllProps;
  } else if (schema.anyOf || schema.oneOf) {
    obj["::description"] = schema.description || "";
    if (schema.type === "object" || schema.properties) {
      obj["::description"] = schema.description || "";
      obj["::flags"] = {
        "\u{1F181}": schema.readOnly && "\u{1F181}",
        "\u{1F186}": schema.writeOnly && "\u{1F186}"
      };
      obj["::type"] = "object";
      for (const key in schema.properties) {
        if (schema.required && schema.required.includes(key)) {
          obj[`${key}*`] = schemaInObjectNotation(schema.properties[key], {}, level + 1);
        } else {
          obj[key] = schemaInObjectNotation(schema.properties[key], {}, level + 1);
        }
      }
    }
    const objWithAnyOfProps = {};
    const xxxOf = schema.anyOf ? "anyOf" : "oneOf";
    schema[xxxOf].forEach((v, index) => {
      if (v.type === "object" || v.properties || v.allOf || v.anyOf || v.oneOf) {
        const partialObj = schemaInObjectNotation(v, {});
        objWithAnyOfProps[`::OPTION~${index + 1}${v.title ? `~${v.title}` : ""}`] = partialObj;
        objWithAnyOfProps["::type"] = "xxx-of-option";
      } else if (v.type === "array" || v.items) {
        const partialObj = schemaInObjectNotation(v, {});
        objWithAnyOfProps[`::OPTION~${index + 1}${v.title ? `~${v.title}` : ""}`] = partialObj;
        objWithAnyOfProps["::type"] = "xxx-of-array";
      } else {
        const prop = `::OPTION~${index + 1}${v.title ? `~${v.title}` : ""}`;
        objWithAnyOfProps[prop] = `${getTypeInfo(v).html}`;
        objWithAnyOfProps["::type"] = "xxx-of-option";
      }
    });
    obj[schema.anyOf ? `::ANY~OF ${suffix}` : `::ONE~OF ${suffix}`] = objWithAnyOfProps;
    obj["::type"] = "xxx-of";
  } else if (Array.isArray(schema.type)) {
    const subSchema = JSON.parse(JSON.stringify(schema));
    const primitiveType = [];
    const complexTypes = [];
    subSchema.type.forEach((v) => {
      if (v.match(/integer|number|string|null|boolean/g)) {
        primitiveType.push(v);
      } else if (v === "array" && typeof (subSchema.items && subSchema.items.type) === "string" && schema.items && subSchema.items.type.match(/integer|number|string|null|boolean/g)) {
        if (subSchema.items.type === "string" && subSchema.items.format) {
          primitiveType.push(`${subSchema.items.format}[]`);
        } else {
          primitiveType.push(`${subSchema.items.type}[]`);
        }
      } else {
        complexTypes.push(v);
      }
    });
    let multiPrimitiveTypes;
    if (primitiveType.length > 0) {
      subSchema.type = primitiveType.join("\u2503");
      multiPrimitiveTypes = getTypeInfo(subSchema);
      if (complexTypes.length === 0) {
        return `${multiPrimitiveTypes && multiPrimitiveTypes.html || ""}`;
      }
    }
    if (complexTypes.length > 0) {
      obj["::type"] = "xxx-of";
      const multiTypeOptions = {
        "::type": "xxx-of-option"
      };
      complexTypes.forEach((v, i) => {
        if (v === "null") {
          multiTypeOptions[`::OPTION~${i + 1}`] = "NULL~|~~|~~|~~|~~|~~|~~|~~|~";
        } else if ("integer, number, string, boolean,".includes(`${v},`)) {
          subSchema.type = Array.isArray(v) ? v.join("\u2503") : v;
          const primitiveTypeInfo = getTypeInfo(subSchema);
          multiTypeOptions[`::OPTION~${i + 1}`] = primitiveTypeInfo.html;
        } else if (v === "object") {
          const objTypeOption = {
            "::title": schema.title || "",
            "::description": schema.description || "",
            "::flags": {
              "\u{1F181}": schema.readOnly && "\u{1F181}",
              "\u{1F186}": schema.writeOnly && "\u{1F186}"
            },
            "::type": "object",
            "::deprecated": schema.deprecated || false
          };
          for (const key in schema.properties) {
            if (schema.required && schema.required.includes(key)) {
              objTypeOption[`${key}*`] = schemaInObjectNotation(schema.properties[key], {}, level + 1);
            } else {
              objTypeOption[key] = schemaInObjectNotation(schema.properties[key], {}, level + 1);
            }
          }
          multiTypeOptions[`::OPTION~${i + 1}`] = objTypeOption;
        } else if (v === "array") {
          multiTypeOptions[`::OPTION~${i + 1}`] = {
            "::title": schema.title || "",
            "::description": schema.description || "",
            "::flags": {
              "\u{1F181}": schema.readOnly && "\u{1F181}",
              "\u{1F186}": schema.writeOnly && "\u{1F186}"
            },
            "::type": "array",
            "::props": schemaInObjectNotation(Object.assign({
              readOnly: schema.readOnly,
              writeOnly: schema.writeOnly
            }, schema.items), {}, level + 1)
          };
        }
      });
      multiTypeOptions[`::OPTION~${complexTypes.length + 1}`] = multiPrimitiveTypes && multiPrimitiveTypes.html || "";
      obj["::ONE~OF"] = multiTypeOptions;
    }
  } else if (schema.type === "object" || schema.properties) {
    obj["::title"] = schema.title || "";
    obj["::description"] = schema.description || "";
    obj["::flags"] = {
      "\u{1F181}": schema.readOnly && "\u{1F181}",
      "\u{1F186}": schema.writeOnly && "\u{1F186}"
    };
    obj["::type"] = "object";
    obj["::deprecated"] = schema.deprecated || false;
    for (const key in schema.properties) {
      if (schema.required && schema.required.includes(key)) {
        obj[`${key}*`] = schemaInObjectNotation(schema.properties[key], {}, level + 1);
      } else {
        obj[key] = schemaInObjectNotation(schema.properties[key], {}, level + 1);
      }
    }
    if (schema.additionalProperties) {
      obj["<any-key>"] = schemaInObjectNotation(schema.additionalProperties, {});
    }
  } else if (schema.type === "array" || schema.items) {
    obj["::title"] = schema.title || "";
    obj["::description"] = schema.description ? schema.description : schema.items && schema.items.description ? `array&lt;${schema.items.description}&gt;` : "";
    obj["::flags"] = {
      "\u{1F181}": schema.readOnly && "\u{1F181}",
      "\u{1F186}": schema.writeOnly && "\u{1F186}"
    };
    obj["::type"] = "array";
    obj["::deprecated"] = schema.deprecated || false;
    obj["::props"] = schemaInObjectNotation(Object.assign({
      deprecated: schema.deprecated,
      readOnly: schema.readOnly,
      writeOnly: schema.writeOnly
    }, schema.items), {}, level + 1);
  } else {
    const typeObj = getTypeInfo(schema);
    if (typeObj && typeObj.html) {
      return `${typeObj.html}`;
    }
    return "";
  }
  return obj;
}
function generateExample(examples, example, schema, rawMimeType, includeReadOnly = true, includeWriteOnly = true, outputType, skipExampleStrings = false) {
  const mimeType = rawMimeType || "application/json";
  const finalExamples = [];
  if (examples) {
    for (const eg in examples) {
      let egContent = "";
      let egFormat = "json";
      if (mimeType.toLowerCase().includes("json")) {
        if (outputType === "text") {
          egContent = typeof examples[eg].value === "string" ? examples[eg].value : JSON.stringify(examples[eg].value, void 0, 2);
          egFormat = "text";
        } else {
          egContent = examples[eg].value;
          if (typeof examples[eg].value === "string") {
            try {
              const fixedJsonString = examples[eg].value.replace(/([\w]+)(:)/g, '"$1"$2').replace(/'/g, '"');
              egContent = JSON.parse(fixedJsonString);
              egFormat = "json";
            } catch (err) {
              egFormat = "text";
              egContent = examples[eg].value;
            }
          }
        }
      } else {
        egContent = examples[eg].value;
        egFormat = "text";
      }
      finalExamples.push({
        exampleId: eg,
        exampleSummary: examples[eg].summary || eg,
        exampleDescription: examples[eg].description || "",
        exampleType: mimeType,
        exampleValue: egContent,
        exampleFormat: egFormat
      });
    }
  } else if (example) {
    let egContent = "";
    let egFormat = "json";
    if (mimeType.toLowerCase().includes("json")) {
      if (outputType === "text") {
        egContent = typeof example === "string" ? example : JSON.stringify(example, void 0, 2);
        egFormat = "text";
      } else if (typeof example === "object") {
        egContent = example;
        egFormat = "json";
      } else if (typeof example === "string") {
        try {
          egContent = JSON.parse(example);
          egFormat = "json";
        } catch (err) {
          egFormat = "text";
          egContent = example;
        }
      }
    } else {
      egContent = example;
      egFormat = "text";
    }
    finalExamples.push({
      exampleId: "Example",
      exampleSummary: "",
      exampleDescription: "",
      exampleType: mimeType,
      exampleValue: egContent,
      exampleFormat: egFormat
    });
  }
  if (finalExamples.length) {
    return finalExamples;
  }
  if (schema && schema.example) {
    return [{
      exampleId: "Example",
      exampleSummary: "",
      exampleDescription: "",
      exampleType: mimeType,
      exampleValue: schema.example,
      exampleFormat: mimeType.toLowerCase().includes("json") && typeof schema.example === "object" ? "json" : "text"
    }];
  }
  const config = {
    includeReadOnly,
    includeWriteOnly,
    skipExampleStrings,
    xml: mimeType.toLowerCase().includes("xml")
  };
  const samples = getExampleValuesFromSchema(schema, config);
  if (!samples || !mimeType.toLowerCase().includes("json") && !mimeType.toLowerCase().includes("text") && !mimeType.toLowerCase().includes("*/*") && !mimeType.toLowerCase().includes("xml")) {
    return [{
      exampleId: "Example",
      exampleSummary: "",
      exampleDescription: "",
      exampleType: mimeType,
      exampleValue: "",
      exampleFormat: "text"
    }];
  }
  return samples.map((sample, sampleCounter) => {
    let exampleValue = "";
    if (mimeType.toLowerCase().includes("xml")) {
      exampleValue = xml(sample, {
        declaration: true,
        indent: "    "
      });
    } else {
      exampleValue = outputType === "text" ? JSON.stringify(sample, null, 8) : sample;
    }
    return {
      exampleId: `Example-${sampleCounter}`,
      exampleSummary: `Example ${sampleCounter + 1}`,
      exampleDescription: "",
      exampleType: mimeType,
      exampleFormat: mimeType.toLowerCase().includes("xml") ? "text" : outputType,
      exampleValue
    };
  }).filter((s) => s);
}

// node_modules/openapi-explorer/dist/es/styles/border-styles.js
var border_styles_default = css`.border-top{border-top:1px solid var(--border-color)}.border{border:1px solid var(--border-color);border-radius:var(--border-radius)}.light-border{border:1px solid var(--light-border-color);border-radius:var(--border-radius)}.pad-8-16{padding:8px 16px}.pad-top-8{padding-top:8px}.mar-top-8{margin-top:8px}`;

// node_modules/openapi-explorer/dist/es/components/json-tree.js
var JsonTree = class extends LitElement {
  static get properties() {
    return {
      data: {
        type: Object
      },
      renderStyle: {
        type: String,
        attribute: "render-style"
      }
    };
  }
  static get styles() {
    return [font_styles_default, border_styles_default, input_styles_default, css`:host{display:flex}.json-tree{background:#333;color:#fff;padding:12px;min-height:30px;font-family:var(--font-mono);font-size:var(--font-size-small);overflow:hidden;word-break:break-all;flex:1;line-height:calc(var(--font-size-small) + 6px)}.open-bracket{display:inline-block;padding:0 20px 0 0;cursor:pointer;border:1px solid transparent;border-radius:3px}.collapsed.open-bracket{padding-right:0}.tree>.open-bracket{margin-left:-2px}.open-bracket:hover{color:var(--primary-color);background-color:var(--hover-color);border:1px solid var(--border-color)}.inside-bracket{padding-left:16px;border-left:1px dotted var(--border-color)}.open-bracket.collapsed+.inside-bracket,.open-bracket.collapsed+.inside-bracket+.close-bracket{display:none}.close-bracket{margin-left:-2px}.string{color:var(--green)}.number{color:var(--blue)}.null{color:var(--red)}.boolean{color:var(--orange)}.object{color:#fff}.toolbar{display:none}.tree .toolbar{display:flex;justify-content:space-between;width:100%}.tree .item{border-bottom:1px dotted transparent}.toolbar-item{cursor:pointer;padding:5px 0 5px 1rem;margin:0 1rem!important;color:#38b3f9;flex-shrink:0}.tree .toolbar .toolbar-item{display:none}.inside-bracket.xxx-of{padding:5px 0;border-style:dotted;border-width:0 0 1px 0;border-color:var(--primary-color)}.schema-root-type.xxx-of{display:none}.toolbar-item:first-of-type{margin:0 2px 0 0}@media only screen and (min-width:576px){.key-descr{display:block}.tree .toolbar .toolbar-item{display:block}.toolbar{display:flex}}.toolbar-backup{position:absolute;right:6px;display:flex;align-items:center}`];
  }
  render() {
    return html` <div class="json-tree tree"> <div class="toolbar"> <div>&nbsp;</div> <div class="toolbar-item"> <button class="toolbar-copy-btn" part="btn btn-fill" @click="${(e) => {
      copyToClipboard(JSON.stringify(this.data, null, 2), e);
    }}">Copy</button> </div> </div> ${this.generateTree(this.data, true)} </div> `;
  }
  generateTree(data, isLast = false) {
    if (data === null) {
      return html`<div class="null" style="display:inline">null</div>`;
    }
    if (typeof data === "object" && data instanceof Date === false) {
      const detailType = Array.isArray(data) ? "array" : "pure_object";
      if (Object.keys(data).length === 0) {
        return html`${Array.isArray(data) ? "[ ]," : "{ },"}`;
      }
      return html` <div class="open-bracket expanded ${detailType === "array" ? "array" : "object"}" @click="${this.toggleExpand}"> ${detailType === "array" ? "[" : "{"}</div> <div class="inside-bracket"> ${Object.keys(data).map((key, i, a) => html` <div class="item"> ${detailType === "pure_object" ? html`"${key}":` : ""} ${this.generateTree(data[key], i === a.length - 1)} </div>`)} </div> <div class="close-bracket">${detailType === "array" ? "]" : "}"}${isLast ? "" : ","}</div> `;
    }
    return typeof data === "string" || data instanceof Date ? html`<span class="${typeof data}">"${data}"</span>${isLast ? "" : ","}` : html`<span class="${typeof data}">${data}</span>${isLast ? "" : ","}`;
  }
  toggleExpand(e) {
    const openBracketEl = e.target;
    if (openBracketEl.classList.contains("expanded")) {
      openBracketEl.classList.replace("expanded", "collapsed");
      e.target.innerHTML = e.target.classList.contains("array") ? "[...]" : "{...}";
    } else {
      openBracketEl.classList.replace("collapsed", "expanded");
      e.target.innerHTML = e.target.classList.contains("array") ? "[" : "{";
    }
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("json-tree", JsonTree);
}

// node_modules/openapi-explorer/dist/es/styles/schema-styles.js
var schema_styles_default = css`*,:after,:before{box-sizing:border-box}.tr{display:flex;flex:none;width:100%;box-sizing:content-box;border-bottom:1px dotted transparent}.td{display:block;flex:0 0 auto}.key{font-family:var(--font-mono);white-space:normal;word-break:break-all}.key-descr{font-family:var(--font-regular);flex-shrink:1;text-overflow:ellipsis;overflow:hidden;display:none;max-height:auto}.toolbar{display:none}.tr.xxx-of{border-top:1px dotted var(--primary-color)}.xxx-of-key{font-size:calc(var(--font-size-small) - 2px);font-weight:700;background-color:var(--primary-color);color:var(--primary-btn-text-color);border-radius:2px;line-height:calc(var(--font-size-small) + 6px);padding:0 5px;margin-bottom:1px;display:inline-block}.xxx-of-descr{font-family:var(--font-regular);color:var(--primary-color);font-size:calc(var(--font-size-small) - 1px);margin-left:2px}.bina,.byte,.date,.emai,.host,.ipv4,.pass,.stri,.string,.uri,.url,.uuid{color:var(--green)}.deci .blue,.doub,.floa,.int3,.int6,.inte,.numb,.number{color:var(--blue)}.null{color:var(--red)}.bool,.boolean{color:var(--orange)}.enum{color:var(--yellow)}.tree .toolbar{display:flex;justify-content:space-between}.toolbar{width:100%}.toolbar-item{cursor:pointer;padding:5px 0 5px 1rem;margin:0 1rem!important;color:#38b3f9;flex-shrink:0}.tree .toolbar .toolbar-item{display:none}.schema-root-type{cursor:auto;color:var(--fg2);font-weight:700;text-transform:uppercase}.schema-root-type.xxx-of{display:none}.toolbar-item:first-of-type{margin:0 2px 0 0}@media only screen and (min-width:576px){.key-descr{display:block}.tree .toolbar .toolbar-item{display:block}.toolbar{display:flex}}`;

// node_modules/openapi-explorer/dist/es/components/schema-tree.js
var SchemaTree = class extends LitElement {
  static get properties() {
    return {
      data: {
        type: Object
      },
      schemaExpandLevel: {
        type: Number,
        attribute: "schema-expand-level"
      },
      schemaDescriptionExpanded: {
        type: String,
        attribute: "schema-description-expanded"
      },
      schemaHideReadOnly: {
        type: String,
        attribute: "schema-hide-read-only"
      },
      schemaHideWriteOnly: {
        type: String,
        attribute: "schema-hide-write-only"
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.schemaExpandLevel || this.schemaExpandLevel < 1) {
      this.schemaExpandLevel = 99999;
    }
    if (!this.schemaDescriptionExpanded || !"true false".includes(this.schemaDescriptionExpanded)) {
      this.schemaDescriptionExpanded = "true";
    }
    if (!this.schemaHideReadOnly || !"true false".includes(this.schemaHideReadOnly)) {
      this.schemaHideReadOnly = "true";
    }
    if (!this.schemaHideWriteOnly || !"true false".includes(this.schemaHideWriteOnly)) {
      this.schemaHideWriteOnly = "true";
    }
  }
  static get styles() {
    return [font_styles_default, schema_styles_default, border_styles_default, css`.tree{min-height:30px;background:#333;padding:12px;color:#fff;font-size:var(--font-size-small);text-align:left;line-height:calc(var(--font-size-small) + 6px)}.tree .key{max-width:300px}.key.deprecated .key-label{text-decoration:line-through}.open-bracket{display:inline-block;padding:0 20px 0 0;cursor:pointer;border:1px solid transparent;border-radius:3px}.collapsed .open-bracket{padding-right:0}.td.key>.open-bracket:first-child{margin-left:-2px}.open-bracket:hover{color:var(--primary-color);background-color:var(--hover-color);border:1px solid var(--border-color)}.close-bracket{display:inline-block;font-family:var(--font-mono);margin-left:-2px}.tr.collapsed .close-bracket{margin-left:0}.tr.collapsed+.inside-bracket,.tr.collapsed+.inside-bracket+.close-bracket{display:none}.inside-bracket.array,.inside-bracket.object{border-left:1px dotted var(--border-color)}.inside-bracket.xxx-of{padding:5px 0;border-style:dotted;border-width:0 0 1px 0;border-color:var(--primary-color)}`];
  }
  render() {
    return html` <div class="tree"> <div class="toolbar"> ${this.data && this.data["::description"] ? html`<span class="m-markdown" style="margin-block-start:0"> ${unsafeHTML(marked(this.data["::description"] || ""))}</span>` : html`<div>&nbsp;</div>`} <div class="toolbar-item" @click="${() => this.toggleSchemaDescription()}"> ${this.schemaDescriptionExpanded === "true" ? "Collapse descriptions" : "Expand descriptions"} </div> </div> ${this.data ? html`${this.generateTree(this.data["::type"] === "array" ? this.data["::props"] : this.data, this.data["::type"])}` : html`<span class="mono-font" style="color:var(--red)"> Schema not found </span>`} </div> `;
  }
  toggleSchemaDescription() {
    this.schemaDescriptionExpanded = !this.schemaDescriptionExpanded;
    this.requestUpdate();
  }
  generateTree(data, dataType = "object", key = "", description = "", schemaLevel = 0, indentLevel = 0) {
    if (!data) {
      return html`<div class="null" style="display:inline">null</div>`;
    }
    if (Object.keys(data).length === 0) {
      return html`<span class="key object">${key}:{ }</span>`;
    }
    let keyLabel = "";
    let keyDescr = "";
    if (key.startsWith("::ONE~OF") || key.startsWith("::ANY~OF")) {
      keyLabel = key.replace("::", "").replace("~", " ");
    } else if (key.startsWith("::OPTION")) {
      const parts2 = key.split("~");
      keyLabel = parts2[1];
      keyDescr = parts2[2];
    } else {
      keyLabel = key;
    }
    const leftPadding = 16;
    const minFieldColWidth = 250 - indentLevel * leftPadding;
    let openBracket = "";
    let closeBracket = "";
    const newSchemaLevel = data["::type"] && data["::type"].startsWith("xxx-of") ? schemaLevel : schemaLevel + 1;
    const newIndentLevel = dataType === "xxx-of-option" || data["::type"] === "xxx-of-option" || key.startsWith("::OPTION") ? indentLevel : indentLevel + 1;
    if (data["::type"] === "object") {
      if (dataType === "array") {
        if (schemaLevel < this.schemaExpandLevel) {
          openBracket = html`<span class="open-bracket array-of-object" @click="${this.toggleObjectExpand}">[{</span>`;
        } else {
          openBracket = html`<span class="open-bracket array-of-object" @click="${this.toggleObjectExpand}">[{...}]</span>`;
        }
        closeBracket = "}]";
      } else {
        if (schemaLevel < this.schemaExpandLevel) {
          openBracket = html`<span class="open-bracket object" @click="${this.toggleObjectExpand}">{</span>`;
        } else {
          openBracket = html`<span class="open-bracket object" @click="${this.toggleObjectExpand}">{...}</span>`;
        }
        closeBracket = "}";
      }
    } else if (data["::type"] === "array") {
      if (dataType === "array") {
        if (schemaLevel < this.schemaExpandLevel) {
          openBracket = html`<span class="open-bracket array-of-array" @click="${this.toggleObjectExpand}">[[</span>`;
        } else {
          openBracket = html`<span class="open-bracket array-of-array" @click="${this.toggleObjectExpand}">[[...]]</span>`;
        }
        closeBracket = "]]";
      } else {
        if (schemaLevel < this.schemaExpandLevel) {
          openBracket = html`<span class="open-bracket array" @click="${this.toggleObjectExpand}">[</span>`;
        } else {
          openBracket = html`<span class="open-bracket array" @click="${this.toggleObjectExpand}">[...]</span>`;
        }
        closeBracket = "]";
      }
    }
    if (typeof data === "object") {
      const flags = data["::flags"] || {};
      if (flags["\u{1F181}"] && this.schemaHideReadOnly === "true") {
        return void 0;
      }
      if (flags["\u{1F186}"] && this.schemaHideWriteOnly === "true") {
        return void 0;
      }
      const displayLine = [flags["\u{1F181}"] || flags["\u{1F186}"], description].filter((v) => v).join(" ");
      return html` <div class="tr ${schemaLevel < this.schemaExpandLevel || data["::type"] && data["::type"].startsWith("xxx-of") ? "expanded" : "collapsed"} ${data["::type"] || "no-type-info"}"> <div class="td key ${data["::deprecated"] ? "deprecated" : ""}" style="min-width:${minFieldColWidth}px"> ${data["::type"] === "xxx-of-option" || data["::type"] === "xxx-of-array" || key.startsWith("::OPTION") ? html`<span class="key-label xxx-of-key">${keyLabel}</span><span class="xxx-of-descr">${keyDescr}</span>` : keyLabel.endsWith("*") ? html`<span class="key-label">${keyLabel.substring(0, keyLabel.length - 1)}</span><span style="color:var(--red)">*</span>:` : keyLabel === "::props" || keyLabel === "::ARRAY~OF" ? "" : schemaLevel > 0 ? html`<span class="key-label">${keyLabel}:</span>` : ""} ${data["::type"] === "xxx-of" && dataType === "array" ? html`<span style="color:var(--primary-color)">ARRAY</span>` : ""} ${openBracket} </div> <div class="td key-descr"> <span class="m-markdown-small" style="font-family:var(--font-mono);vertical-align:middle" title="${flags["\u{1F181}"] && "Read only attribute" || flags["\u{1F186}"] && "Write only attribute" || ""}"> ${unsafeHTML(marked(displayLine))} </span> </div> </div> <div class="inside-bracket ${data["::type"] || "no-type-info"}" style="padding-left:${data["::type"] === "xxx-of-option" || data["::type"] === "xxx-of-array" ? 0 : leftPadding}px"> ${Array.isArray(data) && data[0] ? html`${this.generateTree(data[0], "xxx-of-option", "::ARRAY~OF", "", newSchemaLevel, newIndentLevel)}` : html` ${Object.keys(data).map((dataKey) => dataKey.startsWith("::") && data[dataKey]["::type"] !== "array" && data[dataKey]["::type"] !== "object" ? "" : html`${this.generateTree(data[dataKey]["::type"] === "array" ? data[dataKey]["::props"] : data[dataKey], data[dataKey]["::type"], dataKey, data[dataKey]["::description"], newSchemaLevel, newIndentLevel)}`)}`} </div> ${data["::type"] && data["::type"].includes("xxx-of") ? "" : html`<div class="close-bracket"> ${closeBracket} </div>`} `;
    }
    const {
      type,
      readOrWriteOnly,
      constraint,
      defaultValue,
      example,
      allowedValues,
      pattern,
      schemaDescription,
      schemaTitle,
      deprecated
    } = JSON.parse(data);
    if (readOrWriteOnly === "\u{1F181}" && this.schemaHideReadOnly === "true") {
      return void 0;
    }
    if (readOrWriteOnly === "\u{1F186}" && this.schemaHideWriteOnly === "true") {
      return void 0;
    }
    const dataTypeCss = type.replace(/┃.*/g, "").replace(/[^a-zA-Z0-9+]/g, "").substring(0, 4).toLowerCase();
    return html` <div class="tr primitive"> <div class="td key ${deprecated ? "deprecated" : ""}" style="min-width:${minFieldColWidth}px"> ${keyLabel.endsWith("*") ? html`<span class="key-label">${keyLabel.substring(0, keyLabel.length - 1)}</span><span style="color:var(--red)">*</span>:` : key.startsWith("::OPTION") ? html`<span class="key-label xxx-of-key">${keyLabel}</span><span class="xxx-of-descr">${keyDescr}</span>` : schemaLevel > 0 ? html`<span class="key-label">${keyLabel}:</span>` : ""} <span class="${dataTypeCss}"> ${dataType === "array" ? `${type}[]` : `${type}`} </span> </div> <div class="td key-descr"> <span class="m-markdown-small" style="font-family:var(--font-mono);vertical-align:middle" title="${readOrWriteOnly === "\u{1F181}" && "Read only attribute" || readOrWriteOnly === "\u{1F186}" && "Write only attribute" || ""}"> ${unsafeHTML(marked(`${readOrWriteOnly && `${readOrWriteOnly} ` || ""}${dataType === "array" && description || `${schemaTitle ? `**${schemaTitle}:**` : ""} ${schemaDescription}` || ""}`))} </span> ${this.schemaDescriptionExpanded ? html` ${constraint ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Constraints: </span>${constraint}</div><br>` : ""} ${defaultValue ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Default: </span>${defaultValue}</div><br>` : ""} ${allowedValues ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Allowed: </span>${allowedValues}</div><br>` : ""} ${pattern ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Pattern: </span>${pattern}</div><br>` : ""} ${example ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Example: </span>${example}</div><br>` : ""}` : ""} </div> </div> `;
  }
  toggleObjectExpand(e) {
    const rowEl = e.target.closest(".tr");
    if (rowEl.classList.contains("expanded")) {
      rowEl.classList.replace("expanded", "collapsed");
      e.target.innerHTML = e.target.classList.contains("array-of-object") ? "[{...}]" : e.target.classList.contains("array-of-array") ? "[[...]]" : e.target.classList.contains("array") ? "[...]" : "{...}";
    } else {
      rowEl.classList.replace("collapsed", "expanded");
      e.target.innerHTML = e.target.classList.contains("array-of-object") ? "[{" : e.target.classList.contains("array-of-array") ? "[[" : e.target.classList.contains("object") ? "{" : "[";
    }
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("schema-tree", SchemaTree);
}

// node_modules/openapi-explorer/dist/es/components/tag-input.js
var TagInput = class extends LitElement {
  render() {
    const tagItemTemplate = html`${(this.value || []).filter((v) => v.trim()).map((v) => html`<span class="tag">${v}</span>`)}`;
    return html` <div class="tags" tabindex="0"> ${tagItemTemplate} <input type="text" class="editor" @paste="${(e) => this.afterPaste(e)}" @keydown="${this.afterKeyDown}" placeholder="${this.placeholder || ""}"> </div> `;
  }
  static get properties() {
    return {
      placeholder: {
        type: String
      },
      value: {
        type: Array,
        attribute: "value"
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!Array.isArray(this.value)) {
      this.value = this.value !== "" ? [this.value] : [];
    }
  }
  attributeChangedCallback(name, oldVal, newVal) {
    if (name === "value") {
      if (newVal && oldVal !== newVal) {
        this.value = newVal.split(",").filter((v) => v.trim());
      }
    }
    super.attributeChangedCallback(name, oldVal, newVal);
  }
  afterPaste(e) {
    const clipboardData = e.clipboardData || window.clipboardData;
    const pastedData = clipboardData.getData("Text");
    const pastedArray = pastedData && pastedData.split(",").filter((v) => v.trim()) || [];
    this.value = this.value.concat(pastedArray);
    e.preventDefault();
  }
  afterKeyDown(e) {
    if (e.keyCode === 13) {
      e.stopPropagation();
      e.preventDefault();
      this.value = this.value.concat(e.target.value || []);
      e.target.value = "";
    } else if (e.keyCode === 8) {
      if (e.target.value.length === 0) {
        this.value = this.value.slice(0, -1);
      }
    }
  }
  static get styles() {
    return [css`.tags{display:flex;flex-wrap:wrap;outline:0;padding:0;border-radius:var(--border-radius);border:1px solid var(--border-color);cursor:text;overflow:hidden;background:var(--input-bg)}.editor,.tag{padding:3px;margin:2px}.tag{border:1px solid var(--border-color);background-color:var(--bg3);color:var(--fg3);border-radius:var(--border-radius);word-break:break-all;font-size:var(--font-size-small)}.tag:hover~#cursor{display:block}.editor{flex:1;border:1px solid transparent;color:var(--fg);min-width:60px;outline:0;line-height:inherit;font-family:inherit;background:0 0;font-size:calc(var(--font-size-small) + 1px)}.editor::placeholder{color:var(--placeholder-color);opacity:1}`];
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("tag-input", TagInput);
}

// node_modules/openapi-explorer/dist/es/components/api-request.js
var textFileRegex = RegExp("^font/|tar$|zip$|7z$|rtf$|msword$|excel$|/pdf$|/octet-stream$|^application/vnd.");
var mediaFileRegex = RegExp("^audio/|^image/|^video/");
var truncateString = (str, length) => str && str.length > length ? `${str.substring(0, length - 1)}\u2026` : str;
var ApiRequest = class extends LitElement {
  createRenderRoot() {
    return this;
  }
  constructor() {
    super();
    this.responseMessage = "";
    this.responseStatus = "";
    this.responseHeaders = "";
    this.responseText = "";
    this.responseUrl = "";
    this.responseElapsedMs = 0;
    this.curlSyntax = "";
    this.activeResponseTab = "response";
    this.selectedRequestBodyType = "";
    this.selectedRequestBodyExample = "";
  }
  static get properties() {
    return {
      serverUrl: {
        type: String,
        attribute: "server-url"
      },
      servers: {
        type: Array
      },
      method: {
        type: String
      },
      path: {
        type: String
      },
      parameters: {
        type: Array
      },
      request_body: {
        type: Object
      },
      api_keys: {
        type: Array
      },
      parser: {
        type: Object
      },
      accept: {
        type: String
      },
      callback: {
        type: String
      },
      responseMessage: {
        type: String,
        attribute: false
      },
      responseText: {
        type: String,
        attribute: false
      },
      responseHeaders: {
        type: String,
        attribute: false
      },
      responseStatus: {
        type: String,
        attribute: false
      },
      responseUrl: {
        type: String,
        attribute: false
      },
      responseElapsedMs: {
        type: Number,
        attribute: false
      },
      fillRequestWithDefault: {
        type: String,
        attribute: "fill-defaults"
      },
      allowTry: {
        type: String,
        attribute: "enable-console"
      },
      renderStyle: {
        type: String,
        attribute: "render-style"
      },
      schemaStyle: {
        type: String,
        attribute: "schema-style"
      },
      activeSchemaTab: {
        type: String,
        attribute: "active-schema-tab"
      },
      schemaExpandLevel: {
        type: Number,
        attribute: "schema-expand-level"
      },
      schemaDescriptionExpanded: {
        type: String,
        attribute: "schema-description-expanded"
      },
      schemaHideReadOnly: {
        type: String,
        attribute: "schema-hide-read-only"
      },
      fetchCredentials: {
        type: String,
        attribute: "fetch-credentials"
      },
      activeResponseTab: {
        type: String
      },
      selectedRequestBodyType: {
        type: String,
        attribute: "selected-request-body-type"
      },
      selectedRequestBodyExample: {
        type: String,
        attribute: "selected-request-body-example"
      }
    };
  }
  render() {
    return html` <div class="api-request col regular-font request-panel ${this.renderStyle === "focused" || this.callback === "true" ? "focused-mode" : "view-mode"}"> <div class="${this.callback === "true" ? "tiny-title" : "req-res-title"}"> ${this.callback === "true" ? "CALLBACK REQUEST" : "REQUEST"} </div> <div> ${this.inputParametersTemplate("path")} ${this.inputParametersTemplate("query")} ${this.requestBodyTemplate()} ${this.inputParametersTemplate("header")} ${this.inputParametersTemplate("cookie")} ${this.allowTry === "false" ? "" : html`${this.apiCallTemplate()}`} </div> </div> `;
  }
  updated(changedProperties) {
    if (this.renderStyle !== "focused") {
      return;
    }
    if (changedProperties.size === 1 && changedProperties.has("activeSchemaTab")) {
      return;
    }
    const exampleTextAreaEls = [...this.querySelectorAll('textarea[data-ptype="form-data"]')];
    exampleTextAreaEls.forEach((el) => {
      const origExampleEl = this.querySelector(`textarea[data-pname='hidden-${el.dataset.pname}']`);
      if (origExampleEl) {
        el.value = origExampleEl.value;
      }
    });
  }
  inputParametersTemplate(paramType) {
    const filteredParams = this.parameters ? this.parameters.filter((param) => param.in === paramType) : [];
    if (filteredParams.length === 0) {
      return "";
    }
    let title = "";
    if (paramType === "path") {
      title = "PATH PARAMETERS";
    } else if (paramType === "query") {
      title = "QUERY-STRING PARAMETERS";
    } else if (paramType === "header") {
      title = "REQUEST HEADERS";
    } else if (paramType === "cookie") {
      title = "COOKIES";
    }
    const tableRows = [];
    for (const param of filteredParams) {
      if (!param.schema) {
        continue;
      }
      const paramSchema = getTypeInfo(param.schema);
      if (!paramSchema) {
        continue;
      }
      const defaultVal = Array.isArray(paramSchema.default) ? paramSchema.default : `${paramSchema.default}`;
      let paramStyle = "form";
      let paramExplode = true;
      if (paramType === "query") {
        if (param.style && "form spaceDelimited pipeDelimited".includes(param.style)) {
          paramStyle = param.style;
        }
        if (typeof param.explode === "boolean") {
          paramExplode = param.explode;
        }
      }
      tableRows.push(html` <tr> <td style="width:160px;min-width:50px"> <div class="param-name ${paramSchema.deprecated ? "deprecated" : ""}"> ${param.name}${!paramSchema.deprecated && param.required ? html`<span style="color:var(--red)">*</span>` : ""} </div> <div class="param-type"> ${paramSchema.type === "array" ? `${paramSchema.arrayType}` : `${paramSchema.format ? paramSchema.format : paramSchema.type}`}${!paramSchema.deprecated && param.required ? html`<span style="opacity:0">*</span>` : ""} </div> </td> ${this.allowTry === "true" ? html` <td style="min-width:160px"> ${paramSchema.type === "array" ? html` <tag-input class="request-param" style="width:100%" data-ptype="${paramType}" data-pname="${param.name}" data-default="${Array.isArray(defaultVal) ? defaultVal.join("~|~") : defaultVal}" data-param-serialize-style="${paramStyle}" data-param-serialize-explode="${paramExplode}" data-array="true" placeholder="${paramSchema.example || (Array.isArray(defaultVal) ? defaultVal[0] : defaultVal) || "add-multiple &#x21a9;"}" .value="${Array.isArray(defaultVal) ? defaultVal : defaultVal.split(",")}"> </tag-input>` : paramSchema.type === "object" ? html` <textarea class="textarea request-param" part="textarea textarea-param" data-ptype="${paramType}-object" data-pname="${param.name}" data-default="${defaultVal}" data-param-serialize-style="${paramStyle}" data-param-serialize-explode="${paramExplode}" spellcheck="false" placeholder="${paramSchema.example || defaultVal || ""}" style="resize:vertical;width:100%;height:${"read focused".includes(this.renderStyle) ? "180px" : "120px"}">${this.fillRequestWithDefault === "true" ? defaultVal : ""}</textarea>` : html` <input type="${paramSchema.format === "password" ? "password" : "text"}" spellcheck="false" style="width:100%" placeholder="${paramSchema.example || defaultVal || ""}" class="request-param" part="textbox textbox-param" data-ptype="${paramType}" data-pname="${param.name}" data-default="${Array.isArray(defaultVal) ? defaultVal.join("~|~") : defaultVal}" data-array="false" @keyup="${this.requestParamFunction}" .value="${this.fillRequestWithDefault === "true" ? defaultVal : ""}">`} </td>` : ""} ${this.renderStyle === "focused" ? html` <td> ${paramSchema.default || paramSchema.constraint || paramSchema.allowedValues || paramSchema.pattern ? html` <div class="param-constraint"> ${paramSchema.constraint ? html`<span style="font-weight:700">Constraints: </span>${paramSchema.constraint}<br>` : ""} ${paramSchema.pattern ? html`<span style="font-weight:700">Pattern: </span>${truncateString(paramSchema.pattern, 60)}<br>` : ""} ${paramSchema.allowedValues && paramSchema.allowedValues.split("\u2503").map((v, i) => html` ${i > 0 ? "|" : html`<span style="font-weight:700">Allowed: </span>`} ${html` <a part="anchor anchor-param-constraint" class="${this.allowTry === "true" ? "" : "inactive-link"}" data-type="${paramSchema.type === "array" ? paramSchema.type : "string"}" data-enum="${v.trim()}" @click="${(e) => {
        const inputEl = e.target.closest("table").querySelector(`[data-pname="${param.name}"]`);
        if (inputEl) {
          if (e.target.dataset.type === "array") {
            inputEl.value = [e.target.dataset.enum];
          } else {
            inputEl.value = e.target.dataset.enum;
          }
        }
      }}"> ${v} </a>`}`)} </div>` : ""} </td> ` : ""} </tr>`);
    }
    return html` <div class="table-title top-gap">${title}${paramType === "path" ? html`<span style="color:var(--red)">*</span>` : ""}</div> <div style="display:block;overflow-x:auto;max-width:100%"> <table role="presentation" class="m-table" style="width:100%;word-break:break-word"> ${tableRows} </table> </div>`;
  }
  resetRequestBodySelection() {
    this.selectedRequestBodyType = "";
    this.selectedRequestBodyExample = "";
    this.clearResponseData();
  }
  onSelectExample(e) {
    this.selectedRequestBodyExample = e.target.value;
    const exampleDropdownEl = e.target;
    window.setTimeout((selectEl) => {
      const exampleTextareaEl = selectEl.closest(".example-panel").querySelector(".request-body-param");
      const userInputExampleTextareaEl = selectEl.closest(".example-panel").querySelector(".request-body-param-user-input");
      userInputExampleTextareaEl.value = exampleTextareaEl.value;
    }, 0, exampleDropdownEl);
  }
  onMimeTypeChange(e) {
    this.selectedRequestBodyType = e.target.value;
    const mimeDropdownEl = e.target;
    this.selectedRequestBodyExample = "";
    window.setTimeout((selectEl) => {
      const exampleTextareaEl = selectEl.closest(".request-body-container").querySelector(".request-body-param");
      if (exampleTextareaEl) {
        const userInputExampleTextareaEl = selectEl.closest(".request-body-container").querySelector(".request-body-param-user-input");
        userInputExampleTextareaEl.value = exampleTextareaEl.value;
      }
    }, 0, mimeDropdownEl);
  }
  requestBodyTemplate() {
    if (!this.request_body) {
      return "";
    }
    if (Object.keys(this.request_body).length === 0) {
      return "";
    }
    let reqBodyTypeSelectorHtml = "";
    let reqBodyFileInputHtml = "";
    let reqBodyFormHtml = "";
    let reqBodySchemaHtml = "";
    let reqBodyExampleHtml = "";
    const requestBodyTypes = [];
    const content = this.request_body.content;
    for (const mimeType in content) {
      requestBodyTypes.push({
        mimeType,
        schema: content[mimeType].schema,
        example: content[mimeType].example,
        examples: content[mimeType].examples
      });
      if (!this.selectedRequestBodyType) {
        this.selectedRequestBodyType = mimeType;
      }
    }
    reqBodyTypeSelectorHtml = requestBodyTypes.length === 1 ? "" : html` <select aria-label="mime type" style="min-width:100px;max-width:100%;margin-bottom:-1px" @change="${(e) => this.onMimeTypeChange(e)}"> ${requestBodyTypes.map((reqBody) => html` <option value="${reqBody.mimeType}" ?selected="${reqBody.mimeType === this.selectedRequestBodyType}"> ${reqBody.mimeType} </option> `)} </select> `;
    requestBodyTypes.forEach((reqBody) => {
      let reqBodyExamples = [];
      if (this.selectedRequestBodyType.includes("json") || this.selectedRequestBodyType.includes("xml") || this.selectedRequestBodyType.includes("text")) {
        if (reqBody.mimeType === this.selectedRequestBodyType) {
          reqBodyExamples = generateExample(reqBody.examples ? reqBody.examples : "", reqBody.example ? reqBody.example : "", reqBody.schema, reqBody.mimeType, false, true, "text", true);
          if (!this.selectedRequestBodyExample) {
            this.selectedRequestBodyExample = reqBodyExamples.length > 0 ? reqBodyExamples[0].exampleId : "";
          }
          reqBodyExampleHtml = html` ${reqBodyExampleHtml} <div class="example-panel border-top pad-top-8"> ${reqBodyExamples.length === 1 ? "" : html` <select aria-label="request body example" style="min-width:100px;max-width:100%;margin-bottom:-1px" @change="${(e) => this.onSelectExample(e)}"> ${reqBodyExamples.map((v) => html`<option value="${v.exampleId}" ?selected="${v.exampleId === this.selectedRequestBodyExample}"> ${v.exampleSummary.length > 80 ? v.exampleId : v.exampleSummary ? v.exampleSummary : v.exampleId} </option>`)} </select> `} ${reqBodyExamples.filter((v) => v.exampleId === this.selectedRequestBodyExample).map((v) => html` <div class="example ${v.exampleId === this.selectedRequestBodyExample ? "example-selected" : ""}" data-default="${v.exampleId}"> ${v.exampleSummary && v.exampleSummary.length > 80 ? html`<div style="padding:4px 0"> ${v.exampleSummary} </div>` : ""} ${v.exampleDescription ? html`<div class="m-markdown-small" style="padding:4px 0"> ${unsafeHTML(marked(v.exampleDescription || ""))} </div>` : ""} <textarea class="textarea request-body-param-user-input" part="textarea textarea-param" spellcheck="false" data-ptype="${reqBody.mimeType}" data-default="${v.exampleFormat === "text" ? v.exampleValue : JSON.stringify(v.exampleValue, null, 8)}" data-default-format="${v.exampleFormat}" style="width:100%;resize:vertical">${this.fillRequestWithDefault === "true" ? v.exampleFormat === "text" ? v.exampleValue : JSON.stringify(v.exampleValue, null, 8) : ""}</textarea> <textarea class="textarea is-hidden request-body-param ${reqBody.mimeType.substring(reqBody.mimeType.indexOf("/") + 1)}" spellcheck="false" data-ptype="${reqBody.mimeType}" style="width:100%;resize:vertical;display:none">${v.exampleFormat === "text" ? v.exampleValue : JSON.stringify(v.exampleValue, null, 8)}</textarea> </div> `)} </div> `;
        }
      } else if (this.selectedRequestBodyType.includes("form-urlencoded") || this.selectedRequestBodyType.includes("form-data")) {
        if (reqBody.mimeType === this.selectedRequestBodyType) {
          const ex = generateExample(reqBody.examples ? reqBody.examples : "", reqBody.example ? reqBody.example : "", reqBody.schema, reqBody.mimeType, false, true, "text", true);
          if (reqBody.schema) {
            reqBodyFormHtml = this.formDataTemplate(reqBody.schema, reqBody.mimeType, ex[0] ? ex[0].exampleValue : "");
          }
        }
      } else if (mediaFileRegex.test(this.selectedRequestBodyType) || textFileRegex.test(this.selectedRequestBodyType)) {
        if (reqBody.mimeType === this.selectedRequestBodyType) {
          reqBodyFileInputHtml = html` <div class="small-font-size bold-text row"> <input type="file" part="file-input" style="max-width:100%" class="request-body-param-file" data-ptype="${reqBody.mimeType}" spellcheck="false"> </div> `;
        }
      }
      if (reqBody.mimeType.includes("json") || reqBody.mimeType.includes("xml") || reqBody.mimeType.includes("text")) {
        const schemaAsObj = schemaInObjectNotation(reqBody.schema, {});
        if (this.schemaStyle === "table") {
          reqBodySchemaHtml = html` ${reqBodySchemaHtml} <schema-table class="${reqBody.mimeType.substring(reqBody.mimeType.indexOf("/") + 1)} pad-top-8" style="display:${this.selectedRequestBodyType === reqBody.mimeType ? "block" : "none"}" .data="${schemaAsObj}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="${this.schemaHideReadOnly.includes(this.method)}" schema-hide-write-only="false"> </schema-table> `;
        } else {
          reqBodySchemaHtml = html` ${reqBodySchemaHtml} <schema-tree class="${reqBody.mimeType.substring(reqBody.mimeType.indexOf("/") + 1)} pad-top-8" style="display:${this.selectedRequestBodyType === reqBody.mimeType ? "block" : "none"}" .data="${schemaAsObj}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="${this.schemaHideReadOnly.includes(this.method)}" schema-hide-write-only="false"> </schema-tree> `;
        }
      }
    });
    return html` <div class="request-body-container" data-selected-request-body-type="${this.selectedRequestBodyType}"> <div class="table-title top-gap row"> REQUEST BODY ${this.request_body.required ? html`<span class="mono-font" style="color:var(--red)">*</span>` : ""} <span style="font-weight:400;margin-left:5px"> ${this.selectedRequestBodyType}</span> <span style="flex:1"></span> ${reqBodyTypeSelectorHtml} </div> ${this.request_body.description ? html`<div class="m-markdown" style="margin-bottom:12px">${unsafeHTML(marked(this.request_body.description))}</div>` : ""} ${this.selectedRequestBodyType.includes("json") || this.selectedRequestBodyType.includes("xml") || this.selectedRequestBodyType.includes("text") ? html` <div class="tab-panel col" style="border-width:0 0 1px 0"> <div class="tab-buttons row" @click="${(e) => {
      if (e.target.tagName.toLowerCase() === "button") {
        this.activeSchemaTab = e.target.dataset.tab;
      }
    }}"> <button class="tab-btn ${this.activeSchemaTab === "model" ? "active" : ""}" data-tab="model">MODEL</button> <button class="tab-btn ${this.activeSchemaTab === "body" ? "active" : ""}" data-tab="body">BODY</button> </div> ${html`<div class="tab-content col" style="display:${this.activeSchemaTab === "model" ? "block" : "none"}"> ${reqBodySchemaHtml}</div>`} ${html`<div class="tab-content col" style="display:${this.activeSchemaTab === "model" ? "none" : "block"}"> ${reqBodyExampleHtml}</div>`} </div>` : html` ${reqBodyFileInputHtml} ${reqBodyFormHtml}`} </div> `;
  }
  formDataTemplate(schema, mimeType, exampleValue = "") {
    const formDataTableRows = [];
    if (schema.properties) {
      for (const fieldName in schema.properties) {
        const fieldSchema = schema.properties[fieldName];
        if (fieldSchema.readOnly) {
          continue;
        }
        const fieldType = fieldSchema.type;
        const formdataPartSchema = schemaInObjectNotation(fieldSchema, {});
        const paramSchema = getTypeInfo(fieldSchema);
        const formdataPartExample = generateExample("", fieldSchema.example ? fieldSchema.example : "", fieldSchema, "json", false, true, "text", true);
        formDataTableRows.push(html` <tr> <td style="width:160px;min-width:100px"> <div class="param-name ${fieldSchema.deprecated ? "deprecated" : ""}"> ${fieldName}${!fieldSchema.deprecated && (schema.required && schema.required.includes(fieldName) || fieldSchema.required) ? html`<span style="color:var(--red)">*</span>` : ""} </div> <div class="param-type">${paramSchema.type}</div> </td> <td style="${fieldType === "object" ? "width:100%; padding:0;" : this.allowTry === "true" ? "" : "display:none;"} min-width:100px" colspan="${fieldType === "object" ? 2 : 1}"> ${fieldType === "array" ? fieldSchema.items && fieldSchema.items.format === "binary" ? html` <div class="file-input-container col" style="align-items:flex-end" @click="${(e) => this.onAddRemoveFileInput(e, fieldName, mimeType)}"> <div class="input-set row"> <input type="file" part="file-input" style="width:100%" data-pname="${fieldName}" data-ptype="${mimeType.includes("form-urlencode") ? "form-urlencode" : "form-data"}" data-array="false" data-file-array="true"> <button class="file-input-remove-btn"> &#x2715; </button> </div> <button class="m-btn primary file-input-add-btn" part="btn btn-fill" style="margin:2px 25px 0 0;padding:2px 6px">ADD</button> </div> ` : html` <tag-input style="width:100%" data-ptype="${mimeType.includes("form-urlencode") ? "form-urlencode" : "form-data"}" data-pname="${fieldName}" data-default="${paramSchema.default || ""}" data-array="true" placeholder="${(Array.isArray(paramSchema.example) ? paramSchema.example[0] : paramSchema.example) || "add-multiple &#x21a9;"}" .value="${paramSchema.default || ""}"> </tag-input> ` : html` ${fieldType === "object" ? html` <div class="tab-panel row" style="min-height:220px;border-left:6px solid var(--light-border-color);align-items:stretch"> <div style="width:24px;background-color:var(--light-border-color)"> <div class="row" style="flex-direction:row-reverse;width:160px;height:24px;transform:rotate(270deg) translateX(-160px);transform-origin:top left;display:block" @click="${(e) => {
          if (e.target.classList.contains("v-tab-btn")) {
            const tab = e.target.dataset.tab;
            if (tab) {
              const tabPanelEl = e.target.closest(".tab-panel");
              const selectedTabBtnEl = tabPanelEl.querySelector(`.v-tab-btn[data-tab="${tab}"]`);
              const otherTabBtnEl = [...tabPanelEl.querySelectorAll(`.v-tab-btn:not([data-tab="${tab}"])`)];
              const selectedTabContentEl = tabPanelEl.querySelector(`.tab-content[data-tab="${tab}"]`);
              const otherTabContentEl = [...tabPanelEl.querySelectorAll(`.tab-content:not([data-tab="${tab}"])`)];
              selectedTabBtnEl.classList.add("active");
              selectedTabContentEl.style.display = "block";
              otherTabBtnEl.forEach((el) => {
                el.classList.remove("active");
              });
              otherTabContentEl.forEach((el) => {
                el.style.display = "none";
              });
            }
          }
          if (e.target.tagName.toLowerCase() === "button") {
            this.activeSchemaTab = e.target.dataset.tab;
          }
        }}"> <button class="v-tab-btn ${this.activeSchemaTab === "model" ? "active" : ""}" data-tab="model">MODEL</button> <button class="v-tab-btn ${this.activeSchemaTab === "body" ? "active" : ""}" data-tab="body">REQUEST BODY</button> </div> </div> ${html` <div class="tab-content col" data-tab="model" style="display:${this.activeSchemaTab === "model" ? "block" : "none"};padding-left:5px;width:100%"> <schema-tree .data="${formdataPartSchema}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}"> </schema-tree> </div>`} ${html` <div class="tab-content col" data-tab="example" style="display:${this.activeSchemaTab === "body" ? "block" : "none"};padding-left:5px;width:100%"> <textarea class="textarea" placeholder="${formdataPartExample[0] && formdataPartExample[0].exampleValue || paramSchema.default || ""}" part="textarea textarea-param" style="width:100%;border:none;resize:vertical" data-array="false" data-ptype="${mimeType.includes("form-urlencode") ? "form-urlencode" : "form-data"}" data-pname="${fieldName}" data-default="${paramSchema.default || ""}" spellcheck="false">${this.fillRequestWithDefault === "true" ? paramSchema.default : ""}</textarea> <textarea data-pname="hidden-${fieldName}" data-ptype="${mimeType.includes("form-urlencode") ? "hidden-form-urlencode" : "hidden-form-data"}" class="is-hidden" style="display:none">${paramSchema.default}</textarea> </div>`} </div>` : html` ${this.allowTry === "true" ? html`<input placeholder="${paramSchema.example || paramSchema.default || ""}" .value="${this.fillRequestWithDefault === "true" ? paramSchema.default || "" : ""}" spellcheck="false" type="${fieldSchema.format === "binary" ? "file" : fieldSchema.format === "password" ? "password" : "text"}" part="textbox textbox-param" style="width:100%" data-ptype="${mimeType.includes("form-urlencode") ? "form-urlencode" : "form-data"}" data-pname="${fieldName}" data-default="${paramSchema.default || ""}" data-array="false">` : ""} `}`} </td> ${fieldType === "object" ? "" : html` <td> ${paramSchema.default || paramSchema.constraint || paramSchema.allowedValues || paramSchema.pattern ? html` <div class="param-constraint"> ${paramSchema.pattern ? html`<span style="font-weight:700">Pattern: </span>${paramSchema.pattern}<br>` : ""} ${paramSchema.constraint ? html`<span style="font-weight:700">Constraints: </span>${paramSchema.constraint}<br>` : ""} ${paramSchema.allowedValues && paramSchema.allowedValues.split("\u2503").map((v, i) => html` ${i > 0 ? "|" : html`<span style="font-weight:700">Allowed: </span>`} ${html` <a part="anchor anchor-param-constraint" class="${this.allowTry === "true" ? "" : "inactive-link"}" data-type="${paramSchema.type === "array" ? paramSchema.type : "string"}" data-enum="${v.trim()}" @click="${(e) => {
          const inputEl = e.target.closest("table").querySelector(`[data-pname="${fieldName}"]`);
          if (inputEl) {
            if (e.target.dataset.type === "array") {
              inputEl.value = [e.target.dataset.enum];
            } else {
              inputEl.value = e.target.dataset.enum;
            }
          }
        }}"> ${v} </a>`}`)} </div>` : ""} </td>`} </tr> ${fieldType === "object" ? "" : html` <tr> <td style="border:none"> </td> <td colspan="2" style="border:none;margin-top:0;padding:0 5px 8px 5px"> <span class="m-markdown-small">${unsafeHTML(marked(fieldSchema.description || ""))}</span> ${paramSchema.example ? html` <span> <span style="font-weight:700"> Example: </span> ${paramSchema.type === "array" ? "[ " : ""} <a part="anchor anchor-param-example" class="${this.allowTry === "true" ? "" : "inactive-link"}" data-default-type="${paramSchema.type === "array" ? paramSchema.type : "string"}" data-default="${Array.isArray(paramSchema.example) && paramSchema.example.join("~|~") || paramSchema.example || ""}" @click="${(e) => {
          const inputEl = e.target.closest("table").querySelector(`[data-pname="${fieldName}"]`);
          if (inputEl) {
            if (e.target.dataset.exampleType === "array") {
              inputEl.value = e.target.dataset.example.split("~|~");
            } else {
              inputEl.value = e.target.dataset.example;
            }
          }
        }}"> ${paramSchema.type === "array" ? paramSchema.example.join(", ") : paramSchema.example} </a> ${paramSchema.type === "array" ? "] " : ""} </span>` : ""} </td> </tr> `}`);
      }
      return html` <table role="presentation" style="width:100%" class="m-table"> ${formDataTableRows} </table> `;
    }
    return html` <textarea class="textarea dynamic-form-param ${mimeType}" part="textarea textarea-param" spellcheck="false" data-pname="dynamic-form" data-ptype="${mimeType}" style="width:100%">${exampleValue}</textarea> ${schema.description ? html`<span class="m-markdown-small">${unsafeHTML(marked(schema.description))}</span>` : ""} `;
  }
  apiResponseTabTemplate() {
    const responseFormat = this.responseHeaders.includes("json") ? "json" : this.responseHeaders.includes("html") || this.responseHeaders.includes("xml") ? "html" : "";
    return html` <div class="row" style="font-size:var(--font-size-small);margin:5px 0"> ${this.responseMessage ? html`<div class="response-message ${this.responseStatus}">Response Status: ${this.responseMessage} ${this.responseElapsedMs ? html`<span><br>Execution Time: ${this.responseElapsedMs}ms</span>` : ""} </div>` : ""} <div style="flex:1"></div> <button class="m-btn" part="btn btn-outline" @click="${this.clearResponseData}">CLEAR RESPONSE</button> </div> <div class="tab-panel col" style="border-width:0 0 1px 0"> <div id="tab_buttons" class="tab-buttons row" @click="${(e) => {
      if (e.target.classList.contains("tab-btn") === false) {
        return;
      }
      this.activeResponseTab = e.target.dataset.tab;
    }}"> <button class="tab-btn ${this.activeResponseTab === "response" ? "active" : ""}" data-tab="response">RESPONSE</button> <button class="tab-btn ${this.activeResponseTab === "headers" ? "active" : ""}" data-tab="headers">RESPONSE HEADERS</button> <button class="tab-btn ${this.activeResponseTab === "curl" ? "active" : ""}" data-tab="curl">CURL</button> </div> ${this.responseIsBlob ? html` <div class="tab-content col" style="flex:1;display:${this.activeResponseTab === "response" ? "flex" : "none"}"> <button class="m-btn thin-border mar-top-8" style="width:135px" @click="${this.downloadResponseBlob}" part="btn btn-outline">DOWNLOAD</button> ${this.responseBlobType === "view" ? html`<button class="m-btn thin-border mar-top-8" style="width:135px" @click="${this.viewResponseBlob}" part="btn btn-outline">VIEW (NEW TAB)</button>` : ""} </div>` : html` <div class="tab-content col m-markdown" style="flex:1;display:${this.activeResponseTab === "response" ? "flex" : "none"}"> <button class="toolbar-copy-btn" @click="${(e) => {
      copyToClipboard(this.responseText, e);
    }}" part="btn btn-fill">Copy</button> <pre>${responseFormat ? html`<code>${unsafeHTML(import_prismjs2.default.highlight(this.responseText, import_prismjs2.default.languages[responseFormat], responseFormat))}</code>` : `${this.responseText}`}
              </pre> </div>`} <div class="tab-content col m-markdown" style="flex:1;display:${this.activeResponseTab === "headers" ? "flex" : "none"}"> <button class="toolbar-copy-btn" @click="${(e) => {
      copyToClipboard(this.responseHeaders, e);
    }}" part="btn btn-fill">Copy</button> <pre><code>${unsafeHTML(import_prismjs2.default.highlight(this.responseHeaders, import_prismjs2.default.languages.css, "css"))}</code></pre> </div> <div class="tab-content col m-markdown" style="flex:1;display:${this.activeResponseTab === "curl" ? "flex" : "none"}"> <button class="toolbar-copy-btn" @click="${(e) => {
      copyToClipboard(this.curlSyntax.replace(/\\$/, ""), e);
    }}" part="btn btn-fill">Copy</button> <pre><code>${unsafeHTML(import_prismjs2.default.highlight(this.curlSyntax.trim().replace(/\\$/, ""), import_prismjs2.default.languages.shell, "shell"))}</code></pre> </div> </div>`;
  }
  apiCallTemplate() {
    return html` <div style="display:flex;align-items:flex-end;margin:16px 0;font-size:var(--font-size-small)"> ${this.parameters.length > 0 || this.request_body ? html` <button class="m-btn thin-border" part="btn btn-outline" style="margin-right:5px" @click="${this.onClearRequestData}"> CLEAR </button>` : ""} <button class="m-btn primary btn-execute thin-border" part="btn btn-fill btn-try" @click="${this.onTryClick}">EXECUTE</button> </div> ${this.responseMessage === "" ? "" : this.apiResponseTabTemplate()} `;
  }
  onClearRequestData(e) {
    const requestPanelEl = e.target.closest(".request-panel");
    const requestPanelInputEls = [...requestPanelEl.querySelectorAll("input, tag-input, textarea:not(.is-hidden)")];
    requestPanelInputEls.forEach((el) => {
      el.value = "";
    });
  }
  async onTryClick() {
    const tryBtnEl = this.querySelectorAll(".btn-execute")[0];
    let fetchUrl;
    let curlUrl;
    let curl = "";
    let curlHeaders = "";
    let curlData = "";
    let curlForm = "";
    const closestRespContainer = this.closest(".expanded-req-resp-container, .req-resp-container");
    const respEl = closestRespContainer && closestRespContainer.getElementsByTagName("api-response")[0];
    const acceptHeader = respEl && respEl.selectedMimeType;
    const requestPanelEl = this.closest(".request-panel");
    const pathParamEls = [...requestPanelEl.querySelectorAll("[data-ptype='path']")];
    const queryParamEls = [...requestPanelEl.querySelectorAll("[data-ptype='query']")];
    const queryParamObjTypeEls = [...requestPanelEl.querySelectorAll("[data-ptype='query-object']")];
    const headerParamEls = [...requestPanelEl.querySelectorAll("[data-ptype='header']")];
    const requestBodyContainerEl = requestPanelEl.querySelector(".request-body-container");
    fetchUrl = this.path;
    const fetchOptions = {
      method: this.method.toUpperCase(),
      headers: new Headers()
    };
    pathParamEls.map((el) => {
      fetchUrl = fetchUrl.replace(`{${el.dataset.pname}}`, encodeURIComponent(el.value));
    });
    const urlQueryParam = new URLSearchParams();
    if (queryParamEls.length > 0) {
      queryParamEls.forEach((el) => {
        if (el.dataset.array === "false") {
          if (el.value !== "") {
            urlQueryParam.append(el.dataset.pname, el.value);
          }
        } else {
          const paramSerializeStyle = el.dataset.paramSerializeStyle;
          const paramSerializeExplode = el.dataset.paramSerializeExplode;
          let vals = el.value && Array.isArray(el.value) ? el.value : [];
          vals = Array.isArray(vals) ? vals.filter((v) => v !== "") : [];
          if (vals.length > 0) {
            if (paramSerializeStyle === "spaceDelimited") {
              urlQueryParam.append(el.dataset.pname, vals.join(" ").replace(/^\s|\s$/g, ""));
            } else if (paramSerializeStyle === "pipeDelimited") {
              urlQueryParam.append(el.dataset.pname, vals.join("|").replace(/^\||\|$/g, ""));
            } else {
              if (paramSerializeExplode === "true") {
                vals.forEach((v) => {
                  urlQueryParam.append(el.dataset.pname, v);
                });
              } else {
                urlQueryParam.append(el.dataset.pname, vals.join(",").replace(/^,|,$/g, ""));
              }
            }
          }
        }
      });
    }
    if (queryParamObjTypeEls.length > 0) {
      queryParamObjTypeEls.map((el) => {
        try {
          let queryParamObj = {};
          const paramSerializeStyle = el.dataset.paramSerializeStyle;
          const paramSerializeExplode = el.dataset.paramSerializeExplode;
          queryParamObj = Object.assign(queryParamObj, JSON.parse(el.value.replace(/\s+/g, " ")));
          for (const key in queryParamObj) {
            if (typeof queryParamObj[key] === "object") {
              if (Array.isArray(queryParamObj[key])) {
                if (paramSerializeStyle === "spaceDelimited") {
                  urlQueryParam.append(key, queryParamObj[key].join(" "));
                } else if (paramSerializeStyle === "pipeDelimited") {
                  urlQueryParam.append(key, queryParamObj[key].join("|"));
                } else {
                  if (paramSerializeExplode === "true") {
                    queryParamObj[key].forEach((v) => {
                      urlQueryParam.append(key, v);
                    });
                  } else {
                    urlQueryParam.append(key, queryParamObj[key]);
                  }
                }
              }
            } else {
              urlQueryParam.append(key, queryParamObj[key]);
            }
          }
        } catch (err) {
          console.log("OpenAPI Explorer: unable to parse %s into object", el.value);
        }
      });
    }
    this.api_keys.filter((v) => v.finalKeyValue).forEach((v) => {
      if (v.in === "query") {
        urlQueryParam.append(v.name, v.finalKeyValue);
        return;
      }
      fetchOptions.headers.append(v.name, v.finalKeyValue);
      curlHeaders += ` -H "${v.name}: ${v.finalKeyValue}" \\
`;
    });
    fetchUrl = `${fetchUrl}${urlQueryParam.toString() ? "?" : ""}${urlQueryParam.toString()}`;
    fetchUrl = `${this.serverUrl.replace(/\/$/, "")}${fetchUrl}`;
    if (fetchUrl.startsWith("http") === false) {
      const url = new URL(fetchUrl, window.location.href);
      curlUrl = url.href;
    } else {
      curlUrl = fetchUrl;
    }
    curl = `curl -X ${this.method.toUpperCase()} "${curlUrl}" \\
`;
    if (acceptHeader) {
      fetchOptions.headers.append("Accept", acceptHeader);
      curlHeaders += ` -H "Accept: ${acceptHeader}" \\
`;
    } else if (this.accept) {
      fetchOptions.headers.append("Accept", this.accept);
      curlHeaders += ` -H "Accept: ${this.accept}" \\
`;
    }
    headerParamEls.map((el) => {
      if (el.value) {
        fetchOptions.headers.append(el.dataset.pname, el.value);
        curlHeaders += ` -H "${el.dataset.pname}: ${el.value}" \\
`;
      }
    });
    if (requestBodyContainerEl) {
      const requestBodyType = requestBodyContainerEl.dataset.selectedRequestBodyType;
      if (requestBodyType.includes("form-urlencoded")) {
        const formUrlDynamicTextAreaEl = requestPanelEl.querySelector("[data-ptype='dynamic-form']");
        if (formUrlDynamicTextAreaEl) {
          const val = formUrlDynamicTextAreaEl.value;
          const formUrlDynParams = new URLSearchParams();
          let proceed = true;
          let tmpObj;
          if (val) {
            try {
              tmpObj = JSON.parse(val);
            } catch (err) {
              proceed = false;
              console.warn("OpenAPI Explorer: Invalid JSON provided", err);
            }
          } else {
            proceed = false;
          }
          if (proceed) {
            for (const prop in tmpObj) {
              formUrlDynParams.append(prop, JSON.stringify(tmpObj[prop]));
            }
            fetchOptions.body = formUrlDynParams;
            curlData = ` -d ${formUrlDynParams.toString()} \\
`;
          }
        } else {
          const formUrlEls = [...requestPanelEl.querySelectorAll("[data-ptype='form-urlencode']")];
          const formUrlParams = new URLSearchParams();
          formUrlEls.filter((v) => v.type !== "file").forEach((el) => {
            if (el.dataset.array === "false") {
              if (el.value) {
                formUrlParams.append(el.dataset.pname, el.value);
              }
            } else {
              const vals = el.value && Array.isArray(el.value) ? el.value.join(",") : "";
              formUrlParams.append(el.dataset.pname, vals);
            }
          });
          fetchOptions.body = formUrlParams;
          curlData = ` -d ${formUrlParams.toString()} \\
`;
        }
      } else if (requestBodyType.includes("form-data")) {
        const formDataParams = new FormData();
        const formDataEls = [...requestPanelEl.querySelectorAll("[data-ptype='form-data']")];
        formDataEls.forEach((el) => {
          if (el.dataset.array === "false") {
            if (el.type === "file" && el.files[0]) {
              formDataParams.append(el.dataset.pname, el.files[0], el.files[0].name);
              curlForm += ` -F "${el.dataset.pname}=@${el.files[0].name}" \\
`;
            } else if (el.value) {
              formDataParams.append(el.dataset.pname, el.value);
              curlForm += ` -F "${el.dataset.pname}=${el.value}" \\
`;
            }
          } else if (el.value && Array.isArray(el.value)) {
            el.value.forEach((v) => {
              curlForm = `${curlForm} -F "${el.dataset.pname}[]=${v}" \\
`;
            });
            formDataParams.append(el.dataset.pname, el.value.join(","));
          }
        });
        fetchOptions.body = formDataParams;
      } else if (mediaFileRegex.test(requestBodyType) || textFileRegex.test(requestBodyType)) {
        const bodyParamFileEl = requestPanelEl.querySelector(".request-body-param-file");
        if (bodyParamFileEl && bodyParamFileEl.files[0]) {
          fetchOptions.body = bodyParamFileEl.files[0];
          curlData = ` --data-binary @${bodyParamFileEl.files[0].name} \\
`;
        }
      } else if (requestBodyType.includes("json") || requestBodyType.includes("xml") || requestBodyType.includes("text")) {
        const exampleTextAreaEl = requestPanelEl.querySelector(".request-body-param-user-input");
        if (exampleTextAreaEl && exampleTextAreaEl.value) {
          fetchOptions.body = exampleTextAreaEl.value;
          if (requestBodyType.includes("json")) {
            try {
              curlData = ` -d '${JSON.stringify(JSON.parse(exampleTextAreaEl.value))}' \\
`;
            } catch (err) {
            }
          }
          if (!curlData) {
            curlData = ` -d '${exampleTextAreaEl.value.replace(/'/g, `'"'"'`)}' \\
`;
          }
        }
      }
      if (!requestBodyType.includes("form-data")) {
        fetchOptions.headers.append("Content-Type", requestBodyType);
      }
      curlHeaders += ` -H "Content-Type: ${requestBodyType}" \\
`;
    }
    this.curlSyntax = "";
    this.responseIsBlob = false;
    this.respContentDisposition = "";
    if (this.responseBlobUrl) {
      URL.revokeObjectURL(this.responseBlobUrl);
      this.responseBlobUrl = "";
    }
    this.curlSyntax = `${curl}${curlHeaders}${curlData}${curlForm}`;
    if (this.fetchCredentials) {
      fetchOptions.credentials = this.fetchCredentials;
    }
    const fetchRequest = {
      url: fetchUrl,
      options: fetchOptions
    };
    const event = {
      bubbles: true,
      composed: true,
      detail: {
        request: fetchRequest
      }
    };
    this.dispatchEvent(new CustomEvent("before-try", event));
    this.dispatchEvent(new CustomEvent("request", event));
    const fetchRequestObject = new Request(fetchUrl, fetchOptions);
    let fetchResponse;
    try {
      let respBlob;
      let respJson;
      let respText;
      tryBtnEl.disabled = true;
      const fetchStart = new Date();
      this.responseStatus = "";
      this.responseMessage = "";
      this.responseUrl = "";
      this.responseHeaders = "";
      this.responseText = "\u231B";
      this.requestUpdate();
      const awaiter = new Promise((resolve2) => setTimeout(resolve2, 200));
      fetchResponse = await fetch(fetchRequestObject);
      this.responseElapsedMs = new Date() - fetchStart;
      await awaiter;
      tryBtnEl.disabled = false;
      this.responseStatus = fetchResponse.ok ? "success" : "error";
      this.responseMessage = fetchResponse.statusText ? `${fetchResponse.statusText} (${fetchResponse.status})` : fetchResponse.status;
      this.responseUrl = fetchResponse.url;
      this.responseHeaders = "";
      const headers = {};
      fetchResponse.headers.forEach((hdrVal, hdr) => {
        this.responseHeaders = `${this.responseHeaders}${hdr.trim()}: ${hdrVal}
`;
        headers[hdr.trim()] = hdrVal && hdrVal.trim();
      });
      const contentType = fetchResponse.headers.get("content-type");
      const respEmpty = (await fetchResponse.clone().text()).length === 0;
      if (respEmpty) {
        this.responseText = "";
      } else if (contentType) {
        if (contentType.includes("json")) {
          if (/charset=[^"']+/.test(contentType)) {
            const encoding = contentType.split("charset=")[1];
            const buffer = await fetchResponse.arrayBuffer();
            try {
              respText = new TextDecoder(encoding).decode(buffer);
            } catch {
              respText = new TextDecoder("utf-8").decode(buffer);
            }
            try {
              this.responseText = JSON.stringify(JSON.parse(respText), null, 8);
            } catch {
              this.responseText = respText;
            }
          } else {
            respJson = await fetchResponse.json();
            this.responseText = JSON.stringify(respJson, null, 8);
          }
        } else if (textFileRegex.test(contentType)) {
          this.responseIsBlob = true;
          this.responseBlobType = "download";
        } else if (mediaFileRegex.test(contentType)) {
          this.responseIsBlob = true;
          this.responseBlobType = "view";
        } else {
          respText = await fetchResponse.text();
          if (contentType.includes("xml")) {
            this.responseText = (0, import_xml_but_prettier.default)(respText, {
              textNodesOnSameLine: true,
              indentor: " "
            });
          } else {
            this.responseText = respText;
          }
        }
        if (this.responseIsBlob) {
          const contentDisposition = fetchResponse.headers.get("content-disposition");
          const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
          const filename = filenameRegex.exec(contentDisposition);
          this.respContentDisposition = filename && filename[1] && filename[1].replace(/['"]/g, "") || `download.${extension.extension(contentType) || "file"}`;
          respBlob = await fetchResponse.blob();
          this.responseBlobUrl = URL.createObjectURL(respBlob);
        }
      } else {
        respText = await fetchResponse.text();
        this.responseText = respText;
      }
      const responseEvent = {
        bubbles: true,
        composed: true,
        detail: {
          request: fetchRequest,
          response: {
            headers,
            body: respJson || respText || respBlob || fetchResponse.body,
            status: fetchResponse.status
          }
        }
      };
      this.dispatchEvent(new CustomEvent("after-try", responseEvent));
      this.dispatchEvent(new CustomEvent("response", responseEvent));
    } catch (error) {
      tryBtnEl.disabled = false;
      this.responseMessage = `${error.message} (Check the browser network tab for more information.)`;
      this.responseStatus = "error";
      const responseEvent = {
        bubbles: true,
        composed: true,
        detail: {
          error,
          request: fetchRequest
        }
      };
      document.dispatchEvent(new CustomEvent("after-try", responseEvent));
      document.dispatchEvent(new CustomEvent("response", responseEvent));
    }
  }
  onAddRemoveFileInput(e, pname, ptype) {
    if (e.target.tagName.toLowerCase() !== "button") {
      return;
    }
    if (e.target.classList.contains("file-input-remove-btn")) {
      const el2 = e.target.closest(".input-set");
      el2.remove();
      return;
    }
    const el = e.target.closest(".file-input-container");
    const newInputContainerEl = document.createElement("div");
    newInputContainerEl.setAttribute("class", "input-set row");
    const newInputEl = document.createElement("input");
    newInputEl.type = "file";
    newInputEl.style = "width:200px; margin-top:2px;";
    newInputEl.setAttribute("data-pname", pname);
    newInputEl.setAttribute("data-ptype", ptype.includes("form-urlencode") ? "form-urlencode" : "form-data");
    newInputEl.setAttribute("data-array", "false");
    newInputEl.setAttribute("data-file-array", "true");
    const newRemoveBtnEl = document.createElement("button");
    newRemoveBtnEl.setAttribute("class", "file-input-remove-btn");
    newRemoveBtnEl.innerHTML = "&#x2715;";
    newInputContainerEl.appendChild(newInputEl);
    newInputContainerEl.appendChild(newRemoveBtnEl);
    el.insertBefore(newInputContainerEl, e.target);
  }
  downloadResponseBlob() {
    if (this.responseBlobUrl) {
      const a = document.createElement("a");
      document.body.appendChild(a);
      a.style = "display: none";
      a.href = this.responseBlobUrl;
      a.download = this.respContentDisposition;
      a.click();
      a.remove();
    }
  }
  viewResponseBlob() {
    if (this.responseBlobUrl) {
      const a = document.createElement("a");
      document.body.appendChild(a);
      a.style = "display: none";
      a.href = this.responseBlobUrl;
      a.target = "_blank";
      a.click();
      a.remove();
    }
  }
  clearResponseData() {
    this.responseUrl = "";
    this.responseHeaders = "";
    this.responseText = "";
    this.responseStatus = "";
    this.responseMessage = "";
    this.responseElapsedMs = 0;
    this.responseIsBlob = false;
    this.responseBlobType = "";
    this.respContentDisposition = "";
    if (this.responseBlobUrl) {
      URL.revokeObjectURL(this.responseBlobUrl);
      this.responseBlobUrl = "";
    }
  }
  requestParamFunction(event) {
    if (event.key === "Enter") {
      this.onTryClick();
      event.preventDefault();
    }
  }
  disconnectedCallback() {
    if (this.responseBlobUrl) {
      URL.revokeObjectURL(this.responseBlobUrl);
      this.responseBlobUrl = "";
    }
    super.disconnectedCallback();
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("api-request", ApiRequest);
}

// node_modules/openapi-explorer/dist/es/components/schema-table.js
var SchemaTable = class extends LitElement {
  static get properties() {
    return {
      schemaExpandLevel: {
        type: Number,
        attribute: "schema-expand-level"
      },
      schemaDescriptionExpanded: {
        type: String,
        attribute: "schema-description-expanded"
      },
      schemaHideReadOnly: {
        type: String,
        attribute: "schema-hide-read-only"
      },
      schemaHideWriteOnly: {
        type: String,
        attribute: "schema-hide-write-only"
      },
      data: {
        type: Object
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.schemaExpandLevel || this.schemaExpandLevel < 1) {
      this.schemaExpandLevel = 99999;
    }
    if (!this.schemaDescriptionExpanded || !"true false".includes(this.schemaDescriptionExpanded)) {
      this.schemaDescriptionExpanded = "true";
    }
    if (!this.schemaHideReadOnly || !"true false".includes(this.schemaHideReadOnly)) {
      this.schemaHideReadOnly = "true";
    }
    if (!this.schemaHideWriteOnly || !"true false".includes(this.schemaHideWriteOnly)) {
      this.schemaHideWriteOnly = "true";
    }
  }
  static get styles() {
    return [font_styles_default, schema_styles_default, css`.table{font-size:var(--font-size-small);text-align:left;line-height:calc(var(--font-size-small) + 6px)}.table .tr{width:calc(100% - 5px);padding:0 0 0 5px;border-bottom:1px dotted var(--light-border-color)}.table .td{padding:4px 0}.table .key{width:240px}.key.deprecated .key-label{text-decoration:line-through}.table .key-type{white-space:normal;width:150px}.obj-toggle{padding:0 2px;border-radius:2px;border:1px solid transparent;display:inline-block;margin-left:-16px;color:var(--primary-color);cursor:pointer;font-size:calc(var(--font-size-small) + 4px);font-family:var(--font-mono);background-clip:border-box}.obj-toggle:hover{border-color:var(--primary-color)}.tr.expanded+.object-body{display:block}.tr.collapsed+.object-body{display:none}`];
  }
  render() {
    return html` <div class="table"> ${this.data && this.data["::description"] ? html`<span class="m-markdown"> ${unsafeHTML(marked(this.data["::description"] || ""))}</span>` : ""} <div style="border:1px solid var(--light-border-color)"> <div style="display:flex;background-color:var(--bg2);padding:8px 4px;border-bottom:1px solid var(--light-border-color)"> <div class="key" style="font-family:var(--font-regular);font-weight:700;color:var(--fg)"> Field </div> <div class="key-type" style="font-family:var(--font-regular);font-weight:700;color:var(--fg)"> Type </div> <div class="key-descr" style="font-family:var(--font-regular);font-weight:700;color:var(--fg)"> Description </div> </div> ${this.data ? html`${this.generateTree(this.data["::type"] === "array" ? this.data["::props"] : this.data, this.data["::type"])}` : ""} </div> </div> `;
  }
  generateTree(data, dataType = "object", key = "", description = "", schemaLevel = 0, indentLevel = 0) {
    const newSchemaLevel = data["::type"] && data["::type"].startsWith("xxx-of") ? schemaLevel : schemaLevel + 1;
    const newIndentLevel = dataType === "xxx-of-option" || data["::type"] === "xxx-of-option" || key.startsWith("::OPTION") ? indentLevel : indentLevel + 1;
    const leftPadding = 16 * newIndentLevel;
    if (!data) {
      return html`<div class="null" style="display:inline">null</div>`;
    }
    if (Object.keys(data).length === 0) {
      return html`<span class="td key object" style="padding-left:${leftPadding}px">${key}</span>`;
    }
    let keyLabel = "";
    let keyDescr = "";
    let isOneOfLabel = false;
    if (key.startsWith("::ONE~OF") || key.startsWith("::ANY~OF")) {
      keyLabel = key.replace("::", "").replace("~", " ");
      isOneOfLabel = true;
    } else if (key.startsWith("::OPTION")) {
      const parts2 = key.split("~");
      keyLabel = parts2[1];
      keyDescr = parts2[2];
    } else {
      keyLabel = key;
    }
    let detailObjType = "";
    if (data["::type"] === "object") {
      if (dataType === "array") {
        detailObjType = "array";
      } else {
        detailObjType = "object";
      }
    } else if (data["::type"] === "array") {
      if (dataType === "array") {
        detailObjType = "array of array";
      } else {
        detailObjType = "array";
      }
    }
    if (typeof data === "object") {
      return html` ${newSchemaLevel >= 0 && key ? html` <div class="tr ${newSchemaLevel <= this.schemaExpandLevel ? "expanded" : "collapsed"} ${data["::type"]}" data-obj="${keyLabel}"> <div class="td key ${data["::deprecated"] ? "deprecated" : ""}" style="padding-left:${leftPadding}px"> ${keyLabel || keyDescr ? html` <span class="obj-toggle ${newSchemaLevel < this.schemaExpandLevel ? "expanded" : "collapsed"}" data-obj="${keyLabel}" @click="${(e) => this.toggleObjectExpand(e, keyLabel)}"> ${schemaLevel < this.schemaExpandLevel ? "-" : "+"} </span>` : ""} ${data["::type"] === "xxx-of-option" || data["::type"] === "xxx-of-array" || key.startsWith("::OPTION") ? html`<span class="xxx-of-key" style="margin-left:-6px">${keyLabel}</span><span class="${isOneOfLabel ? "xxx-of-key" : "xxx-of-descr"}">${keyDescr}</span>` : keyLabel.endsWith("*") ? html`<span class="key-label" style="display:inline-block;margin-left:-6px"> ${keyLabel.substring(0, keyLabel.length - 1)}</span><span style="color:var(--red)">*</span>` : html`<span class="key-label" style="display:inline-block;margin-left:-6px">${keyLabel === "::props" ? "" : keyLabel}</span>`} ${data["::type"] === "xxx-of" && dataType === "array" ? html`<span style="color:var(--primary-color)">ARRAY</span>` : ""} </div> <div class="td key-type">${(data["::type"] || "").includes("xxx-of") ? "" : detailObjType}</div> <div class="td key-descr m-markdown-small" style="line-height:1.7">${unsafeHTML(marked(description || ""))}</div> </div>` : html` ${data["::type"] === "array" && dataType === "array" ? html`<div class="tr"> <div class="td"> ${dataType} </div> </div>` : ""} `} <div class="object-body"> ${Array.isArray(data) && data[0] ? html`${this.generateTree(data[0], "xxx-of-option", "::ARRAY~OF", "", newSchemaLevel, newIndentLevel)}` : html` ${Object.keys(data).map((dataKey) => dataKey.startsWith("::") && data[dataKey]["::type"] !== "array" && data[dataKey]["::type"] !== "object" ? "" : html`${this.generateTree(data[dataKey]["::type"] === "array" ? data[dataKey]["::props"] : data[dataKey], data[dataKey]["::type"], dataKey, data[dataKey]["::description"], newSchemaLevel, newIndentLevel)}`)}`} <div> </div></div>`;
    }
    const {
      type,
      readOrWriteOnly,
      constraint,
      defaultValue,
      example,
      allowedValues,
      pattern,
      schemaDescription,
      schemaTitle,
      deprecated
    } = JSON.parse(data);
    if (readOrWriteOnly === "\u{1F181}" && this.schemaHideReadOnly === "true") {
      return void 0;
    }
    if (readOrWriteOnly === "\u{1F186}" && this.schemaHideWriteOnly === "true") {
      return void 0;
    }
    const dataTypeCss = type.replace(/┃.*/g, "").replace(/[^a-zA-Z0-9+]/g, "").substring(0, 4).toLowerCase();
    return html` <div class="tr primitive"> <div class="td key ${deprecated ? "deprecated" : ""}" style="padding-left:${leftPadding}px"> ${keyLabel && keyLabel.endsWith("*") ? html`<span class="key-label">${keyLabel.substring(0, keyLabel.length - 1)}</span><span style="color:var(--red)">*</span>` : key.startsWith("::OPTION") ? html`<span class="xxx-of-key">${keyLabel}</span><span class="xxx-of-descr">${keyDescr}</span>` : html`${keyLabel ? html`<span class="key-label"> ${keyLabel}</span>` : html`<span class="xxx-of-descr">${schemaTitle}</span>`}`} </div> <div class="td key-type ${dataTypeCss}"> ${dataType === "array" ? `${type}[]` : type} <span style="font-family:var(--font-mono)" title="${readOrWriteOnly === "\u{1F181}" && "Read only attribute" || readOrWriteOnly === "\u{1F186}" && "Write only attribute" || ""}"> ${readOrWriteOnly} </span> </div> <div class="td key-descr"> ${dataType === "array" ? html`<span class="m-markdown-small">${unsafeHTML(marked(description))}</span>` : ""} <span class="m-markdown-small" style="font-family:var(--font-mono);vertical-align:middle" title="${readOrWriteOnly === "\u{1F181}" && "Read only attribute" || readOrWriteOnly === "\u{1F186}" && "Write only attribute" || ""}"> ${unsafeHTML(marked(`${readOrWriteOnly && `${readOrWriteOnly} ` || ""}${dataType === "array" && description || `${schemaTitle ? `**${schemaTitle}:**` : ""} ${schemaDescription}` || ""}`))} </span> ${this.schemaDescriptionExpanded ? html` ${constraint ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Constraints: </span>${constraint}</div><br>` : ""} ${defaultValue ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Default: </span>${defaultValue}</div><br>` : ""} ${allowedValues ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Allowed: </span>${allowedValues}</div><br>` : ""} ${pattern ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Pattern: </span>${pattern}</div><br>` : ""} ${example ? html`<div style="display:inline-block;line-break:anywhere;margin-right:8px"><span class="bold-text">Example: </span>${example}</div><br>` : ""}` : ""} </div> </div> `;
  }
  toggleObjectExpand(e) {
    const rowEl = e.target.closest(".tr");
    if (rowEl.classList.contains("expanded")) {
      rowEl.classList.add("collapsed");
      rowEl.classList.remove("expanded");
      e.target.innerText = "+";
    } else {
      rowEl.classList.remove("collapsed");
      rowEl.classList.add("expanded");
      e.target.innerText = "-";
    }
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("schema-table", SchemaTable);
}

// node_modules/openapi-explorer/dist/es/components/api-response.js
var ApiResponse = class extends LitElement {
  constructor() {
    super();
    this.selectedStatus = "";
    this.headersForEachRespStatus = {};
    this.mimeResponsesForEachStatus = {};
    this.activeSchemaTab = "model";
  }
  static get properties() {
    return {
      callback: {
        type: String
      },
      responses: {
        type: Object
      },
      parser: {
        type: Object
      },
      schemaStyle: {
        type: String,
        attribute: "schema-style"
      },
      renderStyle: {
        type: String,
        attribute: "render-style"
      },
      selectedStatus: {
        type: String,
        attribute: "selected-status"
      },
      selectedMimeType: {
        type: String,
        attribute: "selected-mime-type"
      },
      activeSchemaTab: {
        type: String,
        attribute: "active-schema-tab"
      },
      schemaExpandLevel: {
        type: Number,
        attribute: "schema-expand-level"
      },
      schemaDescriptionExpanded: {
        type: String,
        attribute: "schema-description-expanded"
      },
      schemaHideWriteOnly: {
        type: String,
        attribute: "schema-hide-write-only"
      }
    };
  }
  static get styles() {
    return [font_styles_default, flex_styles_default, tab_styles_default, table_styles_default, input_styles_default, border_styles_default, css`.resp-head{vertical-align:middle;padding:16px 0 8px}.resp-head.divider{border-top:1px solid var(--border-color);margin-top:10px}.resp-status{font-weight:700;font-size:calc(var(--font-size-small) + 1px)}.resp-descr{font-size:calc(var(--font-size-small) + 1px)}.top-gap{margin-top:16px}.example-panel{font-size:var(--font-size-small);margin:0}.generic-tree{background:#333;color:#fff}.example-panel.generic-tree{margin-top:8px}pre.generic-tree{border:none;padding:8px 10px 10px}.example-panel select{margin-left:8px;padding-top:8px;min-width:100px;max-width:100%}.example-panel .example{padding-top:8px}.focused-mode,.read-mode{padding-top:24px;margin-top:12px;border-top:1px dashed var(--border-color)}`];
  }
  render() {
    return html` <div class="col regular-font response-panel ${this.renderStyle}-mode"> <div class="${this.callback === "true" ? "tiny-title" : "req-res-title"}"> ${this.callback === "true" ? "CALLBACK RESPONSE" : "RESPONSE"} </div> <div> ${this.responseTemplate()} <div> </div> </div></div>`;
  }
  resetSelection() {
    this.selectedStatus = "";
    this.selectedMimeType = "";
  }
  responseTemplate() {
    if (!this.responses) {
      return "";
    }
    for (const statusCode in this.responses) {
      if (!this.selectedStatus) {
        this.selectedStatus = statusCode;
      }
      const allMimeResp = {};
      for (const mimeResp in this.responses[statusCode] && this.responses[statusCode].content) {
        const mimeRespObj = this.responses[statusCode].content[mimeResp];
        if (!this.selectedMimeType) {
          this.selectedMimeType = mimeResp;
        }
        const schemaTree = schemaInObjectNotation(mimeRespObj.schema, {});
        const respExamples = generateExample(mimeRespObj.examples || "", mimeRespObj.example || "", mimeRespObj.schema, mimeResp, true, false, mimeResp.includes("json") ? "json" : "text");
        allMimeResp[mimeResp] = {
          description: this.responses[statusCode].description,
          examples: respExamples,
          selectedExample: respExamples[0] && respExamples[0].exampleId || "",
          schemaTree
        };
      }
      const tempHeaders = [];
      for (const key in this.responses[statusCode] && this.responses[statusCode].headers) {
        tempHeaders.push({
          name: key,
          ...this.responses[statusCode].headers[key]
        });
      }
      this.headersForEachRespStatus[statusCode] = tempHeaders;
      this.mimeResponsesForEachStatus[statusCode] = allMimeResp;
    }
    return html`<div class="row" style="flex-wrap:wrap"> ${Object.keys(this.responses).map((respStatus) => html` ${respStatus === "$$ref" ? "" : html` <button @click="${() => {
      this.selectedStatus = respStatus;
      if (this.responses[respStatus].content && Object.keys(this.responses[respStatus].content)[0]) {
        this.selectedMimeType = Object.keys(this.responses[respStatus].content)[0];
      } else {
        this.selectedMimeType = void 0;
      }
    }}" class="m-btn small ${this.selectedStatus === respStatus ? "primary" : ""}" part="btn--resp ${this.selectedStatus === respStatus ? "btn-fill--resp" : "btn-outline--resp"} btn-response-status" style="margin:8px 4px 0 0"> ${respStatus} </button>`}`)} </div> ${Object.keys(this.responses).map((status) => html` <div style="display:${status === this.selectedStatus ? "block" : "none"}"> <div class="top-gap"> <span class="resp-descr m-markdown">${unsafeHTML(marked(this.responses[status] && this.responses[status].description || ""))}</span> ${this.headersForEachRespStatus[status] && this.headersForEachRespStatus[status].length > 0 ? html`${this.responseHeaderListTemplate(this.headersForEachRespStatus[status])}` : ""} </div> ${Object.keys(this.mimeResponsesForEachStatus[status]).length === 0 ? "" : html` <div class="tab-panel col"> <div class="tab-buttons row" @click="${(e) => {
      if (e.target.tagName.toLowerCase() === "button") {
        this.activeSchemaTab = e.target.dataset.tab;
      }
    }}"> <button class="tab-btn ${this.activeSchemaTab === "model" ? "active" : ""}" data-tab="model">MODEL</button> <button class="tab-btn ${this.activeSchemaTab === "body" ? "active" : ""}" data-tab="body">EXAMPLE</button> <div style="flex:1"></div> ${Object.keys(this.mimeResponsesForEachStatus[status]).length === 1 ? html`<span class="small-font-size gray-text" style="align-self:center;margin-top:8px"> ${Object.keys(this.mimeResponsesForEachStatus[status])[0]} </span>` : html`${this.mimeTypeDropdownTemplate(Object.keys(this.mimeResponsesForEachStatus[status]))}`} </div> ${this.activeSchemaTab === "body" ? html`<div class="tab-content col" style="flex:1"> ${this.mimeExampleTemplate(this.mimeResponsesForEachStatus[status][this.selectedMimeType])} </div>` : html`<div class="tab-content col" style="flex:1"> ${this.mimeSchemaTemplate(this.mimeResponsesForEachStatus[status][this.selectedMimeType])} </div>`} </div> `}</div>`)} `;
  }
  responseHeaderListTemplate(respHeaders) {
    return html` <div style="padding:16px 0 8px 0" class="resp-headers small-font-size bold-text">RESPONSE HEADERS</div> <table role="presentation" style="border-collapse:collapse;margin-bottom:16px;border:1px solid var(--border-color);border-radius:var(--border-radius)" class="small-font-size mono-font"> ${respHeaders.map((v) => html` <tr> <td style="padding:8px;vertical-align:baseline;min-width:120px;border-top:1px solid var(--light-border-color);text-overflow:ellipsis"> ${v.name || ""} </td> <td style="padding:4px;vertical-align:baseline;padding:0 5px;border-top:1px solid var(--light-border-color);text-overflow:ellipsis"> ${v.schema.type || ""} </td> <td style="padding:8px;vertical-align:baseline;border-top:1px solid var(--light-border-color);text-overflow:ellipsis"> <div class="m-markdown-small regular-font">${unsafeHTML(marked(v.description || ""))}</div> </td> <td style="padding:8px;vertical-align:baseline;border-top:1px solid var(--light-border-color);text-overflow:ellipsis"> ${v.schema.example || ""} </td> </tr> `)} </table>`;
  }
  mimeTypeDropdownTemplate(mimeTypes) {
    return html` <select aria-label="mime type" @change="${(e) => {
      this.selectedMimeType = e.target.value;
    }}" style="margin-bottom:-1px;z-index:1"> ${mimeTypes.map((mimeType) => html`<option value="${mimeType}" ?selected="${mimeType === this.selectedMimeType}"> ${mimeType} </option>`)} </select>`;
  }
  onSelectExample(e) {
    const exampleContainerEl = e.target.closest(".example-panel");
    const exampleEls = [...exampleContainerEl.querySelectorAll(".example")];
    exampleEls.forEach((v) => {
      v.style.display = v.dataset.example === e.target.value ? "block" : "none";
    });
  }
  mimeExampleTemplate(mimeRespDetails) {
    if (!mimeRespDetails) {
      return html` <pre style="color:var(--red)" class="example-panel border-top"> No example provided </pre> `;
    }
    return html` ${mimeRespDetails.examples.length === 1 ? html` ${mimeRespDetails.examples[0].exampleSummary && mimeRespDetails.examples[0].exampleSummary.length > 80 ? html`<div style="padding:4px 0"> ${mimeRespDetails.examples[0].exampleSummary} </div>` : ""} ${mimeRespDetails.examples[0].exampleDescription ? html`<div class="m-markdown-small" style="padding:4px 0"> ${unsafeHTML(marked(mimeRespDetails.examples[0].exampleDescription || ""))} </div>` : ""} ${mimeRespDetails.examples[0].exampleFormat === "json" ? html` <json-tree render-style="${this.renderStyle}" .data="${mimeRespDetails.examples[0].exampleValue}" class="example-panel pad-top-8"></json-tree>` : html` <pre class="example-panel generic-tree border-top pad-top-8">${mimeRespDetails.examples[0].exampleValue}</pre> `}` : html` <span class="example-panel generic-tree ${this.renderStyle === "read" ? "border pad-8-16" : "border-top pad-top-8"}"> <select aria-label="response body example" @change="${(e) => this.onSelectExample(e)}"> ${mimeRespDetails.examples.map((v) => html`<option value="${v.exampleId}" ?selected="${v.exampleId === mimeRespDetails.selectedExample}"> ${v.exampleSummary.length > 80 ? v.exampleId : v.exampleSummary} </option>`)} </select> ${mimeRespDetails.examples.map((v) => html` <div class="example" data-example="${v.exampleId}" style="display:${v.exampleId === mimeRespDetails.selectedExample ? "block" : "none"}"> ${v.exampleSummary && v.exampleSummary.length > 80 ? html`<div style="padding:4px 0"> ${v.exampleSummary} </div>` : ""} ${v.exampleDescription ? html`<div class="m-markdown-small" style="padding:4px 0"> ${unsafeHTML(marked(v.exampleDescription || ""))} </div>` : ""} ${v.exampleFormat === "json" ? html` <json-tree render-style="${this.renderStyle}" .data="${v.exampleValue}"></json-tree>` : html`<pre class="generic-tree">${v.exampleValue}</pre>`} </div> `)} </span> `} `;
  }
  mimeSchemaTemplate(mimeRespDetails) {
    if (!mimeRespDetails) {
      return html` <pre style="color:var(--red)" class="${this.renderStyle === "read" ? "border pad-8-16" : "border-top"}"> Schema not found</pre> `;
    }
    return html` ${this.schemaStyle === "table" ? html` <schema-table render-style="${this.renderStyle}" .data="${mimeRespDetails.schemaTree}" class="example-panel ${this.renderStyle === "read" ? "border pad-8-16" : "border-top pad-top-8"}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="false" schema-hide-write-only="${this.schemaHideWriteOnly}"> </schema-table> ` : html` <schema-tree render-style="${this.renderStyle}" .data="${mimeRespDetails.schemaTree}" class="example-panel ${this.renderStyle === "read" ? "border pad-8-16" : "pad-top-8"}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="false" schema-hide-write-only="${this.schemaHideWriteOnly}"> </schema-tree>`}`;
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("api-response", ApiResponse);
}

// node_modules/openapi-explorer/dist/es/templates/expanded-endpoint-template.js
function expandedEndpointBodyTemplate(path, tagName = "") {
  const acceptContentTypes = /* @__PURE__ */ new Set();
  for (const respStatus in path.responses) {
    for (const acceptContentType in path.responses[respStatus] && path.responses[respStatus].content) {
      acceptContentTypes.add(acceptContentType.trim());
    }
  }
  const accept = [...acceptContentTypes].join(", ");
  const nonEmptyApiKeys = this.resolvedSpec.securitySchemes.filter((v) => v.finalKeyValue && path.security && path.security.some((ps) => ps[v.apiKeyId])) || [];
  const codeSampleTabPanel = path.xCodeSamples ? codeSamplesTemplate.call(this, path.xCodeSamples) : "";
  return html` ${this.renderStyle === "read" ? html`<div class="divider" part="operation-divider"></div>` : ""} <div class="expanded-endpoint-body observe-me ${path.method}" part="section-operation ${path.elementId}" id="${path.elementId}"> ${this.renderStyle === "focused" && tagName !== "General \u2982" ? html`<h3 class="upper" style="font-weight:700"> ${tagName} </h3>` : ""} ${path.deprecated ? html`<div class="bold-text red-text"> DEPRECATED </div>` : ""} ${html` <h2> ${path.shortSummary || `${path.method.toUpperCase()} ${path.path}`}</h2> <div class='mono-font part="section-operation-url" regular-font-size' style="padding:8px 0;color:var(--fg3)"> ${path.isWebhook ? html`<span style="color:var(--primary-color)"> WEBHOOK </span>` : ""} <span part="label-operation-method" class="regular-font upper method-fg bold-text ${path.method}">${path.method}</span> <span part="label-operation-path">${path.path}</span> </div>`} ${path.description ? html`<div class="m-markdown"> ${unsafeHTML(marked(path.description))}</div>` : ""} <slot name="${path.elementId}"></slot> ${pathSecurityTemplate.call(this, path.security)} ${codeSampleTabPanel} <div class="expanded-req-resp-container"> <api-request class="request-panel" method="${path.method}" path="${path.path}" .parameters="${path.parameters}" .request_body="${path.requestBody}" .api_keys="${nonEmptyApiKeys}" .servers="${path.servers}" server-url="${path.servers && path.servers[0] && path.servers[0].url || this.selectedServer.computedUrl}" fill-defaults="${this.fillRequestWithDefault}" enable-console="${this.allowTry}" accept="${accept}" render-style="${this.renderStyle}" schema-style="${this.displaySchemaAsTable ? "table" : "tree"}" active-schema-tab="${this.defaultSchemaTab}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="${this.schemaHideReadOnly}" fetch-credentials="${this.fetchCredentials}" exportparts="btn btn-fill btn-outline btn-try"> </api-request> ${path.callbacks ? callbackTemplate.call(this, path.callbacks) : ""} <api-response class="response-panel" .responses="${path.responses}" render-style="${this.renderStyle}" schema-style="${this.displaySchemaAsTable ? "table" : "tree"}" active-schema-tab="${this.defaultSchemaTab}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-write-only="${this.schemaHideWriteOnly}" selected-status="${Object.keys(path.responses || {})[0] || ""}" exportparts="btn--resp btn-fill--resp btn-outline--resp"> </api-response> </div> </div> `;
}

// node_modules/openapi-explorer/dist/es/templates/components-template.js
function componentBodyTemplate(sComponent) {
  const formdataPartSchema = schemaInObjectNotation(sComponent.component, {});
  return html` <div class="expanded-endpoint-body observe-me ${sComponent.name}" id="cmp--${sComponent.id}"> <h2>${sComponent.name}</h2> <div class="mono-font regular-font-size" style="padding:8px 0;color:var(--fg2)"> ${this.displaySchemaAsTable ? html`<schema-table .data="${formdataPartSchema}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="false" schema-hide-write-only="false"> </schema-table>` : html`<schema-tree .data="${formdataPartSchema}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="false" schema-hide-write-only="false"> </schema-tree>`} </div> </div> `;
}
function componentsTemplate() {
  return html` ${this.resolvedSpec.components.map((component) => html` <div id="cmp--${component.name.toLowerCase()}" class="regular-font section-gap--read-mode observe-me" style="border-top:1px solid var(--primary-color)"> <div class="title tag">${component.name}</div> <div class="regular-font-size"> ${unsafeHTML(`<div class='m-markdown regular-font'>${marked(component.description ? component.description : "")}</div>`)} </div> </div> <div class="regular-font section-gap--read-mode"> ${component.subComponents.filter((c) => c.expanded).map((sComponent) => componentBodyTemplate.call(this, sComponent))} </div> `)} `;
}

// node_modules/openapi-explorer/dist/es/templates/overview-template.js
function overviewTemplate() {
  return html` <section id="overview" part="section-overview" class="observe-me ${this.renderStyle === "focused" ? "section-gap--focused-mode" : "section-gap"}"> ${this.resolvedSpec && this.resolvedSpec.info ? html` <slot name="overview"> <div id="api-title" part="label-overview-title" style="font-size:32px" class="section-padding"> ${this.resolvedSpec.info.title} ${!this.resolvedSpec.info.version ? "" : html` <span style="font-size:var(--font-size-small);font-weight:700"> ${this.resolvedSpec.info.version} </span>`} </div> <div id="api-info" style="font-size:calc(var(--font-size-regular) - 1px);margin-top:8px" class="section-padding"> ${this.resolvedSpec.info.contact && this.resolvedSpec.info.contact.email ? html`<span>${this.resolvedSpec.info.contact.name || "Email"}: <a href="mailto:${this.resolvedSpec.info.contact.email}" part="anchor anchor-overview">${this.resolvedSpec.info.contact.email}</a> </span>` : ""} ${this.resolvedSpec.info.contact && this.resolvedSpec.info.contact.url ? html`<span>URL: <a href="${this.resolvedSpec.info.contact.url}" part="anchor anchor-overview">${this.resolvedSpec.info.contact.url}</a></span>` : ""} ${this.resolvedSpec.info.license ? html`<span>License: ${this.resolvedSpec.info.license.url ? html`<a href="${this.resolvedSpec.info.license.url}" part="anchor anchor-overview">${this.resolvedSpec.info.license.name}</a>` : this.resolvedSpec.info.license.name} </span>` : ""} ${this.resolvedSpec.info.termsOfService ? html`<span><a href="${this.resolvedSpec.info.termsOfService}" part="anchor anchor-overview">Terms of Service</a></span>` : ""} </div> </slot> <slot name="overview-api-description"> ${this.resolvedSpec.info.description ? html`${unsafeHTML(`<div class="m-markdown regular-font section-padding">${marked(this.resolvedSpec.info.description)}</div>`)}` : ""} </slot> ` : ""} </section> `;
}

// node_modules/openapi-explorer/dist/es/templates/server-template.js
function onApiServerChange(e, server) {
  if (e && e.target.checked) {
    this.selectedServer = server;
    this.requestUpdate();
  }
}
function onApiServerVarChange(e, serverObj) {
  const inputEls = [...e.currentTarget.closest("table").querySelectorAll("input, select")];
  let tempUrl = serverObj.url;
  inputEls.forEach((v) => {
    const regex = new RegExp(`{${v.dataset.var}}`, "g");
    tempUrl = tempUrl.replace(regex, v.value);
  });
  serverObj.computedUrl = tempUrl;
  this.requestUpdate();
}
function serverVarsTemplate() {
  return this.selectedServer && this.selectedServer.variables ? html` <div class="table-title"> SERVER VARIABLES</div> <table role="presentation" class="m-table"> ${Object.entries(this.selectedServer.variables).map((kv) => html` <tr> <td style="vertical-align:middle">${kv[0]}</td> <td> ${kv[1].enum ? html` <select data-var="${kv[0]}" @input="${(e) => {
    onApiServerVarChange.call(this, e, this.selectedServer);
  }}"> ${Object.entries(kv[1].enum).map((e) => kv[1].default === e[1] ? html` <option selected="selected" label="${e[1]}" value="${e[1]}">` : html` <option label="${e[1]}" value="${e[1]}">`)} </select>` : html` <input type="text" part="textbox textbox-server-var" spellcheck="false" data-var="${kv[0]}" value="${kv[1].default}" @input="${(e) => {
    onApiServerVarChange.call(this, e, this.selectedServer);
  }}">`} </td> </tr> ${kv[1].description ? html`<tr><td colspan="2" style="border:none"><span class="m-markdown-small"> ${unsafeHTML(marked(kv[1].description))} </span></td></tr>` : ""} `)} </table> ` : "";
}
function serverTemplate() {
  if (!this.resolvedSpec) {
    return void 0;
  }
  return html` <section id="servers" part="section-servers" style="margin-top:24px;margin-bottom:24px" class="regular-font observe-me section-padding ${this.renderStyle === "read" ? "section-gap--read-mode" : this.renderStyle === "focused" ? "section-gap--focused-mode" : "section-gap"}"> <div class="sub-title">API SERVER</div> <div class="mono-font" style="margin:12px 0;font-size:calc(var(--font-size-small) + 1px)"> ${!this.resolvedSpec.servers || !this.resolvedSpec.servers.length ? "" : html` ${this.resolvedSpec.servers.map((server, i) => html` <input type="radio" name="api_server" id="srvr-opt-${i}" value="${server.url}" @change="${(e) => {
    onApiServerChange.call(this, e, server);
  }}" .checked="${this.selectedServer.url === server.url}" style="margin:4px 0;cursor:pointer"> <label style="cursor:pointer" for="srvr-opt-${i}"> ${server.url} ${server.description ? html`- <span class="regular-font">${server.description} </span>` : ""} </label> <br> `)} `} <div class="table-title primary-text" part="label-selected-server"> SELECTED: ${this.selectedServer && this.selectedServer.computedUrl || "none"}</div> </div> <slot name="servers"></slot> ${serverVarsTemplate.call(this)} </section>`;
}

// node_modules/openapi-explorer/dist/es/templates/focused-endpoint-template.js
function wrapFocusedTemplate(templateToWrap) {
  return html` <div class="regular-font section-gap--focused-mode" part="section-operations-in-tag"> ${templateToWrap} </div>`;
}
function defaultContentTemplate() {
  if (this.showInfo === "true") {
    return overviewTemplate.call(this);
  }
  const selectedTagObj = this.resolvedSpec.tags[0];
  const selectedPathObj = selectedTagObj && selectedTagObj.paths[0];
  return selectedTagObj && selectedPathObj ? wrapFocusedTemplate(expandedEndpointBodyTemplate.call(this, selectedPathObj, selectedTagObj.name)) : wrapFocusedTemplate("");
}
function focusedTagBodyTemplate(tag) {
  return html`<h1 id="${tag.elementId}">${tag.name}</h1>`;
}
function focusedEndpointTemplate() {
  if (!this.explorerLocation || !this.resolvedSpec) {
    return void 0;
  }
  const focusElId = this.explorerLocation;
  let selectedPathObj = null;
  let selectedTagObj = null;
  let focusedTemplate;
  let i = 0;
  if (focusElId.startsWith("overview") && this.showInfo === "true") {
    focusedTemplate = overviewTemplate.call(this);
  } else if (focusElId === "auth" && this.allowAuthentication === "true") {
    focusedTemplate = securitySchemeTemplate.call(this);
  } else if (focusElId === "servers" && this.allowServerSelection === "true") {
    focusedTemplate = serverTemplate.call(this);
  } else if (focusElId === "section") {
    focusedTemplate = html` <section id="section" class="observe-me"> <slot name="custom-section"></slot> </section>`;
  } else if (focusElId.startsWith("cmp--") && !this.hideComponents) {
    focusedTemplate = componentsTemplate.call(this);
  } else if (focusElId.startsWith("tag--")) {
    const idToFocus = focusElId.indexOf("--", 4) > 0 ? focusElId.substring(0, focusElId.indexOf("--", 5)) : focusElId;
    selectedTagObj = this.resolvedSpec.tags.find((v) => v.elementId === idToFocus);
    if (selectedTagObj) {
      focusedTemplate = wrapFocusedTemplate.call(this, focusedTagBodyTemplate.call(this, selectedTagObj));
    } else {
      focusedTemplate = defaultContentTemplate.call(this);
    }
  } else {
    for (i = 0; i < this.resolvedSpec.tags.length; i += 1) {
      selectedTagObj = this.resolvedSpec.tags[i];
      selectedPathObj = this.resolvedSpec.tags[i].paths.find((v) => `${v.elementId}` === focusElId);
      if (selectedPathObj) {
        break;
      }
    }
    if (selectedPathObj) {
      focusedTemplate = wrapFocusedTemplate.call(this, expandedEndpointBodyTemplate.call(this, selectedPathObj, selectedTagObj.name));
    } else {
      focusedTemplate = defaultContentTemplate.call(this);
    }
  }
  return focusedTemplate;
}

// node_modules/openapi-explorer/dist/es/templates/endpoint-template.js
function toggleExpand(path) {
  if (path.expanded) {
    path.expanded = false;
    replaceState(null);
  } else {
    path.expanded = true;
    if (path.elementId !== getCurrentElement()) {
      replaceState(path.elementId);
    }
  }
  this.requestUpdate();
}
function toggleTag(tagElement, tagId) {
  const sectionTag = tagElement.target.closest(".section-tag");
  const tag = this.resolvedSpec.tags.find((t) => t.elementId === tagId);
  tag.expanded = !tag.expanded;
  if (tag.expanded) {
    sectionTag.classList.remove("collapsed");
    sectionTag.classList.add("expanded");
  } else {
    sectionTag.classList.remove("expanded");
    sectionTag.classList.add("collapsed");
  }
  this.requestUpdate();
}
function expandCollapseAll(currentElement, action = "expand-all") {
  const operationsRootEl = currentElement.target.closest(".operations-root");
  const elList = [...operationsRootEl.querySelectorAll(".section-tag")];
  const expand = action === "expand-all";
  this.resolvedSpec.tags.forEach((t) => t.expanded = expand);
  elList.map((el) => {
    if (expand) {
      el.classList.remove("collapsed");
      el.classList.add("expanded");
    } else {
      el.classList.remove("expanded");
      el.classList.add("collapsed");
    }
  });
}
function endpointHeadTemplate(path) {
  return html` <summary @click="${(e) => {
    toggleExpand.call(this, path, e);
  }}" class="endpoint-head ${path.method} ${path.expanded ? "expanded" : "collapsed"}"> <div class="method ${path.method}"> ${path.method} </div> <div class="path"> ${path.path} ${path.isWebhook ? html`<span style="color:var(--primary-color)"> (Webhook) </span>` : ""} </div> ${path.deprecated ? html` <span style="font-size:var(--font-size-small);text-transform:uppercase;font-weight:700;color:var(--red);margin:2px 0 0 5px"> deprecated </span>` : ""} <div class="only-large-screen" style="min-width:60px;flex:1"></div> <div class="descr">${path.summary || path.shortSummary} </div> </summary> `;
}
function endpointBodyTemplate(path) {
  const acceptContentTypes = /* @__PURE__ */ new Set();
  for (const respStatus in path.responses) {
    for (const acceptContentType in path.responses[respStatus] && path.responses[respStatus].content) {
      acceptContentTypes.add(acceptContentType.trim());
    }
  }
  const accept = [...acceptContentTypes].join(", ");
  const nonEmptyApiKeys = this.resolvedSpec.securitySchemes.filter((v) => v.finalKeyValue && path.security && path.security.some((ps) => ps[v.apiKeyId])) || [];
  const codeSampleTabPanel = path.xCodeSamples ? codeSamplesTemplate(path.xCodeSamples) : "";
  return html` <div class="endpoint-body ${path.method}"> <div class="summary"> ${path.summary ? html`<div class="title">${path.summary}<div></div></div>` : path.shortSummary !== path.description ? html`<div class="title">${path.shortSummary}</div>` : ""} ${path.description ? html`<div class="m-markdown"> ${unsafeHTML(marked(path.description))}</div>` : ""} <slot name="${path.elementId}"></slot> ${pathSecurityTemplate.call(this, path.security)} ${codeSampleTabPanel} </div> <div class="req-resp-container"> <div style="display:flex;flex-direction:column" class="request"> <api-request class="request-panel" style="width:100%" method="${path.method}" , path="${path.path}" .parameters="${path.parameters}" .request_body="${path.requestBody}" .api_keys="${nonEmptyApiKeys}" .servers="${path.servers}" server-url="${path.servers && path.servers.length > 0 ? path.servers[0].url : this.selectedServer.computedUrl}" active-schema-tab="${this.defaultSchemaTab}" fill-defaults="${this.fillRequestWithDefault}" enable-console="${this.allowTry}" accept="${accept}" render-style="${this.renderStyle}" schema-style="${this.displaySchemaAsTable ? "table" : "tree"}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-read-only="${this.schemaHideReadOnly}" fetch-credentials="${this.fetchCredentials}" exportparts="btn btn-fill btn-outline btn-try"> </api-request> </div> ${path.callbacks ? callbackTemplate.call(this, path.callbacks) : ""} <api-response class="request response" .responses="${path.responses}" active-schema-tab="${this.defaultSchemaTab}" render-style="${this.renderStyle}" schema-style="${this.displaySchemaAsTable ? "table" : "tree"}" schema-expand-level="${this.schemaExpandLevel}" schema-description-expanded="${this.schemaDescriptionExpanded}" schema-hide-write-only="${this.schemaHideWriteOnly}" selected-status="${Object.keys(path.responses || {})[0] || ""}" exportparts="btn--resp btn-fill--resp btn-outline--resp"> </api-response> </div> </div>`;
}
function endpointTemplate() {
  return html` <div style="display:flex;justify-content:flex-end;padding-right:1rem;font-size:14px;margin-top:16px"> <span @click="${(e) => expandCollapseAll.call(this, e, "expand-all")}" style="color:var(--primary-color);cursor:pointer">Expand</span> &nbsp;|&nbsp; <span @click="${(e) => expandCollapseAll.call(this, e, "collapse-all")}" style="color:var(--primary-color);cursor:pointer">Collapse</span> </div> ${(this.resolvedSpec && this.resolvedSpec.tags || []).map((tag) => html` <div class="regular-font method-section-gap section-tag ${tag.expanded ? "expanded" : "collapsed"}"> <div class="section-tag-header" @click="${(e) => toggleTag.call(this, e, tag.elementId)}"> <div id="${tag.elementId}" class="sub-title tag" style="color:var(--primary-color)">${tag.name}</div> </div> <div class="section-tag-body"> <slot name="${tag.elementId}"></slot> ${tag.description ? `html
          <div class="regular-font regular-font-size m-markdown" style="padding-bottom:12px">
            ${unsafeHTML(marked(tag.description || ""))}
          </div>` : ""} ${tag.paths.filter((v) => {
    if (this.matchPaths) {
      return pathIsInSearch(this.matchPaths, v);
    }
    return true;
  }).map((path) => html` <section id="${path.elementId}" class="m-endpoint regular-font ${path.method} ${path.expanded ? "expanded" : "collapsed"}"> ${endpointHeadTemplate.call(this, path)} ${path.expanded ? endpointBodyTemplate.call(this, path) : ""} </section>`)} </div> </div> `)}`;
}

// node_modules/openapi-explorer/dist/es/templates/navbar-template.js
function onExpandCollapse(tagId) {
  const tag = this.resolvedSpec.tags.find((t) => t.elementId === tagId);
  if (!tag) {
    return;
  }
  tag.expanded = !tag.expanded;
  if (tag.expanded && this.operationsCollapsed) {
    this.resolvedSpec.tags.filter((t) => t.elementId !== tagId).forEach((t) => t.expanded = false);
  }
  this.requestUpdate();
}
function expandCollapseAll2() {
  const expand = this.operationsCollapsed;
  this.operationsCollapsed = !expand;
  this.resolvedSpec.tags.forEach((t) => {
    t.expanded = expand;
  });
}
function navbarTemplate() {
  return html` <nav class="nav-bar ${this.renderStyle}" part="section-navbar"> ${this.allowSearch === "false" && this.allowAdvancedSearch === "false" ? "" : html` <div style="display:flex;flex-direction:row;justify-content:center;align-items:center;padding:24px;${this.allowAdvancedSearch === "false" ? "border-bottom: 1px solid var(--nav-hover-bg-color)" : ""}"> ${this.allowSearch === "false" ? "" : html` <div style="display:flex;flex:1;line-height:22px"> <input id="nav-bar-search" part="textbox textbox-nav-filter" style="width:100%;padding-right:20px;color:var(--nav-hover-text-color);border-color:var(--secondary-color);background-color:var(--nav-hover-bg-color)" type="text" placeholder="Filter" @change="${this.onSearchChange}" spellcheck="false"> <div style="margin:6px 5px 0 -24px;font-size:var(--font-size-regular);cursor:pointer">&#x21a9;</div> </div> ${this.matchPaths ? html` <div @click="${this.onClearSearch}" style="margin-left:5px;cursor:pointer;align-self:center;color:var(--nav-text-color)" class="small-font-size primary-text bold-text"> CLEAR </div>` : ""} `} ${this.allowAdvancedSearch === "false" || this.matchPaths ? "" : html` <button class="m-btn primary" part="btn btn-fill btn-search" style="margin-left:5px" @click="${this.onShowSearchModalClicked}"> Search </button> `} </div> `} ${html`<nav class="nav-scroll" part="navbar-scroll"> ${this.showInfo === "false" || !this.resolvedSpec.info ? "" : html`<div class="nav-bar-info" id="link-overview" data-content-id="overview" @click="${(e) => this.scrollToEventTarget(e, false)}"> ${this.isV1 && this.resolvedSpec.info.title || "Overview"} </div>`} ${this.allowServerSelection === "false" ? "" : html`<div class="nav-bar-info" id="link-servers" data-content-id="servers" @click="${(e) => this.scrollToEventTarget(e, false)}"> API Servers </div>`} ${this.allowAuthentication === "false" || !this.resolvedSpec.securitySchemes ? "" : html`<div class="nav-bar-info" id="link-auth" data-content-id="auth" @click="${(e) => this.scrollToEventTarget(e, false)}"> Authentication </div>`} <slot name="nav-section" class="custom-nav-section" data-content-id="section" @click="${(e) => this.scrollToEventTarget(e, false)}"></slot> <div class="sticky-scroll-element"> <div class="nav-bar-section" part="navbar-operations-header"> <slot name="operations-header"> <div class="nav-bar-section-title">OPERATIONS</div> </slot> <div style="" part="navbar-operations-header-collapse"> ${this.resolvedSpec.tags.length > 1 ? html` ${this.operationsCollapsed ? html`<div @click="${(e) => {
    expandCollapseAll2.call(this, e);
  }}" style="font-size:16px;transform:rotate(0);cursor:pointer">▸</div>` : html`<div @click="${(e) => {
    expandCollapseAll2.call(this, e);
  }}" style="font-size:16px;transform:rotate(90deg);cursor:pointer">▸</div>`}` : ""} </div> </div> </div> ${this.resolvedSpec.tags.filter((tag) => tag.paths.filter((path) => pathIsInSearch(this.matchPaths, path)).length).map((tag) => html` <slot name="nav-${tag.elementId}"> <div class="nav-bar-tag-and-paths ${tag.expanded ? "expanded" : "collapsed"}"> ${tag.name === "General \u2982" ? html`` : html` <div class="nav-bar-tag" id="link-${tag.elementId}" data-content-id="${tag.elementId}" @click="${() => {
    onExpandCollapse.call(this, tag.elementId);
  }}"> <div style="display:flex;justify-content:space-between;width:100%"> <div>${tag.name}</div> <div class="nav-bar-tag-icon expand-button-arrow">▸</div> <div class="nav-bar-tag-icon collapse-button-arrow">▾</div> </div> </div> `} <div class="nav-bar-paths-under-tag"> ${tag.paths.filter((v) => {
    if (this.matchPaths) {
      return pathIsInSearch(this.matchPaths, v);
    }
    return true;
  }).map((p) => html` <div class="nav-bar-path ${this.usePathInNavBar === "true" ? "small-font" : ""}" data-content-id="${p.elementId}" id="link-${p.elementId}" @click="${(e) => {
    this.scrollToEventTarget(e, false);
  }}"> <span style="line-break:anywhere;${p.deprecated ? "filter:opacity(0.5)" : ""}"> ${this.usePathInNavBar === "true" ? html`<span class="mono-font">${p.method.toUpperCase()} ${p.path}</span>` : p.summary || p.shortSummary} ${p.isWebhook ? "(Webhook)" : ""} </span> </div>`)} </div> </div> </slot> `)} ${this.resolvedSpec.components && !this.hideComponents ? html` <div class="sticky-scroll-element"> <div id="link-components" class="nav-bar-section"> <div class="nav-bar-section-title">COMPONENTS</div> </div> </div> ${this.resolvedSpec.components.map((component) => component.subComponents.filter((s) => s.expanded).length ? html` <div class="nav-bar-tag" data-content-id="cmp--${component.name.toLowerCase()}" id="link-cmp--${component.name.toLowerCase()}" @click="${(e) => this.scrollToEventTarget(e, false)}"> ${component.name} </div> ${component.subComponents.filter((s) => s.expanded).map((p) => html` <div class="nav-bar-path" data-content-id="cmp--${p.id}" id="link-cmp--${p.id}" @click="${(e) => this.scrollToEventTarget(e, false)}"> <span> ${p.name} </span> </div>`)}` : "")}` : ""} </nav>`} </nav> `;
}

// node_modules/openapi-explorer/dist/es/templates/advance-search-template.js
function searchByPropertiesModalTemplate() {
  const keyDownEventListenerAdvancedSearch = (e) => {
    if ((e.detail && e.detail.code || e.code) === "Escape") {
      this.showAdvancedSearchDialog = false;
    }
  };
  const closeAdvancedSearchDialog = () => {
    document.dispatchEvent(new CustomEvent("keydown", {
      detail: {
        code: "Escape"
      }
    }));
    document.removeEventListener("keydown", keyDownEventListenerAdvancedSearch, {
      once: true
    });
  };
  document.addEventListener("keydown", keyDownEventListenerAdvancedSearch, {
    once: true
  });
  return html` ${this.showAdvancedSearchDialog ? html` <div class="dialog-box-overlay"> <div class="dialog-box"> <header class="dialog-box-header"> <span class="dialog-box-title">Advanced Search</span> <button class="m-btn thin-border" @click="${() => {
    closeAdvancedSearchDialog();
  }}" part="btn btn-outline">&times;</button> </header> <div id="advanced-search-modal" class="dialog-box-content"> <span class="advanced-search-options"> <div class="advanced-search-dialog-input"> <input id="advanced-search-dialog-input" type="text" part="textbox textbox-search-dialog" placeholder="search text..." spellcheck="false" @keyup="${(e) => this.onAdvancedSearch(e, 400)}"> </div> <div class="advanced-search-locations"> <div> <input style="cursor:pointer" type="checkbox" part="checkbox checkbox-search-dialog" id="search-api-path" checked="checked" @change="${(e) => this.onAdvancedSearch(e, 0)}"> <label style="cursor:pointer" for="search-api-path"> API Path </label> </div> <div> <input style="cursor:pointer" type="checkbox" part="checkbox checkbox-search-dialog" id="search-api-descr" checked="checked" @change="${(e) => this.onAdvancedSearch(e, 0)}"> <label style="cursor:pointer" for="search-api-descr"> API Description </label> </div> <div> <input style="cursor:pointer" type="checkbox" part="checkbox checkbox-search-dialog" id="search-api-params" @change="${(e) => this.onAdvancedSearch(e, 0)}"> <label style="cursor:pointer" for="search-api-params"> Request Parameters </label> </div> <div> <input style="cursor:pointer" type="checkbox" part="checkbox checkbox-search-dialog" id="search-api-request-body" @change="${(e) => this.onAdvancedSearch(e, 0)}"> <label style="cursor:pointer" for="search-api-request-body"> Request Body </label> </div> <div> <input style="cursor:pointer" type="checkbox" part="checkbox checkbox-search-dialog" id="search-api-resp-descr" @change="${(e) => this.onAdvancedSearch(e, 0)}"> <label style="cursor:pointer" for="search-api-resp-descr"> Response Description </label> </div> </div> </span> <div class="advanced-search-results"> ${this.advancedSearchMatches && this.advancedSearchMatches.map((path) => html` <div class="mono-font small-font-size hover-bg" tabindex="0" style="padding:5px;cursor:pointer;border-bottom:1px solid var(--light-border-color);${path.deprecated ? "filter:opacity(0.5);" : ""}" data-content-id="${path.elementId}" @click="${(e) => {
    this.matchPaths = "";
    closeAdvancedSearchDialog();
    this.requestUpdate();
    this.scrollToEventTarget(e, true);
  }}"> <span class="upper bold-text method-fg ${path.method}">${path.method}</span> <span>${path.path}</span> - <span class="regular-font gray-text">${path.summary}</span> </div> `)} </div> </div> </div> </div>` : ""}`;
}

// node_modules/openapi-explorer/dist/es/utils/theme.js
var import_color = __toESM(require_color());

// node_modules/openapi-explorer/dist/es/utils/color-utils.js
var color_utils_default = {
  color: {
    inputReverseFg: "#fff",
    inputReverseBg: "#333",
    headerBg: "#444",
    getRgb(hexStr) {
      let hex = (hexStr || "").trim();
      if (hex.indexOf("#") === 0) {
        hex = hex.slice(1, 7);
      }
      if (hex.length === 3 || hex.length === 4) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      if (hex.length !== 6) {
        console.error(`Invalid HEX color: '${hexStr}'`);
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16)
      };
    },
    luminanace(hexColorCode) {
      const rgb = this.getRgb(hexColorCode);
      return rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114;
    },
    invert(hexColorCode) {
      return this.luminanace(hexColorCode) > 149 ? "#000000" : "#ffffff";
    },
    selectTextColorFromBackground(bcHexColor) {
      const {
        r,
        g,
        b
      } = this.getRgb(bcHexColor);
      const colors = [r / 255, g / 255, b / 255];
      const c = colors.map((col) => {
        if (col <= 0.03928) {
          return col / 12.92;
        }
        return ((col + 0.055) / 1.055) ** 2.4;
      });
      const L = 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];
      return L > 0.179 ? "#000000" : "#FFFFFF";
    },
    opacity(hex, opacity) {
      const rgb = this.getRgb(hex);
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
    },
    brightness(hex, amt) {
      const rgb = this.getRgb(hex);
      rgb.r += amt;
      rgb.g += amt;
      rgb.b += amt;
      if (rgb.r > 255) {
        rgb.r = 255;
      } else if (rgb.r < 0) {
        rgb.r = 0;
      }
      if (rgb.g > 255) {
        rgb.g = 255;
      } else if (rgb.g < 0) {
        rgb.g = 0;
      }
      if (rgb.b > 255) {
        rgb.b = 255;
      } else if (rgb.b < 0) {
        rgb.b = 0;
      }
      return `#${rgb.r.toString(16).padStart(2, "0")}${rgb.g.toString(16).padStart(2, "0")}${rgb.b.toString(16).padStart(2, "0")}`;
    }
  },
  isValidHexColor(colorCode) {
    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}|[A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/i.test(colorCode);
  }
};

// node_modules/openapi-explorer/dist/es/utils/theme.js
function setTheme(theme = {}) {
  const bg1 = theme.bg1 ? theme.bg1 : "#ffffff";
  const fg1 = theme.fg1 ? theme.fg1 : "#444444";
  const bg2 = theme.bg2 ? theme.bg2 : color_utils_default.color.brightness(bg1, -5);
  const bg3 = theme.bg3 ? theme.bg3 : color_utils_default.color.brightness(bg1, -15);
  const lightBg = theme.bg3 ? theme.bg3 : color_utils_default.color.brightness(bg1, -45);
  const fg2 = theme.fg2 ? theme.fg2 : color_utils_default.color.brightness(fg1, 17);
  const fg3 = theme.fg3 ? theme.fg3 : color_utils_default.color.brightness(fg1, 30);
  const lightFg = theme.fg3 ? theme.fg3 : color_utils_default.color.brightness(fg1, 70);
  const inlineCodeFg = theme.inlineCodeFg ? theme.inlineCodeFg : "brown";
  const selectionBg = "#444";
  const selectionFg = "#eee";
  const headerColor = theme.headerColor ? theme.headerColor : color_utils_default.color.brightness(bg1, -180);
  const navBgColor = theme.navBgColor ? theme.navBgColor : color_utils_default.color.brightness(bg1, -180);
  const navTextColor = theme.navTextColor ? theme.navTextColor : color_utils_default.color.opacity(color_utils_default.color.invert(navBgColor), "0.65");
  const navHoverBgColor = theme.navHoverBgColor ? theme.navHoverBgColor : color_utils_default.color.brightness(navBgColor, -15);
  const navHoverTextColor = theme.navHoverTextColor ? theme.navHoverTextColor : color_utils_default.color.invert(navBgColor);
  const overlayBg = "rgba(0, 0, 0, 0.4)";
  const defaultColors = [`--purple: ${getComputedStyle(this).getPropertyValue("--purple").trim() || "#6f42c1"}`, `--red: ${getComputedStyle(this).getPropertyValue("--red").trim() || "#dc3545"}`, `--orange: ${getComputedStyle(this).getPropertyValue("--orange").trim() || "#fd7e14"}`, `--yellow: ${getComputedStyle(this).getPropertyValue("--yellow").trim() || "#ffc107"}`, `--green: ${getComputedStyle(this).getPropertyValue("--green").trim() || "#28a745"}`, `--blue: ${getComputedStyle(this).getPropertyValue("--blue").trim() || "#38b3f9"}`, "--pink: #e83e8c", "--white: #fff", ""];
  const lightColors = [`--light-purple: ${(0, import_color.default)(getComputedStyle(this).getPropertyValue("--purple").trim() || "#6f42c1").lightness(96).hex()}`, `--light-red: ${(0, import_color.default)(getComputedStyle(this).getPropertyValue("--red").trim() || "#dc3545").lightness(96).hex()}`, `--light-orange: ${(0, import_color.default)(getComputedStyle(this).getPropertyValue("--orange").trim() || "#fd7e14").lightness(96).hex()}`, `--light-yellow: ${(0, import_color.default)(getComputedStyle(this).getPropertyValue("--yellow").trim() || "#ffc107").lightness(96).hex()}`, `--light-green: ${(0, import_color.default)(getComputedStyle(this).getPropertyValue("--green").trim() || "#28a745").lightness(96).hex()}`, `--light-blue: ${(0, import_color.default)(getComputedStyle(this).getPropertyValue("--blue").trim() || "#38b3f9").lightness(96).hex()}`, ""];
  const newTheme = {
    bg1,
    bg2,
    bg3,
    lightBg,
    fg1,
    fg2,
    fg3,
    lightFg,
    inlineCodeFg,
    selectionBg,
    selectionFg,
    overlayBg,
    navBgColor,
    navTextColor,
    navHoverBgColor,
    navHoverTextColor,
    headerColor,
    headerColorInvert: color_utils_default.color.invert(headerColor),
    headerColorDarker: color_utils_default.color.brightness(headerColor, -20),
    headerColorBorder: color_utils_default.color.brightness(headerColor, 10),
    borderColor: theme.borderColor || color_utils_default.color.brightness(bg1, -38),
    lightBorderColor: theme.lightBorderColor || color_utils_default.color.brightness(bg1, -23),
    codeBorderColor: theme.codeBorderColor || "transparent",
    inputBg: theme.inputBg || color_utils_default.color.brightness(bg1, 10),
    placeHolder: theme.placeHolder || color_utils_default.color.brightness(lightFg, 20),
    hoverColor: theme.hoverColor || color_utils_default.color.brightness(bg1, -5),
    codeBg: theme.codeBg || color_utils_default.color.opacity(color_utils_default.color.brightness(bg1, -15), 0.7),
    codeFg: theme.codeFg || "#666",
    codePropertyColor: theme.codePropertyColor || "#905",
    codeKeywordColor: theme.codeKeywordColor || "#07a",
    codeOperatorColor: theme.codeOperatorColor || "#9a6e3a"
  };
  return html` <style>*,:after,:before{box-sizing:border-box}:host{--border-radius:2px;--layout:${this.layout || "column"};--nav-item-padding:${this.navItemSpacing === "relaxed" ? "10px" : this.navItemSpacing === "compact" ? "5px 10px" : "7px 10px"};--resp-area-height:${this.responseAreaHeight};--font-size-small:${this.fontSize === "default" ? "12px" : this.fontSize === "large" ? "13px" : "14px"};--font-size-mono:${this.fontSize === "default" ? "13px" : this.fontSize === "large" ? "14px" : "15px"};--font-size-regular:${this.fontSize === "default" ? "14px" : this.fontSize === "large" ? "15px" : "16px"};--dialog-z-index:1000;--bg:${newTheme.bg1};--bg2:${newTheme.bg2};--bg3:${newTheme.bg3};--light-bg:${newTheme.lightBg};--fg:${newTheme.fg1};--fg2:${newTheme.fg2};--fg3:${newTheme.fg3};--light-fg:${newTheme.lightFg};--selection-bg:${newTheme.selectionBg};--selection-fg:${newTheme.selectionFg};--overlay-bg:${newTheme.overlayBg};--border-color:${newTheme.borderColor};--light-border-color:${newTheme.lightBorderColor};--code-border-color:${newTheme.codeBorderColor};--input-bg:${newTheme.inputBg};--placeholder-color:${newTheme.placeHolder};--hover-color:${newTheme.hoverColor};${defaultColors.join(";\n")} ${lightColors.join(";\n")} --header-bg:${newTheme.headerColor};--header-fg:${newTheme.headerColorInvert};--header-color-darker:${newTheme.headerColorDarker};--header-color-border:${newTheme.headerColorBorder};--nav-bg-color:${newTheme.navBgColor};--nav-text-color:${newTheme.navTextColor};--nav-hover-bg-color:${newTheme.navHoverBgColor};--nav-hover-text-color:${newTheme.navHoverTextColor};--code-bg:${newTheme.codeBg};--code-fg:${newTheme.codeFg};--inline-code-fg:${newTheme.inlineCodeFg};--code-property-color:${newTheme.codePropertyColor};--code-keyword-color:${newTheme.codeKeywordColor};--code-operator-color:${newTheme.codeOperatorColor};--primary-color:${theme.primaryColor};--secondary-color:${theme.secondaryColor};--primary-btn-text-color:${color_utils_default.color.selectTextColorFromBackground(theme.primaryColor)}}</style>`;
}

// node_modules/openapi-explorer/dist/es/templates/responsiveViewMainBodyTemplate.js
function responsiveViewMainBodyTemplate() {
  const newTheme = {
    bg1: color_utils_default.isValidHexColor(this.bgColor) ? this.bgColor : "",
    fg1: color_utils_default.isValidHexColor(this.textColor) ? this.textColor : "",
    primaryColor: color_utils_default.isValidHexColor(this.primaryColor) ? this.primaryColor : "#3E6077",
    secondaryColor: color_utils_default.isValidHexColor(this.secondaryColor) ? this.secondaryColor : "#FBAF0B",
    headerColor: color_utils_default.isValidHexColor(this.headerColor) ? this.headerColor : "",
    navBgColor: color_utils_default.isValidHexColor(this.navBgColor) ? this.navBgColor : "",
    navTextColor: color_utils_default.isValidHexColor(this.navTextColor) ? this.navTextColor : "",
    navHoverBgColor: color_utils_default.isValidHexColor(this.navHoverBgColor) ? this.navHoverBgColor : "",
    navHoverTextColor: color_utils_default.isValidHexColor(this.navHoverTextColor) ? this.navHoverTextColor : ""
  };
  return html` ${setTheme.call(this, newTheme)} ${this.allowAdvancedSearch === "false" ? "" : searchByPropertiesModalTemplate.call(this)} <div id="the-main-body" class="body"> ${this.renderStyle === "focused" && this.resolvedSpec ? navbarTemplate.call(this) : ""} ${this.loading === true ? html`<slot name="loader"><div class="loader"></div></slot>` : html` <main class="main-content regular-font" part="section-main-content"> <slot></slot> <div id="operations-root" class="main-content-inner"> ${this.loadFailed === true ? html`<div style="text-align:center;margin:16px">Unable to load the Spec${this.specUrl ? ": " : ""}<strong>${this.specUrl}</strong></div>` : html` <div class="operations-root" @click="${(e) => {
    this.handleHref(e);
  }}"> ${this.renderStyle === "focused" ? html`${focusedEndpointTemplate.call(this)}` : html` ${this.showInfo === "true" ? overviewTemplate.call(this) : ""} ${this.allowServerSelection === "true" ? serverTemplate.call(this) : ""} ${this.allowAuthentication === "true" ? securitySchemeTemplate.call(this) : ""} <section id="section" class="observe-me ${this.renderStyle === "focused" ? "section-gap--focused-mode" : "section-gap"}"> <slot name="custom-section"></slot> </section> ${endpointTemplate.call(this)}`} </div> `}</div></main>`} </div> <slot name="footer"></slot> `;
}

// node_modules/openapi-explorer/dist/es/styles/api-request-styles.js
var api_request_styles_default = css`.api-request,.api-request *,.api-request :after,.api-request :before,.api-request:after,.api-request:before{box-sizing:border-box}.api-request.focused-mode,.api-request.read-mode{padding-top:24px;margin-top:12px;border-top:1px dashed var(--border-color)}.api-request .param-name,.api-request .param-type{margin:1px 0;text-align:right;line-height:var(--font-size-small)}.api-request .param-name{color:var(--fg);font-family:var(--font-mono)}.api-request .param-name.deprecated{text-decoration:line-through}.api-request .param-type{color:var(--light-fg);font-family:var(--font-regular)}.api-request .param-constraint{min-width:100px}.api-request .param-constraint:empty{display:none}.api-request .top-gap{margin-top:24px}.api-request .textarea{min-height:220px;padding:5px;resize:vertical}.api-request .response-message{font-weight:700;text-overflow:ellipsis}.api-request .response-message.error{color:var(--red)}.api-request .response-message.success{color:var(--blue)}.api-request .file-input-container{align-items:flex-end}.api-request .file-input-container .input-set:first-child .file-input-remove-btn{visibility:hidden}.api-request .file-input-remove-btn{font-size:16px;color:var(--red);outline:0;border:none;background:0 0;cursor:pointer}.api-request .v-tab-btn{font-size:var(--smal-font-size);height:24px;border:none;background:0 0;opacity:.3;cursor:pointer;padding:4px 8px}.api-request .v-tab-btn.active{font-weight:700;background:var(--bg);opacity:1}.api-request .border-top{border-top:1px solid var(--border-color)}.api-request .border{border:1px solid var(--border-color);border-radius:var(--border-radius)}.api-request .light-border{border:1px solid var(--light-border-color);border-radius:var(--border-radius)}.api-request .pad-8-16{padding:8px 16px}.api-request .pad-top-8{padding-top:8px}.api-request .mar-top-8{margin-top:8px}@media only screen and (min-width:768px){.api-request .textarea{padding:8px}}`;

// node_modules/openapi-explorer/dist/es/openapi-explorer-oauth-handler.js
var OpenapiExplorerOauthHandler = class extends HTMLElement {
  connectedCallback() {
    checkForAuthToken(true);
  }
};
if (!customElements.get("openapi-explorer-oauth-handler")) {
  customElements.define("openapi-explorer-oauth-handler", OpenapiExplorerOauthHandler);
}

// node_modules/openapi-explorer/dist/es/openapi-explorer.js
var OpenApiExplorer = class extends LitElement {
  constructor() {
    super();
    this.isV1 = false;
    this.loading = true;
    const intersectionObserverOptions = {
      root: this.getRootNode().host,
      rootMargin: "-50px 0px -50px 0px",
      threshold: 0
    };
    this.isIntersectionObserverActive = true;
    if (typeof IntersectionObserver !== "undefined") {
      this.intersectionObserver = new IntersectionObserver((entries) => {
        this.onIntersect(entries);
      }, intersectionObserverOptions);
    } else {
      this.intersectionObserver = {
        disconnect() {
        },
        observe() {
        }
      };
    }
  }
  static get properties() {
    return {
      headingText: {
        type: String,
        attribute: "heading-text"
      },
      explorerLocation: {
        type: String,
        attribute: "explorer-location"
      },
      specUrl: {
        type: String,
        attribute: "spec-url"
      },
      layout: {
        type: String
      },
      operationsCollapsed: {
        type: Boolean,
        attribute: "collapse"
      },
      defaultSchemaTab: {
        type: String,
        attribute: "default-schema-tab"
      },
      responseAreaHeight: {
        type: String,
        attribute: "response-area-height"
      },
      fillRequestWithDefault: {
        type: String,
        attribute: "fill-defaults"
      },
      displaySchemaAsTable: {
        type: Boolean,
        attribute: "table"
      },
      schemaExpandLevel: {
        type: Number,
        attribute: "schema-expand-level"
      },
      schemaDescriptionExpanded: {
        type: String
      },
      serverUrl: {
        type: String,
        attribute: "server-url"
      },
      showInfo: {
        type: String,
        attribute: "show-info"
      },
      allowAuthentication: {
        type: String,
        attribute: "show-authentication"
      },
      allowTry: {
        type: String,
        attribute: "enable-console"
      },
      allowSearch: {
        type: String,
        attribute: "allow-search"
      },
      allowAdvancedSearch: {
        type: String,
        attribute: "allow-advanced-search"
      },
      allowServerSelection: {
        type: String,
        attribute: "show-server-selection"
      },
      hideComponents: {
        type: Boolean,
        attribute: "hide-components"
      },
      primaryColor: {
        type: String,
        attribute: "primary-color"
      },
      secondaryColor: {
        type: String,
        attribute: "secondary-color"
      },
      bgColor: {
        type: String,
        attribute: "bg-color"
      },
      textColor: {
        type: String,
        attribute: "text-color"
      },
      headerColor: {
        type: String,
        attribute: "header-color"
      },
      fontSize: {
        type: String,
        attribute: "font-size"
      },
      navBgColor: {
        type: String,
        attribute: "nav-bg-color"
      },
      navTextColor: {
        type: String,
        attribute: "nav-text-color"
      },
      navHoverBgColor: {
        type: String,
        attribute: "nav-hover-bg-color"
      },
      navHoverTextColor: {
        type: String,
        attribute: "nav-hover-text-color"
      },
      navItemSpacing: {
        type: String,
        attribute: "nav-item-spacing"
      },
      usePathInNavBar: {
        type: String,
        attribute: "use-path-in-nav-bar"
      },
      fetchCredentials: {
        type: String,
        attribute: "fetch-credentials"
      },
      matchPaths: {
        type: String,
        attribute: "match-paths"
      },
      loading: {
        type: Boolean
      },
      showAdvancedSearchDialog: {
        type: Boolean
      },
      advancedSearchMatches: {
        type: Object
      }
    };
  }
  static get styles() {
    return [font_styles_default, input_styles_default, flex_styles_default, table_styles_default, endpoint_styles_default, prism_styles_default, tab_styles_default, nav_styles_default, info_styles_default, advanced_search_styles_default, api_request_styles_default, css`:not(:defined){display:none}:host{display:flex;flex-direction:column;width:100%;height:100%;margin:0;padding:0;overflow:hidden;letter-spacing:normal;color:var(--fg);background-color:var(--bg);font-family:var(--font-regular)}.body{display:flex;height:100%;width:100%;overflow:hidden}.main-content{margin:0;padding:0;display:block;flex:1;height:100%;overflow-y:overlay;overflow-x:hidden;scrollbar-width:thin;scrollbar-color:var(--border-color) transparent}.main-content::-webkit-scrollbar{width:8px;height:8px}.main-content::-webkit-scrollbar-track{background:0 0}.main-content::-webkit-scrollbar-thumb{background-color:var(--border-color)}.section-gap.section-tag{border-bottom:1px solid var(--border-color)}.method-section-gap{padding:24px 8px 0 4px}.section-gap{padding:24px 0 0}.section-tag-header{position:relative;cursor:n-resize;padding:12px 0}.collapsed .section-tag-header:hover{cursor:s-resize}.section-tag-header:hover{background-image:linear-gradient(to right,rgba(0,0,0,0),var(--border-color),rgba(0,0,0,0))}.collapsed .section-tag-header:hover::after{color:var(--primary-color)}.collapsed .section-tag-body{display:none}.logo{height:36px;width:36px;margin-left:5px}.only-large-screen,.only-large-screen-flex{display:none}.header-title{font-size:calc(var(--font-size-regular) + 8px);padding:0 8px}.tag.title{text-transform:uppercase}.header{background-color:var(--header-bg);color:var(--header-fg);width:100%}input.header-input{background:var(--header-color-darker);color:var(--header-fg);border:1px solid var(--header-color-border);flex:1;padding-right:24px;border-radius:3px}input.header-input::placeholder{opacity:.4}input:disabled{cursor:not-allowed}.loader{margin:16px auto 16px auto;border:4px solid var(--bg3);border-radius:50%;border-top:4px solid var(--primary-color);width:36px;height:36px;animation:spin 2s linear infinite}.expanded-endpoint-body{position:relative;padding:6px 0}.divider{border-top:2px solid var(--border-color);margin:24px 0;width:100%}.tooltip{border:1px solid var(--border-color);border-left-width:4px;margin-left:2px}.tooltip a{color:var(--fg2);text-decoration:none}.tooltip-text{color:var(--fg2);background-color:var(--bg2);visibility:hidden;overflow-wrap:break-word}.tooltip:hover{color:var(--primary-color);border-color:var(--primary-color)}.tooltip:hover a:hover{color:var(--primary-color)}.tooltip:hover .tooltip-text{visibility:visible;opacity:1}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@media only screen and (max-width:767.98px){.section-padding{margin:1rem}.sub-title.tag{margin-left:1rem}}@media only screen and (min-width:768px){.nav-bar{width:260px;display:flex}.only-large-screen{display:block}.only-large-screen-flex{display:flex}.section-gap{padding:24px 24px}.section-gap--read-mode{padding:24px 8px}.section-gap--focused-mode{padding:2rem 3rem}.endpoint-body{position:relative;padding:36px 0 48px 0}}@media only screen and (min-width:1024px){.nav-bar{width:${unsafeCSS(this.fontSize === "default" ? "300px" : this.fontSize === "large" ? "315px" : "330px")};display:flex}.section-gap--read-mode{padding:24px 24px 12px}.main-content-inner{padding:24px}}`];
  }
  connectedCallback() {
    super.connectedCallback();
    this.handleResize = this.handleResize.bind(this);
    window.addEventListener("resize", this.handleResize);
    this.loading = true;
    const parent = this.parentElement;
    if (parent) {
      if (parent.offsetWidth === 0 && parent.style.width === "") {
        parent.style.width = "100vw";
      }
      if (parent.offsetHeight === 0 && parent.style.height === "") {
        parent.style.height = "100vh";
      }
      if (parent.tagName === "BODY") {
        if (!parent.style.marginTop) {
          parent.style.marginTop = "0";
        }
        if (!parent.style.marginRight) {
          parent.style.marginRight = "0";
        }
        if (!parent.style.marginBottom) {
          parent.style.marginBottom = "0";
        }
        if (!parent.style.marginLeft) {
          parent.style.marginLeft = "0";
        }
      }
    }
    this.renderStyle = "focused";
    this.explorerLocation = this.explorerLocation || getCurrentElement();
    if (!this.defaultSchemaTab || !"body, model,".includes(`${this.defaultSchemaTab},`)) {
      this.defaultSchemaTab = "model";
    }
    if (!this.schemaExpandLevel || this.schemaExpandLevel < 1) {
      this.schemaExpandLevel = 99999;
    }
    if (!this.schemaDescriptionExpanded || !"true, false,".includes(`${this.schemaDescriptionExpanded},`)) {
      this.schemaDescriptionExpanded = "true";
    }
    this.schemaHideReadOnly = ["post", "put", "patch"].join(",");
    this.schemaHideWriteOnly = true;
    if (!this.fillRequestWithDefault || !"true, false,".includes(`${this.fillRequestWithDefault},`)) {
      this.fillRequestWithDefault = "true";
    }
    if (!this.responseAreaHeight) {
      this.responseAreaHeight = "300px";
    }
    if (!this.allowSearch || !"true, false,".includes(`${this.allowSearch},`)) {
      this.allowSearch = "true";
    }
    if (!this.allowAdvancedSearch || !"true, false,".includes(`${this.allowAdvancedSearch},`)) {
      this.allowAdvancedSearch = "true";
    }
    if (!this.allowTry || !"true, false,".includes(`${this.allowTry},`)) {
      this.allowTry = "true";
    }
    if (!this.navItemSpacing || !"compact, relaxed, default,".includes(`${this.navItemSpacing},`)) {
      this.navItemSpacing = "default";
    }
    if (!this.usePathInNavBar || !"true, false,".includes(`${this.usePathInNavBar},`)) {
      this.usePathInNavBar = "false";
    }
    if (!this.fontSize || !"default, large, largest,".includes(`${this.fontSize},`)) {
      this.fontSize = "default";
    }
    if (!this.showInfo || !"true, false,".includes(`${this.showInfo},`)) {
      this.showInfo = "true";
    }
    if (!this.allowServerSelection || !"true, false,".includes(`${this.allowServerSelection},`)) {
      this.allowServerSelection = "true";
    }
    if (!this.allowAuthentication || !"true, false,".includes(`${this.allowAuthentication},`)) {
      this.allowAuthentication = "true";
    }
    if (!this.fetchCredentials || !"omit, same-origin, include,".includes(`${this.fetchCredentials},`)) {
      this.fetchCredentials = "";
    }
    if (!this.showAdvancedSearchDialog) {
      this.showAdvancedSearchDialog = false;
    }
    marked.setOptions({
      highlight(code, lang) {
        if (import_prismjs3.default.languages[lang]) {
          return import_prismjs3.default.highlight(code, import_prismjs3.default.languages[lang], lang);
        }
        return code;
      }
    });
    window.addEventListener("hashchange", () => {
      this.scrollTo(getCurrentElement());
    }, true);
    this.handleResize();
  }
  disconnectedCallback() {
    this.intersectionObserver.disconnect();
    window.removeEventListener("resize", this.handleResize);
    super.disconnectedCallback();
  }
  render() {
    return responsiveViewMainBodyTemplate.call(this);
  }
  observeExpandedContent() {
    const observeOverviewEls = this.shadowRoot.querySelectorAll(".observe-me");
    observeOverviewEls.forEach((targetEl) => {
      this.intersectionObserver.observe(targetEl);
    });
  }
  handleResize() {
    const mediaQueryResult = window.matchMedia("(min-width: 768px)");
    const newDisplay = mediaQueryResult.matches ? "focused" : "view";
    if (this.renderStyle !== newDisplay) {
      this.renderStyle = newDisplay;
      this.requestUpdate();
    }
  }
  attributeChangedCallback(name, oldVal, newVal) {
    if (name === "spec-url") {
      if (oldVal !== newVal) {
        window.setTimeout(async () => {
          await this.loadSpec(newVal);
          if (this.explorerLocation) {
            this.scrollTo(this.explorerLocation);
          }
        }, 0);
      }
    }
    if (name === "render-style") {
      if (newVal === "read") {
        window.setTimeout(() => {
          this.observeExpandedContent();
        }, 100);
      } else {
        this.intersectionObserver.disconnect();
      }
    }
    if (name === "explorer-location") {
      window.setTimeout(() => {
        this.scrollTo(newVal);
      }, 0);
    }
    super.attributeChangedCallback(name, oldVal, newVal);
  }
  onSearchChange(e) {
    this.operationsCollapsed = false;
    this.matchPaths = e.target.value;
    this.resolvedSpec.tags.forEach((tag) => tag.paths.filter((v) => {
      if (this.matchPaths) {
        if (pathIsInSearch(this.matchPaths, v)) {
          tag.expanded = true;
        }
      }
    }));
    this.resolvedSpec.components.forEach((component) => {
      component.subComponents.forEach((subComponent) => {
        subComponent.expanded = false;
        if (!this.matchPaths || componentIsInSearch(this.matchPaths, subComponent)) {
          subComponent.expanded = true;
        }
      });
    });
    this.requestUpdate();
  }
  onClearSearch() {
    const searchEl = this.shadowRoot.getElementById("nav-bar-search");
    searchEl.value = "";
    this.matchPaths = "";
    this.resolvedSpec.components.forEach((component) => {
      component.subComponents.forEach((v) => {
        v.expanded = true;
      });
    });
  }
  async onShowSearchModalClicked() {
    this.showAdvancedSearchDialog = true;
    await sleep(10);
    const inputEl = this.shadowRoot.getElementById("advanced-search-dialog-input");
    if (inputEl) {
      inputEl.focus();
    }
  }
  async loadSpec(specUrlOrObject) {
    if (!specUrlOrObject) {
      return;
    }
    this.matchPaths = "";
    try {
      this.resolvedSpec = null;
      this.loading = true;
      this.loadFailed = false;
      const spec = await ProcessSpec(specUrlOrObject, this.serverUrl);
      this.loading = false;
      if (spec === void 0 || spec === null) {
        console.error("Unable to resolve the API spec. ");
        return;
      }
      if (!this.serverUrl) {
        this.serverUrl = spec.servers[0].computedUrl || spec.servers[0].url;
      }
      this.selectedServer = spec.servers.find((s) => s.url === this.serverUrl || !this.serverUrl) || spec.servers[0];
      this.afterSpecParsedAndValidated(spec);
    } catch (err) {
      this.loading = false;
      this.loadFailed = true;
      this.resolvedSpec = null;
      console.error("OpenAPI Explorer: Unable to resolve the API spec..", err);
    }
  }
  async setAuthenticationConfiguration(apiKeyId, {
    token,
    clientId,
    clientSecret,
    redirectUri
  }) {
    const securityObj = this.resolvedSpec && this.resolvedSpec.securitySchemes.find((v) => v.apiKeyId === apiKeyId);
    if (!securityObj) {
      throw Error("SecuritySchemeNotFound");
    }
    let authorizationToken = token && token.replace(/^(Bearer|Basic)\s+/i, "").trim();
    if (authorizationToken && securityObj.type && securityObj.type === "http" && securityObj.scheme && securityObj.scheme.toLowerCase() === "basic") {
      authorizationToken = `Basic ${btoa(authorizationToken)}`;
    } else if (authorizationToken && securityObj.scheme && securityObj.scheme.toLowerCase() === "bearer") {
      authorizationToken = `Bearer ${authorizationToken}`;
    } else {
      authorizationToken = null;
    }
    securityObj.clientId = clientId && clientId.trim();
    securityObj.clientSecret = clientSecret && clientSecret.trim();
    securityObj.redirectUri = new URL(redirectUri && redirectUri.trim() || "", window.location.href).toString();
    securityObj.finalKeyValue = authorizationToken;
    await checkForAuthToken.call(this);
    this.requestUpdate();
  }
  afterSpecParsedAndValidated(spec) {
    this.resolvedSpec = spec;
    if (this.operationsCollapsed) {
      this.resolvedSpec.tags.forEach((t) => t.expanded = false);
    }
    this.dispatchEvent(new CustomEvent("spec-loaded", {
      bubbles: true,
      detail: spec
    }));
    this.requestUpdate();
    this.intersectionObserver.disconnect();
    if (this.renderStyle === "focused") {
      const defaultElementId = this.showInfo ? "overview" : this.resolvedSpec.tags && this.resolvedSpec.tags[0] && this.resolvedSpec.tags[0].paths[0];
      this.scrollTo(this.explorerLocation || defaultElementId);
    }
    if (this.renderStyle === "view" && this.explorerLocation) {
      this.expandAndGotoOperation(this.explorerLocation);
    }
  }
  expandAndGotoOperation(elementId) {
    let isExpandingNeeded = false;
    const tag = this.resolvedSpec.tags.find((t) => t.paths && t.paths.find((p) => p.elementId === elementId));
    const path = tag && tag.paths && tag.paths.find((p) => p.elementId === elementId);
    if (path && (!path.expanded || !tag.expanded)) {
      isExpandingNeeded = true;
      path.expanded = true;
      tag.expanded = true;
      this.requestUpdate();
    }
    const tmpElementId = elementId.indexOf("#") === -1 ? elementId : elementId.substring(1);
    window.setTimeout(() => {
      const gotoEl = this.shadowRoot.getElementById(tmpElementId);
      if (gotoEl) {
        gotoEl.scrollIntoView({
          behavior: "auto",
          block: "start"
        });
        replaceState(tmpElementId);
      }
    }, isExpandingNeeded ? 150 : 0);
  }
  isValidTopId(id) {
    return id.startsWith("overview") || id === "servers" || id === "auth";
  }
  isValidPathId(id) {
    if (id === "overview" && this.showInfo) {
      return true;
    }
    if (id === "servers" && this.allowServerSelection) {
      return true;
    }
    if (id === "auth" && this.allowAuthentication) {
      return true;
    }
    if (id.startsWith("tag--")) {
      return this.resolvedSpec.tags && this.resolvedSpec.tags.find((tag) => tag.elementId === id);
    }
    return this.resolvedSpec.tags && this.resolvedSpec.tags.find((tag) => tag.paths.find((path) => path.elementId === id));
  }
  onIntersect(entries) {
    if (this.isIntersectionObserverActive === false) {
      return;
    }
    entries.forEach((entry) => {
      if (entry.isIntersecting && entry.intersectionRatio > 0) {
        const oldNavEl = this.shadowRoot.querySelector(".nav-bar-tag.active, .nav-bar-path.active, .nav-bar-info.active, .nav-bar-h1.active, .nav-bar-h2.active");
        const newNavEl = this.shadowRoot.getElementById(`link-${entry.target.id}`);
        if (newNavEl) {
          replaceState(entry.target.id);
          newNavEl.scrollIntoView({
            behavior: "auto",
            block: "center"
          });
          newNavEl.classList.add("active");
        }
        if (oldNavEl) {
          oldNavEl.classList.remove("active");
        }
      }
    });
  }
  handleHref(e) {
    if (e.target.tagName.toLowerCase() === "a") {
      const anchor = e.target.getAttribute("href");
      if (anchor && anchor.startsWith("#")) {
        const gotoEl = this.shadowRoot.getElementById(anchor.replace("#", ""));
        if (gotoEl) {
          gotoEl.scrollIntoView({
            behavior: "auto",
            block: "start"
          });
        }
      }
    }
  }
  scrollToEventTarget(event, scrollNavItemToView = true) {
    const navEl = event.currentTarget;
    if (!navEl.dataset.contentId) {
      return;
    }
    let repeatedElementIndex;
    if (navEl.dataset.contentId === "section") {
      const navSectionSlot = this.shadowRoot.querySelector("slot.custom-nav-section");
      const assignedNodes = navSectionSlot && navSectionSlot.assignedNodes();
      repeatedElementIndex = assignedNodes && [].findIndex.call(assignedNodes, (slot) => slot === event.target);
    }
    this.isIntersectionObserverActive = false;
    this.scrollTo(navEl.dataset.contentId, scrollNavItemToView, repeatedElementIndex);
    setTimeout(() => {
      this.isIntersectionObserverActive = true;
    }, 300);
  }
  async scrollTo(elementId, scrollNavItemToView = true, repeatedElementIndex) {
    if (!this.resolvedSpec) {
      return;
    }
    if (this.renderStyle === "view") {
      this.expandAndGotoOperation(elementId);
      return;
    }
    this.explorerLocation = elementId;
    await sleep(0);
    const contentEl = this.shadowRoot.getElementById(elementId);
    if (!contentEl) {
      return;
    }
    if (!elementId.match("cmp--")) {
      this.shadowRoot.getElementById("operations-root").scrollIntoView({
        behavior: "auto",
        block: "start"
      });
    } else {
      contentEl.scrollIntoView({
        behavior: "auto",
        block: "start"
      });
    }
    const requestEl = this.shadowRoot.querySelector("api-request");
    if (requestEl) {
      requestEl.resetRequestBodySelection();
    }
    const responseEl = this.shadowRoot.querySelector("api-response");
    if (responseEl) {
      responseEl.resetSelection();
    }
    replaceState(elementId);
    let newNavEl = this.shadowRoot.getElementById(`link-${elementId}`);
    if (elementId === "section") {
      const navSectionSlot2 = this.shadowRoot.querySelector("slot.custom-nav-section");
      const assignedNodes2 = navSectionSlot2 && navSectionSlot2.assignedNodes();
      newNavEl = assignedNodes2 && assignedNodes2[repeatedElementIndex || 0];
    }
    if (!newNavEl) {
      return;
    }
    if (scrollNavItemToView) {
      newNavEl.scrollIntoView({
        behavior: "auto",
        block: "center"
      });
    }
    await sleep(0);
    const oldNavEl = this.shadowRoot.querySelector(".nav-bar-tag.active, .nav-bar-path.active, .nav-bar-info.active, .nav-bar-h1.active, .nav-bar-h2.active");
    if (oldNavEl) {
      oldNavEl.classList.remove("active");
    }
    const navSectionSlot = this.shadowRoot.querySelector("slot.custom-nav-section");
    const assignedNodes = navSectionSlot && navSectionSlot.assignedNodes();
    (assignedNodes || []).filter((n, nodeIndex) => nodeIndex !== repeatedElementIndex).forEach((node) => {
      node.classList.remove("active");
    });
    newNavEl.classList.add("active");
    this.requestUpdate();
  }
  onAdvancedSearch(ev, delay) {
    const eventTargetEl = ev.target;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      let searchInputEl;
      if (eventTargetEl.type === "text") {
        searchInputEl = eventTargetEl;
      } else {
        searchInputEl = eventTargetEl.closest(".advanced-search-options").querySelector("input[type=text]");
      }
      const searchOptions = [...eventTargetEl.closest(".advanced-search-options").querySelectorAll("input:checked")].map((v) => v.id);
      this.advancedSearchMatches = advancedSearch(searchInputEl.value, this.resolvedSpec.tags, searchOptions);
    }, delay);
  }
};
if (!customElements.get("openapi-explorer")) {
  customElements.define("openapi-explorer", OpenApiExplorer);
}

// dep:openapi-explorer
var openapi_explorer_default = OpenApiExplorer;
export {
  openapi_explorer_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*! https://mths.be/punycode v1.3.2 by @mathias */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=openapi-explorer.js.map
